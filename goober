execve("/usr/bin/gem1.8", ["gem1.8", "build", "yahoo"], [/* 39 vars */]) = 0
brk(0)                                  = 0x9db8000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7862000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/etc/ld.so.cache", O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=60535, ...}) = 0
mmap2(NULL, 60535, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7853000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/usr/lib/libruby1.8.so.1.8", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\0!\1\0004\0\0\0p\363\f\0\0\0\0\0004\0 \0\7\0(\0\34\0\33\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$\317\f\0$\317\f\0\5\0\0\0\0\20\0\0\1\0\0\0t\323\f\0t\343\f\0t\343\f\0\370\36\0\0\4#\1\0\6\0\0\0\0\20\0\0\2\0\0\0\210\332\f\0\210\352\f\0\210\352\f\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0\24\1\0\0\24\1\0\0\24\1\0\0$\0\0\0$\0\0\0\4\0\0\0\4\0\0\0P\345td\254\316\f\0\254\316\f\0\254\316\f\0\34\0\0\0\34\0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345tdt\323\f\0t\343\f\0t\343\f\0\214\f\0\0\214\f\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\310\215H\253\232G\314\362\204\222\n\v\252\365\2752,^_\24\7\4\0\0\37\4\0\0\0\0\0\0\220\2\0\0\356\1\0\0\0\0\0\0\306\0\0\0\374\2\0\0R\2\0\0\0\0\0\0\0\0\0\0z\0\0\0\0\0\0\0\356\0\0\0005\3\0\0\201\0\0\0X\1\0\0\0\0\0\0\v\4\0\0\372\0\0\0*\1\0\0\0\0\0\0006\3\0\0\233\2\0\0001\2\0\0$\1\0\0\0\0\0\0\0\0\0\0\253\1\0\0\0\0\0\0\356\2\0\0\0\0\0\0\0\0\0\0\23\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\227\2\0\0\0\0\0\0\0\0\0\0\354\1\0\0\0\0\0\0\332\1\0\0\f\3\0\0\263\0\0\0008\0\0\0}\1\0\0\270\2\0\0|\0\0\0\325\1\0\0", 512) = 512
fstat64(3, {st_mode=S_IFREG|0644, st_size=849872, ...}) = 0
mmap2(NULL, 919160, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x622000
mprotect(0x6ef000, 4096, PROT_NONE)     = 0
mmap2(0x6f0000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0xcd) = 0x6f0000
mmap2(0x6f3000, 63096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x6f3000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0PI\0\0004\0\0\0\0T\1\0\0\0\0\0004\0 \0\t\0(\0&\0#\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0,\17\1\0,\17\1\0,\17\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0004@\1\0004@\1\0\5\0\0\0\0\20\0\0\1\0\0\0\260M\1\0\260]\1\0\260]\1\0\210\3\0\0008$\0\0\6\0\0\0\0\20\0\0\2\0\0\0\264N\1\0\264^\1\0\264^\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0D\0\0\0D\0\0\0\4\0\0\0\4\0\0\0P\345td@\17\1\0@\17\1\0@\17\1\0\f\5\0\0\f\5\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\260M\1\0\260]\1\0\260]\1\0P\2\0\0P\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0X\250\361\205r\251\2709\342i\343{\f\360\215\347\377F\253\201\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\17\0\0\0\262\1\0\0M\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2", 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=116920, ...}) = 0
mmap2(NULL, 98792, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x786000
mmap2(0x79b000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x14) = 0x79b000
mmap2(0x79d000, 4584, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x79d000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/tls/i686/cmov/librt.so.1", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\300\30\0\0004\0\0\0\264r\0\0\0\0\0\0004\0 \0\t\0(\0!\0 \0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0HZ\0\0HZ\0\0HZ\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0xb\0\0xb\0\0\5\0\0\0\0\20\0\0\1\0\0\0\314n\0\0\314~\0\0\314~\0\0\234\2\0\0\210\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\350n\0\0\350~\0\0\350~\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0D\0\0\0D\0\0\0\4\0\0\0\4\0\0\0P\345td\\Z\0\0\\Z\0\0\\Z\0\0t\0\0\0t\0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\314n\0\0\314~\0\0\314~\0\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0>\25\244\223H\260x1\366\r\306\201\313\270\360\3\362\264\252I\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\17\0\0\0O\0\0\0?\0\0\0\10\0\0\0\10\0\0\0\21A\0041\250\f(\2\10Q\34\213\0\0242\340\250J\2\222\0`P i\2\307\366\0\21D\7\0\0\0\0\0\0\0\0?\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0A\0\0\0\0\0\0\0B\0\0\0C\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
fstat64(3, {st_mode=S_IFREG|0644, st_size=30684, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7852000
mmap2(NULL, 33364, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xec5000
mmap2(0xecc000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x6) = 0xecc000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\n\0\0004\0\0\0X!\0\0\0\0\0\0004\0 \0\10\0(\0\36\0\35\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0G\32\0\0G\32\0\0G\32\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\34\0\0\f\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\220\1\0\0\304\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0D\0\0\0D\0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0L\1\0\0L\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\324\rR\375\246I\20\5h5(\10\325\347\325Pj\250\337{\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\17\0\0\0\26\0\0\0\30\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\30\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\31\0\0\0\0\0\0\0\32\0\0\0\33\0\0\0\0\0\0\0\35\0\0\0\0\0\0\0\0\0\0\0\36\0\0\0 \0\0\0!\0\0\0\0\0\0\0\0\0\0\0\"\0\0\0$\0\0\0%\0\0\0\0\0\0\0'\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371", 512) = 512
fstat64(3, {st_mode=S_IFREG|0644, st_size=9736, ...}) = 0
mmap2(NULL, 12408, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x820000
mmap2(0x822000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1) = 0x822000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0P\7\0\0004\0\0\0P\221\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\240\202\0\0\240\202\0\0\240\202\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\314\203\0\0\314\203\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\\\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0D\0\0\0D\0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\32u'v\v\300\vo\240w\207\234\363v\17\265H\206w?\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\17\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Z\0\0\0", 512) = 512
fstat64(3, {st_mode=S_IFREG|0644, st_size=38360, ...}) = 0
mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x1d3000
mmap2(0x1dc000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x8) = 0x1dc000
mmap2(0x1de000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x1de000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0`4\0\0004\0\0\0hB\2\0\0\0\0\0004\0 \0\t\0(\0!\0 \0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\230\23\2\0\230\23\2\0\230\23\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2142\2\0\2142\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334N\2\0\334N\2\0\\\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360N\2\0\360N\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0D\0\0\0D\0\0\0\4\0\0\0\4\0\0\0P\345td\254\23\2\0\254\23\2\0\254\23\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334N\2\0\334N\2\0$\1\0\0$\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0!\247.A\353\311S\"\267\317\342\306\\*_\243\347\374XA\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\17\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310", 512) = 512
fstat64(3, {st_mode=S_IFREG|0644, st_size=149392, ...}) = 0
mmap2(NULL, 151680, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xee9000
mmap2(0xf0d000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x23) = 0xf0d000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260l\1\0004\0\0\0\374\26\24\0\0\0\0\0004\0 \0\n\0(\0E\0D\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\360\200\22\0\360\200\22\0\360\200\22\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20\336\23\0\20\336\23\0\5\0\0\0\0\20\0\0\1\0\0\0\310\341\23\0\310\361\23\0\310\361\23\0\264'\0\0\240W\0\0\6\0\0\0\0\20\0\0\2\0\0\0|\375\23\0|\r\24\0|\r\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0D\0\0\0D\0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\310\341\23\0\310\361\23\0\310\361\23\0\10\0\0\0@\0\0\0\4\0\0\0\4\0\0\0P\345td\4\201\22\0\4\201\22\0\4\201\22\0\3141\0\0\3141\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\310\341\23\0\310\361\23\0\310\361\23\0008\36\0\0008\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\207v\244\270'\n\\\201\\\16\361p\355Lt\300\335\241_F\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\17\0\0\0\363\3\0\0\t\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0E\200\0`\300\200\0\f\212\f\0\0010\0\10@2\10\256\4\210H6l\240\0260\0&\204\200\216\4\10B$", 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=1319364, ...}) = 0
mmap2(NULL, 1329512, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xad6000
mprotect(0xc14000, 4096, PROT_NONE)     = 0
mmap2(0xc15000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x13e) = 0xc15000
mmap2(0xc18000, 10600, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xc18000
close(3)                                = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7851000
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7850000
set_thread_area({entry_number:-1 -> 6, base_addr:0xb78506c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
mprotect(0xc15000, 8192, PROT_READ)     = 0
mprotect(0xf0d000, 4096, PROT_READ)     = 0
mprotect(0x1dc000, 4096, PROT_READ)     = 0
mprotect(0x822000, 4096, PROT_READ)     = 0
mprotect(0xecc000, 4096, PROT_READ)     = 0
mprotect(0x79b000, 4096, PROT_READ)     = 0
mprotect(0x6f0000, 4096, PROT_READ)     = 0
mprotect(0x8049000, 4096, PROT_READ)    = 0
mprotect(0xd41000, 4096, PROT_READ)     = 0
munmap(0xb7853000, 60535)               = 0
set_tid_address(0xb7850728)             = 7383
set_robust_list(0xb7850730, 0xc)        = 0
futex(0xbfe55640, FUTEX_WAKE_PRIVATE, 1) = 0
futex(0xbfe55640, 0x189 /* FUTEX_??? */, 1, NULL, bfe55650) = -1 EAGAIN (Resource temporarily unavailable)
rt_sigaction(SIGRTMIN, {0x78a340, [], SA_SIGINFO}, NULL, 8) = 0
rt_sigaction(SIGRT_1, {0x78a820, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
uname({sys="Linux", node="catlow", ...}) = 0
getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
brk(0)                                  = 0x9db8000
brk(0x9dd9000)                          = 0x9dd9000
mmap2(NULL, 200704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb781f000
sigprocmask(SIG_BLOCK, NULL, [])        = 0
brk(0x9dfa000)                          = 0x9dfa000
open("/dev/urandom", O_RDONLY|O_NOCTTY|O_NONBLOCK|O_LARGEFILE|O_NOFOLLOW) = 3
fstat64(3, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 9), ...}) = 0
read(3, "\2021\210m\332\377/}\254G~\0100z\265w", 16) = 16
close(3)                                = 0
gettimeofday({1263334812, 86440}, NULL) = 0
rt_sigaction(SIGINT, {0x6bb440, [], 0}, {SIG_DFL, [], 0}, 8) = 0
rt_sigaction(SIGHUP, {0x6bb440, [], 0}, {SIG_DFL, [], 0}, 8) = 0
rt_sigaction(SIGQUIT, {0x6bb440, [], 0}, {SIG_DFL, [], 0}, 8) = 0
rt_sigaction(SIGTERM, {0x6bb440, [], 0}, {SIG_DFL, [], 0}, 8) = 0
rt_sigaction(SIGALRM, {0x6bb440, [], 0}, {SIG_DFL, [], 0}, 8) = 0
rt_sigaction(SIGUSR1, {0x6bb440, [], 0}, {SIG_DFL, [], 0}, 8) = 0
rt_sigaction(SIGUSR2, {0x6bb440, [], 0}, {SIG_DFL, [], 0}, 8) = 0
rt_sigaction(SIGBUS, {0x6bb340, [], 0}, {SIG_DFL, [], 0}, 8) = 0
rt_sigaction(SIGSEGV, {0x6bb2e0, [], 0}, {SIG_DFL, [], 0}, 8) = 0
rt_sigaction(SIGPIPE, {0x6bb0b0, [], 0}, {SIG_DFL, [], 0}, 8) = 0
rt_sigprocmask(SIG_BLOCK, ~[RTMIN RT_1], [], 8) = 0
rt_sigaction(SIGCHLD, {SIG_DFL, [], 0}, {SIG_DFL, [], 0}, 8) = 0
rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
geteuid32()                             = 1000
getegid32()                             = 1000
getuid32()                              = 1000
geteuid32()                             = 1000
getgid32()                              = 1000
getegid32()                             = 1000
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/bin/gem1.8", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/bin/gem1.8", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0755, st_size=545, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "#!/usr/bin/ruby1.8\n#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\nrequire 'rubygems'\nrequire 'rubygems/gem_runner'\nrequire 'rubygems/exceptions'\n\nrequired_version = Gem::Requirement.new \"> 1.8.3\"\n\nunless required_version.satisfied_by? Gem.ruby_version then\n  abort \"Expected Ruby Version #{required_version}, was #{Gem.ruby_version}\"\nend\n\nargs = ARGV.clone\n\nbegin\n  Gem::GemRunner.new.run args\nrescue Gem::SystemExitException => e\n  exit e.exit_code\nend\n\n", 4096) = 545
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems.rb", {st_mode=S_IFREG|0644, st_size=29096, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=29096, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems.rb", {st_mode=S_IFREG|0644, st_size=29096, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=29096, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=29096, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=29096, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "# -*- ruby -*-\n#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\nrequire 'rubygems/defaults'\nrequire 'thread'\nrequire 'etc'\n\nmodule Gem\n\n  RubyGemsVersion = VERSION = '1.3.5'\n\n  ##\n  # Raised when RubyGems is unable to load or activate a gem.  Contains the\n  # name and version requirements of the gem that either conflicts with\n  # already activated gems or that RubyGems is otherwise unable to activate.\n\n  class LoadError < ::LoadError\n\n    ##\n    # Name of gem\n\n    attr_accessor :name\n\n    ##\n    # Version requirement of gem\n\n    attr_accessor :version_requirement\n\n  end\n\nend\n\nmodule Kernel\n\n  ##\n  # Use Kernel#gem to activate a specific version of +gem_name+.\n  #\n  # +version_requirements+ is a list of version requirements that the\n  # specified gem must match, most commonly \"= example.version.number\".  See\n  # Gem::Requirement for how to specify a version requirement.\n  #\n  # If you will be activating the latest version of a gem, there is no need to\n  # call Kernel#gem, Kernel#require will do the right thing for you.\n  #\n  # Kernel#gem returns true if the gem was activated, otherwise false.  If the\n  # gem could not be found, didn't match the version requirements, or a\n  # different version was already activated, an exception will be raised.\n  #\n  # Kernel#gem should be called *before* any require statements (otherwise\n  # RubyGems may load a conflicting library version).\n  #\n  # In older RubyGems versions, the environment variable GEM_SKIP could be\n  # used to skip activation of specified gems, for example to test out changes\n  # that haven't been installed yet.  Now RubyGems defers to -I and the\n  # RUBYLIB environment variable to skip activation of a gem.\n  #\n  # Example:\n  #\n  #   GEM_SKIP=libA:libB ruby -I../libA -I../libB ./mycode.rb\n\n  def gem(gem_name, *version_requirements) # :doc:\n    skip_list = (ENV['GEM_SKIP'] || \"\").split(/:/)\n    raise Gem::LoadError, \"skipping #{gem_name}\" if skip_list.include? gem_name\n    Gem.activate(gem_name, *version_requirements)\n  end\n\n  private :gem\n\nend\n\n##\n# RubyGems is the Ruby standard for publishing and managing third party\n# libraries.\n#\n# For user documentation, see:\n#\n# * <tt>gem help</tt> and <tt>gem help [command]</tt>\n# * {RubyGems User Guide}[http://docs.rubygems.org/read/book/1]\n# * {Frequently Asked Questions}[http://docs.rubygems.org/read/book/3]\n#\n# For gem developer documentation see:\n#\n# * {Creating Gems}[http://docs.rubygems.org/read/chapter/5]\n# * Gem::Specification\n#\n# Further RubyGems documentation can be found at:\n#\n# * {RubyGems API}[http://rubygems.rubyforge.org/rdoc] (also available from\n#   <tt>gem server</tt>)\n# * {RubyGems Bookshelf}[http://rubygem.org]\n#\n# == RubyGems Plugins\n#\n# As of RubyGems 1.3.2, RubyGems will load plugins installed in gems or\n# $LOAD_PATH.  Plugins must be named 'rubygems_plugin' are discovered via\n# Gem::find_files then loaded.  Take care when implementing a plugin as your\n# plugin file may be loaded multiple times if multiple versions of your gem\n# are installed.\n#\n# For an example plugin, see the graph gem which adds a `gem graph` command.\n#\n# == RubyGems Defaults, Packaging\n#\n# RubyGems defaults are stored in rubygems/defaults.rb.  If you're packaging\n# RubyGems or implementing Ruby you can change RubyGems' defaults.\n#\n# For RubyGems packagers, provide lib/rubygems/operating_system.rb and\n# override any defaults from lib/rubygems/defaults.rb.\n#\n# For Ruby implementers, provide lib/rubygems/#{RUBY_ENGINE}.rb and override\n# any defaults from lib/rubygems/defaults.rb.\n#\n# If you need RubyGems to perform extra work on install or uninstall, your\n# defaults override file can set pre and post install and uninstall hooks.\n# See Gem::pre_install, Gem::pre_uninstall, Gem::post_install,\n# Gem::post_uninstall.\n#\n# == Bugs\n#\n# You can submit bugs to the\n# {RubyGems bug tracker}[http://rubyforge.org/tracker/?atid=575&group_id=126&func=browse]\n# on RubyForge"..., 4096) = 4096
read(3, "developed at RubyConf 2003 by:\n#\n# * Rich Kilmer -- rich(at)infoether.com\n# * Chad Fowler -- chad(at)chadfowler.com\n# * David Black -- dblack(at)wobblini.net\n# * Paul Brannan -- paul(at)atdesk.com\n# * Jim Weirch -- {jim(at)weirichhouse.org}[mailto:jim@weirichhouse.org]\n#\n# Contributors:\n#\n# * Gavin Sinclair -- gsinclair(at)soyabean.com.au\n# * George Marrows -- george.marrows(at)ntlworld.com\n# * Dick Davies -- rasputnik(at)hellooperator.net\n# * Mauricio Fernandez -- batsman.geo(at)yahoo.com\n# * Simon Strandgaard -- neoneye(at)adslhome.dk\n# * Dave Glasser -- glasser(at)mit.edu\n# * Paul Duncan -- pabs(at)pablotron.org\n# * Ville Aine -- vaine(at)cs.helsinki.fi\n# * Eric Hodel -- drbrain(at)segment7.net\n# * Daniel Berger -- djberg96(at)gmail.com\n# * Phil Hagelberg -- technomancy(at)gmail.com\n# * Ryan Davis\n#\n# (If your name is missing, PLEASE let us know!)\n#\n# Thanks!\n#\n# -The RubyGems Team\n\nmodule Gem\n\n  ##\n  # Configuration settings from ::RbConfig\n\n  ConfigMap = {} unless defined?(ConfigMap)\n\n  require 'rbconfig'\n  # :stopdoc:\n  RbConfig = Config unless defined? ::RbConfig\n  # :startdoc:\n\n  ConfigMap.merge!(\n    :EXEEXT => RbConfig::CONFIG[\"EXEEXT\"],\n    :RUBY_SO_NAME => RbConfig::CONFIG[\"RUBY_SO_NAME\"],\n    :arch => RbConfig::CONFIG[\"arch\"],\n    :bindir => RbConfig::CONFIG[\"bindir\"],\n    :datadir => RbConfig::CONFIG[\"datadir\"],\n    :libdir => RbConfig::CONFIG[\"libdir\"],\n    :ruby_install_name => RbConfig::CONFIG[\"ruby_install_name\"],\n    :ruby_version => RbConfig::CONFIG[\"ruby_version\"],\n    :sitedir => RbConfig::CONFIG[\"sitedir\"],\n    :sitelibdir => RbConfig::CONFIG[\"sitelibdir\"],\n    :vendordir => RbConfig::CONFIG[\"vendordir\"] ,\n    :vendorlibdir => RbConfig::CONFIG[\"vendorlibdir\"]\n  )\n\n  ##\n  # Default directories in a gem repository\n\n  DIRECTORIES = %w[cache doc gems specifications] unless defined?(DIRECTORIES)\n\n  # :stopdoc:\n  MUTEX = Mutex.new\n\n  RubyGemsPackageVersion = RubyGemsVersion\n  # :startdoc:\n\n  ##\n  # An Array of Regexps that match windows ruby platforms.\n\n  WIN_PATTERNS = [\n    /bccwin/i,\n    /cygwin/i,\n    /djgpp/i,\n    /mingw/i,\n    /mswin/i,\n    /wince/i,\n  ]\n\n  @@source_index = nil\n  @@win_platform = nil\n\n  @configuration = nil\n  @loaded_specs = {}\n  @loaded_stacks = {}\n  @platforms = []\n  @ruby = nil\n  @sources = []\n\n  @post_install_hooks   ||= []\n  @post_uninstall_hooks ||= []\n  @pre_uninstall_hooks  ||= []\n  @pre_install_hooks    ||= []\n\n  ##\n  # Activates an installed gem matching +gem+.  The gem must satisfy\n  # +version_requirements+.\n  #\n  # Returns true if the gem is activated, false if it is already\n  # loaded, or an exception otherwise.\n  #\n  # Gem#activate adds the library paths in +gem+ to $LOAD_PATH.  Before a Gem\n  # is activated its required Gems are activated.  If the version information\n  # is omitted, the highest version Gem of the supplied name is loaded.  If a\n  # Gem is not found that meets the version requirements or a required Gem is\n  # not found, a Gem::LoadError is raised.\n  #\n  # More information on version requirements can be found in the\n  # Gem::Requirement and Gem::Version documentation.\n\n  def self.activate(gem, *version_requirements)\n    if version_requirements.last.is_a?(Hash)\n      options = version_requirements.pop\n    else\n      options = {}\n    end\n\n    sources = options[:sources] || []\n\n    if version_requirements.empty? then\n      version_requirements = Gem::Requirement.default\n    end\n\n    unless gem.respond_to?(:name) and\n           gem.respond_to?(:version_requirements) then\n      gem = Gem::Dependency.new(gem, version_requirements)\n    end\n\n    matches = Gem.source_index.find_name(gem.name, gem.version_requirements)\n    report_activate_error(gem) if matches.empty?\n\n    if @loaded_specs[gem.name] then\n      # This gem is already loaded.  If the currently loaded gem is not in the\n      # list of candidate gems, then we have a version conflict.\n      existing_spec = @loaded_specs[gem.name]\n\n      unless matches.any? { |spec| spec.version == existing_spec.version } the"..., 4096) = 4096
read(3, "ded_stacks[gem.name].map { |spec| spec.full_name }\n\n         msg = \"can't activate #{gem} for #{sources_message.inspect}, \"\n         msg << \"already activated #{existing_spec.full_name} for \"\n         msg << \"#{stack_message.inspect}\"\n\n         e = Gem::LoadError.new msg\n         e.name = gem.name\n         e.version_requirement = gem.version_requirements\n\n         raise e\n      end\n\n      return false\n    end\n\n    # new load\n    spec = matches.last\n    return false if spec.loaded?\n\n    spec.loaded = true\n    @loaded_specs[spec.name] = spec\n    @loaded_stacks[spec.name] = sources.dup\n\n    # Load dependent gems first\n    spec.runtime_dependencies.each do |dep_gem|\n      activate dep_gem, :sources => [spec, *sources]\n    end\n\n    # bin directory must come before library directories\n    spec.require_paths.unshift spec.bindir if spec.bindir\n\n    require_paths = spec.require_paths.map do |path|\n      File.join spec.full_gem_path, path\n    end\n\n    sitelibdir = ConfigMap[:sitelibdir]\n\n    # gem directories must come after -I and ENV['RUBYLIB']\n    insert_index = load_path_insert_index\n\n    if insert_index then\n      # gem directories must come after -I and ENV['RUBYLIB']\n      $LOAD_PATH.insert(insert_index, *require_paths)\n    else\n      # we are probably testing in core, -I and RUBYLIB don't apply\n      $LOAD_PATH.unshift(*require_paths)\n    end\n\n    return true\n  end\n\n  ##\n  # An Array of all possible load paths for all versions of all gems in the\n  # Gem installation.\n\n  def self.all_load_paths\n    result = []\n\n    Gem.path.each do |gemdir|\n      each_load_path all_partials(gemdir) do |load_path|\n        result << load_path\n      end\n    end\n\n    result\n  end\n\n  ##\n  # Return all the partial paths in +gemdir+.\n\n  def self.all_partials(gemdir)\n    Dir[File.join(gemdir, 'gems/*')]\n  end\n\n  private_class_method :all_partials\n\n  ##\n  # See if a given gem is available.\n\n  def self.available?(gem, *requirements)\n    requirements = Gem::Requirement.default if requirements.empty?\n\n    unless gem.respond_to?(:name) and\n           gem.respond_to?(:version_requirements) then\n      gem = Gem::Dependency.new gem, requirements\n    end\n\n    !Gem.source_index.search(gem).empty?\n  end\n\n  ##\n  # Find the full path to the executable for gem +name+.  If the +exec_name+\n  # is not given, the gem's default_executable is chosen, otherwise the\n  # specifed executable's path is returned.  +version_requirements+ allows you\n  # to specify specific gem versions.\n\n  def self.bin_path(name, exec_name = nil, *version_requirements)\n    version_requirements = Gem::Requirement.default if\n      version_requirements.empty?\n    spec = Gem.source_index.find_name(name, version_requirements).last\n\n    raise Gem::GemNotFoundException,\n          \"can't find gem #{name} (#{version_requirements})\" unless spec\n\n    exec_name ||= spec.default_executable\n\n    unless exec_name\n      msg = \"no default executable for #{spec.full_name}\"\n      raise Gem::Exception, msg\n    end\n\n    unless spec.executables.include? exec_name\n      msg = \"can't find executable #{exec_name} for #{spec.full_name}\"\n      raise Gem::Exception, msg\n    end\n\n    File.join(spec.full_gem_path, spec.bindir, exec_name)\n  end\n\n  ##\n  # The mode needed to read a file as straight binary.\n\n  def self.binary_mode\n    @binary_mode ||= RUBY_VERSION > '1.9' ? 'rb:ascii-8bit' : 'rb'\n  end\n\n  ##\n  # The path where gem executables are to be installed.\n\n  def self.bindir(install_dir=Gem.dir)\n    return File.join(install_dir, 'bin') unless\n      install_dir.to_s == Gem.default_dir\n    Gem.default_bindir\n  end\n\n  ##\n  # Reset the +dir+ and +path+ values.  The next time +dir+ or +path+\n  # is requested, the values will be calculated from scratch.  This is\n  # mainly used by the unit tests to provide test isolation.\n\n  def self.clear_paths\n    @gem_home = nil\n    @gem_path = nil\n    @user_home = nil\n\n    @@source_index = nil\n\n    MUTEX.synchronize do\n      @searcher = nil\n    end\n  end\n\n  ##\n  # The path to standard location"..., 4096) = 4096
brk(0x9e1b000)                          = 0x9e1b000
read(3, "\n  ##\n  # The standard configuration object for gems.\n\n  def self.configuration\n    @configuration ||= Gem::ConfigFile.new []\n  end\n\n  ##\n  # Use the given configuration object (which implements the ConfigFile\n  # protocol) as the standard configuration object.\n\n  def self.configuration=(config)\n    @configuration = config\n  end\n\n  ##\n  # The path the the data directory specified by the gem name.  If the\n  # package is not available as a gem, return nil.\n\n  def self.datadir(gem_name)\n    spec = @loaded_specs[gem_name]\n    return nil if spec.nil?\n    File.join(spec.full_gem_path, 'data', gem_name)\n  end\n\n  ##\n  # A Zlib::Deflate.deflate wrapper\n\n  def self.deflate(data)\n    require 'zlib'\n    Zlib::Deflate.deflate data\n  end\n\n  ##\n  # The path where gems are to be installed.\n\n  def self.dir\n    @gem_home ||= nil\n    set_home(ENV['GEM_HOME'] || Gem.configuration.home || default_dir) unless @gem_home\n    @gem_home\n  end\n\n  ##\n  # Expand each partial gem path with each of the required paths specified\n  # in the Gem spec.  Each expanded path is yielded.\n\n  def self.each_load_path(partials)\n    partials.each do |gp|\n      base = File.basename(gp)\n      specfn = File.join(dir, \"specifications\", base + \".gemspec\")\n      if File.exist?(specfn)\n        spec = eval(File.read(specfn))\n        spec.require_paths.each do |rp|\n          yield(File.join(gp, rp))\n        end\n      else\n        filename = File.join(gp, 'lib')\n        yield(filename) if File.exist?(filename)\n      end\n    end\n  end\n\n  private_class_method :each_load_path\n\n  ##\n  # Quietly ensure the named Gem directory contains all the proper\n  # subdirectories.  If we can't create a directory due to a permission\n  # problem, then we will silently continue.\n\n  def self.ensure_gem_subdirectories(gemdir)\n    require 'fileutils'\n\n    Gem::DIRECTORIES.each do |filename|\n      fn = File.join gemdir, filename\n      FileUtils.mkdir_p fn rescue nil unless File.exist? fn\n    end\n  end\n\n  ##\n  # Returns a list of paths matching +file+ that can be used by a gem to pick\n  # up features from other gems.  For example:\n  #\n  #   Gem.find_files('rdoc/discover').each do |path| load path end\n  #\n  # find_files search $LOAD_PATH for files as well as gems.\n  #\n  # Note that find_files will return all files even if they are from different\n  # versions of the same gem.\n\n  def self.find_files(path)\n    load_path_files = $LOAD_PATH.map do |load_path|\n      files = Dir[\"#{File.expand_path path, load_path}#{Gem.suffix_pattern}\"]\n\n      files.select do |load_path_file|\n        File.file? load_path_file.untaint\n      end\n    end.flatten\n\n    specs = searcher.find_all path\n\n    specs_files = specs.map do |spec|\n      searcher.matching_files spec, path\n    end.flatten\n\n    (load_path_files + specs_files).flatten.uniq\n  end\n\n  ##\n  # Finds the user's home directory.\n  #--\n  # Some comments from the ruby-talk list regarding finding the home\n  # directory:\n  #\n  #   I have HOME, USERPROFILE and HOMEDRIVE + HOMEPATH. Ruby seems\n  #   to be depending on HOME in those code samples. I propose that\n  #   it should fallback to USERPROFILE and HOMEDRIVE + HOMEPATH (at\n  #   least on Win32).\n\n  def self.find_home\n    ['HOME', 'USERPROFILE'].each do |homekey|\n      return ENV[homekey] if ENV[homekey]\n    end\n\n    if ENV['HOMEDRIVE'] && ENV['HOMEPATH'] then\n      return \"#{ENV['HOMEDRIVE']}#{ENV['HOMEPATH']}\"\n    end\n\n    begin\n      File.expand_path(\"~\")\n    rescue\n      if File::ALT_SEPARATOR then\n          \"C:/\"\n      else\n          \"/\"\n      end\n    end\n  end\n\n  private_class_method :find_home\n\n  ##\n  # Zlib::GzipReader wrapper that unzips +data+.\n\n  def self.gunzip(data)\n    require 'stringio'\n    require 'zlib'\n    data = StringIO.new data\n\n    Zlib::GzipReader.new(data).read\n  end\n\n  ##\n  # Zlib::GzipWriter wrapper that zips +data+.\n\n  def self.gzip(data)\n    require 'stringio'\n    require 'zlib'\n    zipped = StringIO.new\n\n    Zlib::GzipWriter.wrap zipped do |io| io.write data end\n\n    zipped.string\n  end\n\n  ##\n  "..., 4096) = 4096
read(3, ".inflate data\n  end\n\n  ##\n  # Return a list of all possible load paths for the latest version for all\n  # gems in the Gem installation.\n\n  def self.latest_load_paths\n    result = []\n\n    Gem.path.each do |gemdir|\n      each_load_path(latest_partials(gemdir)) do |load_path|\n        result << load_path\n      end\n    end\n\n    result\n  end\n\n  ##\n  # Return only the latest partial paths in the given +gemdir+.\n\n  def self.latest_partials(gemdir)\n    latest = {}\n    all_partials(gemdir).each do |gp|\n      base = File.basename(gp)\n      if base =~ /(.*)-((\\d+\\.)*\\d+)/ then\n        name, version = $1, $2\n        ver = Gem::Version.new(version)\n        if latest[name].nil? || ver > latest[name][0]\n          latest[name] = [ver, gp]\n        end\n      end\n    end\n    latest.collect { |k,v| v[1] }\n  end\n\n  private_class_method :latest_partials\n\n  ##\n  # The index to insert activated gem paths into the $LOAD_PATH.\n  #\n  # Defaults to the site lib directory unless gem_prelude.rb has loaded paths,\n  # then it inserts the activated gem's paths before the gem_prelude.rb paths\n  # so you can override the gem_prelude.rb default $LOAD_PATH paths.\n\n  def self.load_path_insert_index\n    index = $LOAD_PATH.index ConfigMap[:sitelibdir]\n\n    $LOAD_PATH.each_with_index do |path, i|\n      if path.instance_variables.include?(:@gem_prelude_index) or\n        path.instance_variables.include?('@gem_prelude_index') then\n        index = i\n        break\n      end\n    end\n\n    index\n  end\n\n  ##\n  # The file name and line number of the caller of the caller of this method.\n\n  def self.location_of_caller\n    caller[1] =~ /(.*?):(\\d+).*?$/i\n    file = $1\n    lineno = $2.to_i\n\n    [file, lineno]\n  end\n\n  ##\n  # The version of the Marshal format for your Ruby.\n\n  def self.marshal_version\n    \"#{Marshal::MAJOR_VERSION}.#{Marshal::MINOR_VERSION}\"\n  end\n\n  ##\n  # Array of paths to search for Gems.\n\n  def self.path\n    @gem_path ||= nil\n\n    unless @gem_path then\n      paths = [ENV['GEM_PATH'] || Gem.configuration.path || default_path]\n\n      if defined?(APPLE_GEM_HOME) and not ENV['GEM_PATH'] then\n        paths << APPLE_GEM_HOME\n      end\n\n      set_paths paths.compact.join(File::PATH_SEPARATOR)\n    end\n\n    @gem_path\n  end\n\n  ##\n  # Set array of platforms this RubyGems supports (primarily for testing).\n\n  def self.platforms=(platforms)\n    @platforms = platforms\n  end\n\n  ##\n  # Array of platforms this RubyGems supports.\n\n  def self.platforms\n    @platforms ||= []\n    if @platforms.empty?\n      @platforms = [Gem::Platform::RUBY, Gem::Platform.local]\n    end\n    @platforms\n  end\n\n  ##\n  # Adds a post-install hook that will be passed an Gem::Installer instance\n  # when Gem::Installer#install is called\n\n  def self.post_install(&hook)\n    @post_install_hooks << hook\n  end\n\n  ##\n  # Adds a post-uninstall hook that will be passed a Gem::Uninstaller instance\n  # and the spec that was uninstalled when Gem::Uninstaller#uninstall is\n  # called\n\n  def self.post_uninstall(&hook)\n    @post_uninstall_hooks << hook\n  end\n\n  ##\n  # Adds a pre-install hook that will be passed an Gem::Installer instance\n  # when Gem::Installer#install is called\n\n  def self.pre_install(&hook)\n    @pre_install_hooks << hook\n  end\n\n  ##\n  # Adds a pre-uninstall hook that will be passed an Gem::Uninstaller instance\n  # and the spec that will be uninstalled when Gem::Uninstaller#uninstall is\n  # called\n\n  def self.pre_uninstall(&hook)\n    @pre_uninstall_hooks << hook\n  end\n\n  ##\n  # The directory prefix this RubyGems was installed at.\n\n  def self.prefix\n    prefix = File.dirname File.expand_path(__FILE__)\n\n    if File.dirname(prefix) == File.expand_path(ConfigMap[:sitelibdir]) or\n       File.dirname(prefix) == File.expand_path(ConfigMap[:libdir]) or\n       'lib' != File.basename(prefix) then\n      nil\n    else\n      File.dirname prefix\n    end\n  end\n\n  ##\n  # Promotes the load paths of the +gem_name+ over the load paths of\n  # +over_name+.  Useful for allowing one gem to override features in another\n  # using #"..., 4096) = 4096
read(3, "me]\n    over = Gem.loaded_specs[over_name]\n\n    raise ArgumentError, \"gem #{gem_name} is not activated\" if gem.nil?\n    raise ArgumentError, \"gem #{over_name} is not activated\" if over.nil?\n\n    last_gem_path = File.join gem.full_gem_path, gem.require_paths.last\n\n    over_paths = over.require_paths.map do |path|\n      File.join over.full_gem_path, path\n    end\n\n    over_paths.each do |path|\n      $LOAD_PATH.delete path\n    end\n\n    gem = $LOAD_PATH.index(last_gem_path) + 1\n\n    $LOAD_PATH.insert(gem, *over_paths)\n  end\n\n  ##\n  # Refresh source_index from disk and clear searcher.\n\n  def self.refresh\n    source_index.refresh!\n\n    MUTEX.synchronize do\n      @searcher = nil\n    end\n  end\n\n  ##\n  # Safely read a file in binary mode on all platforms.\n\n  def self.read_binary(path)\n    File.open path, binary_mode do |f| f.read end\n  end\n\n  ##\n  # Report a load error during activation.  The message of load error\n  # depends on whether it was a version mismatch or if there are not gems of\n  # any version by the requested name.\n\n  def self.report_activate_error(gem)\n    matches = Gem.source_index.find_name(gem.name)\n\n    if matches.empty? then\n      error = Gem::LoadError.new(\n          \"Could not find RubyGem #{gem.name} (#{gem.version_requirements})\\n\")\n    else\n      error = Gem::LoadError.new(\n          \"RubyGem version error: \" +\n          \"#{gem.name}(#{matches.first.version} not #{gem.version_requirements})\\n\")\n    end\n\n    error.name = gem.name\n    error.version_requirement = gem.version_requirements\n    raise error\n  end\n\n  private_class_method :report_activate_error\n\n  ##\n  # Full path to +libfile+ in +gemname+.  Searches for the latest gem unless\n  # +requirements+ is given.\n\n  def self.required_location(gemname, libfile, *requirements)\n    requirements = Gem::Requirement.default if requirements.empty?\n\n    matches = Gem.source_index.find_name gemname, requirements\n\n    return nil if matches.empty?\n\n    spec = matches.last\n    spec.require_paths.each do |path|\n      result = File.join spec.full_gem_path, path, libfile\n      return result if File.exist? result\n    end\n\n    nil\n  end\n\n  ##\n  # The path to the running Ruby interpreter.\n\n  def self.ruby\n    if @ruby.nil? then\n      @ruby = File.join(ConfigMap[:bindir],\n                        ConfigMap[:ruby_install_name])\n      @ruby << ConfigMap[:EXEEXT]\n\n      # escape string in case path to ruby executable contain spaces.\n      @ruby.sub!(/.*\\s.*/m, '\"\\&\"')\n    end\n\n    @ruby\n  end\n\n  ##\n  # A Gem::Version for the currently running ruby.\n\n  def self.ruby_version\n    return @ruby_version if defined? @ruby_version\n    version = RUBY_VERSION.dup\n\n    if defined?(RUBY_PATCHLEVEL) && RUBY_PATCHLEVEL != -1 then\n      version << \".#{RUBY_PATCHLEVEL}\"\n    elsif defined?(RUBY_REVISION) then\n      version << \".dev.#{RUBY_REVISION}\"\n    end\n\n    @ruby_version = Gem::Version.new version\n  end\n\n  ##\n  # The GemPathSearcher object used to search for matching installed gems.\n\n  def self.searcher\n    MUTEX.synchronize do\n      @searcher ||= Gem::GemPathSearcher.new\n    end\n  end\n\n  ##\n  # Set the Gem home directory (as reported by Gem.dir).\n\n  def self.set_home(home)\n    home = home.gsub(File::ALT_SEPARATOR, File::SEPARATOR) if File::ALT_SEPARATOR\n    @gem_home = home\n    ensure_gem_subdirectories(@gem_home)\n  end\n\n  private_class_method :set_home\n\n  ##\n  # Set the Gem search path (as reported by Gem.path).\n\n  def self.set_paths(gpaths)\n    if gpaths\n      @gem_path = gpaths.split(File::PATH_SEPARATOR)\n\n      if File::ALT_SEPARATOR then\n        @gem_path.map! do |path|\n          path.gsub File::ALT_SEPARATOR, File::SEPARATOR\n        end\n      end\n\n      @gem_path << Gem.dir\n    else\n      # TODO: should this be Gem.default_path instead?\n      @gem_path = [Gem.dir]\n    end\n\n    @gem_path.uniq!\n    @gem_path.each do |path|\n      if 0 == File.expand_path(path).index(Gem.user_home)\n        next unless File.directory? Gem.user_home\n        unless win_platform? then\n          # only create by matc"..., 4096) = 4096
read(3, "d\n            next\n          end\n        end\n      end\n      ensure_gem_subdirectories path\n    end\n  end\n\n  private_class_method :set_paths\n\n  ##\n  # Returns the Gem::SourceIndex of specifications that are in the Gem.path\n\n  def self.source_index\n    @@source_index ||= SourceIndex.from_installed_gems\n  end\n\n  ##\n  # Returns an Array of sources to fetch remote gems from.  If the sources\n  # list is empty, attempts to load the \"sources\" gem, then uses\n  # default_sources if it is not installed.\n\n  def self.sources\n    if @sources.empty? then\n      begin\n        gem 'sources', '> 0.0.1'\n        require 'sources'\n      rescue LoadError\n        @sources = default_sources\n      end\n    end\n\n    @sources\n  end\n\n  ##\n  # Need to be able to set the sources without calling\n  # Gem.sources.replace since that would cause an infinite loop.\n\n  def self.sources=(new_sources)\n    @sources = new_sources\n  end\n\n  ##\n  # Glob pattern for require-able path suffixes.\n\n  def self.suffix_pattern\n    @suffix_pattern ||= \"{#{suffixes.join(',')}}\"\n  end\n\n  ##\n  # Suffixes for require-able paths.\n\n  def self.suffixes\n    ['', '.rb', '.rbw', '.so', '.bundle', '.dll', '.sl', '.jar']\n  end\n\n  ##\n  # Prints the amount of time the supplied block takes to run using the debug\n  # UI output.\n\n  def self.time(msg, width = 0, display = Gem.configuration.verbose)\n    now = Time.now\n\n    value = yield\n\n    elapsed = Time.now - now\n\n    ui.say \"%2$*1$s: %3$3.3fs\" % [-width, msg, elapsed] if display\n\n    value\n  end\n\n  ##\n  # Lazily loads DefaultUserInteraction and returns the default UI.\n\n  def self.ui\n    require 'rubygems/user_interaction'\n\n    Gem::DefaultUserInteraction.ui\n  end\n\n  ##\n  # Use the +home+ and +paths+ values for Gem.dir and Gem.path.  Used mainly\n  # by the unit tests to provide environment isolation.\n\n  def self.use_paths(home, paths=[])\n    clear_paths\n    set_home(home) if home\n    set_paths(paths.join(File::PATH_SEPARATOR)) if paths\n  end\n\n  ##\n  # The home directory for the user.\n\n  def self.user_home\n    @user_home ||= find_home\n  end\n\n  ##\n  # Is this a windows platform?\n\n  def self.win_platform?\n    if @@win_platform.nil? then\n      @@win_platform = !!WIN_PATTERNS.find { |r| RUBY_PLATFORM =~ r }\n    end\n\n    @@win_platform\n  end\n\n  class << self\n\n    ##\n    # Hash of loaded Gem::Specification keyed by name\n\n    attr_reader :loaded_specs\n\n    ##\n    # The list of hooks to be run before Gem::Install#install does any work\n\n    attr_reader :post_install_hooks\n\n    ##\n    # The list of hooks to be run before Gem::Uninstall#uninstall does any\n    # work\n\n    attr_reader :post_uninstall_hooks\n\n    ##\n    # The list of hooks to be run after Gem::Install#install is finished\n\n    attr_reader :pre_install_hooks\n\n    ##\n    # The list of hooks to be run after Gem::Uninstall#uninstall is finished\n\n    attr_reader :pre_uninstall_hooks\n\n    # :stopdoc:\n\n    alias cache source_index # an alias for the old name\n\n    # :startdoc:\n\n  end\n\n  ##\n  # Location of Marshal quick gemspecs on remote repositories\n\n  MARSHAL_SPEC_DIR = \"quick/Marshal.#{Gem.marshal_version}/\"\n\n  ##\n  # Location of legacy YAML quick gemspecs on remote repositories\n\n  YAML_SPEC_DIR = 'quick/'\n\nend\n\nmodule Config\n  # :stopdoc:\n  class << self\n    # Return the path to the data directory associated with the named\n    # package.  If the package is loaded as a gem, return the gem\n    # specific data directory.  Otherwise return a path to the share\n    # area as define by \"#{ConfigMap[:datadir]}/#{package_name}\".\n    def datadir(package_name)\n      Gem.datadir(package_name) ||\n        File.join(Gem::ConfigMap[:datadir], package_name)\n    end\n  end\n  # :startdoc:\nend\n\nrequire 'rubygems/exceptions'\nrequire 'rubygems/version'\nrequire 'rubygems/requirement'\nrequire 'rubygems/dependency'\nrequire 'rubygems/gem_path_searcher'    # Needed for Kernel#gem\nrequire 'rubygems/source_index'         # Needed for Kernel#gem\nrequire 'rubygems/platform'\nrequire 'rubygems/builder'              # HACK: Needed for"..., 4096) = 4096
read(3, "\n\nif defined?(RUBY_ENGINE) then\n  begin\n    require \"rubygems/defaults/#{RUBY_ENGINE}\"\n  rescue LoadError\n  end\nend\n\nrequire 'rubygems/config_file'\n\nif RUBY_VERSION < '1.9' then\n  require 'rubygems/custom_require'\nend\n\nGem.clear_paths\n\nplugins = Gem.find_files 'rubygems_plugin'\n\nplugins.each do |plugin|\n  begin\n    load plugin\n  rescue => e\n    warn \"error loading #{plugin.inspect}: #{e.message} (#{e.class})\"\n  end\nend\n\n", 4096) = 424
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/defaults.rb", {st_mode=S_IFREG|0644, st_size=2307, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/defaults.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2307, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/defaults.rb", {st_mode=S_IFREG|0644, st_size=2307, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/defaults.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2307, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/defaults.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2307, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/defaults.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/defaults.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2307, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "module Gem\n\n  @post_install_hooks   ||= []\n  @post_uninstall_hooks ||= []\n  @pre_uninstall_hooks  ||= []\n  @pre_install_hooks    ||= []\n\n  ##\n  # An Array of the default sources that come with RubyGems\n\n  def self.default_sources\n    %w[http://gems.rubyforge.org/]\n  end\n\n  ##\n  # Default home directory path to be used if an alternate value is not\n  # specified in the environment\n\n  def self.default_dir\n    if defined? RUBY_FRAMEWORK_VERSION then\n      File.join File.dirname(ConfigMap[:sitedir]), 'Gems',\n                ConfigMap[:ruby_version]\n    # 1.9.2dev reverted to 1.8 style path\n    elsif RUBY_VERSION > '1.9' and RUBY_VERSION < '1.9.2' then\n      File.join(ConfigMap[:libdir], ConfigMap[:ruby_install_name], 'gems',\n                ConfigMap[:ruby_version])\n    else\n      File.join(ConfigMap[:libdir], ruby_engine, 'gems',\n                ConfigMap[:ruby_version])\n    end\n  end\n\n  ##\n  # Path for gems in the user's home directory\n\n  def self.user_dir\n    File.join(Gem.user_home, '.gem', ruby_engine,\n              ConfigMap[:ruby_version])\n  end\n\n  ##\n  # Default gem load path\n\n  def self.default_path\n    if File.exist?(Gem.user_home)\n      [user_dir, default_dir]\n    else\n      [default_dir]\n    end\n  end\n\n  ##\n  # Deduce Ruby's --program-prefix and --program-suffix from its install name\n\n  def self.default_exec_format\n    exec_format = ConfigMap[:ruby_install_name].sub('ruby', '%s') rescue '%s'\n\n    unless exec_format =~ /%s/ then\n      raise Gem::Exception,\n        \"[BUG] invalid exec_format #{exec_format.inspect}, no %s\"\n    end\n\n    exec_format\n  end\n\n  ##\n  # The default directory for binaries\n\n  def self.default_bindir\n    if defined? RUBY_FRAMEWORK_VERSION then # mac framework support\n      '/usr/bin'\n    else # generic install\n      ConfigMap[:bindir]\n    end\n  end\n\n  ##\n  # The default system-wide source info cache directory\n\n  def self.default_system_source_cache_dir\n    File.join Gem.dir, 'source_cache'\n  end\n\n  ##\n  # The default user-specific source info cache directory\n\n  def self.default_user_source_cache_dir\n    File.join Gem.user_home, '.gem', 'source_cache'\n  end\n\n  ##\n  # A wrapper around RUBY_ENGINE const that may not be defined\n\n  def self.ruby_engine\n    if defined? RUBY_ENGINE then\n      RUBY_ENGINE\n    else\n      'ruby'\n    end\n  end\n\nend\n\n", 4096) = 2307
brk(0x9e3c000)                          = 0x9e3c000
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/thread.rb", 0xbfe53e60) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/thread.so", 0xbfe53e60) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/thread.rb", 0xbfe53e60) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/thread.so", 0xbfe53e60) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/thread.rb", 0xbfe53e60) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/thread.so", 0xbfe53e60) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/thread.rb", 0xbfe53e60) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/thread.so", 0xbfe53e60) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/thread.rb", 0xbfe53e60) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/thread.so", 0xbfe53e60) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/thread.rb", 0xbfe53e60) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/thread.so", 0xbfe53e60) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/thread.rb", 0xbfe53e60) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/thread.so", 0xbfe53e60) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/thread.rb", {st_mode=S_IFREG|0644, st_size=104, ...}) = 0
open("/usr/lib/ruby/1.8/thread.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=104, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/thread.rb", 0xbfe53e70) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/thread.rb", 0xbfe53e70) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/thread.rb", 0xbfe53e70) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/thread.rb", 0xbfe53e70) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/thread.rb", 0xbfe53e70) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/thread.rb", 0xbfe53e70) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/thread.rb", 0xbfe53e70) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/thread.rb", {st_mode=S_IFREG|0644, st_size=104, ...}) = 0
open("/usr/lib/ruby/1.8/thread.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=104, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/thread.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=104, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/thread.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/thread.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=104, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "unless defined? Thread\n  fail \"Thread not available for this ruby interpreter\"\nend\n\nrequire 'thread.so'\n", 4096) = 104
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/thread.so", 0xbfe53300) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/thread.so", 0xbfe53300) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/thread.so", 0xbfe53300) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/thread.so", 0xbfe53300) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/thread.so", 0xbfe53300) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/thread.so", 0xbfe53300) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/thread.so", 0xbfe53300) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/thread.so", 0xbfe53300) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i486-linux/thread.so", {st_mode=S_IFREG|0644, st_size=13692, ...}) = 0
open("/usr/lib/ruby/1.8/i486-linux/thread.so", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=13692, ...}) = 0
close(3)                                = 0
futex(0x82306c, FUTEX_WAKE_PRIVATE, 2147483647) = 0
open("/usr/lib/ruby/1.8/i486-linux/thread.so", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\300\r\0\0004\0\0\0l1\0\0\0\0\0\0004\0 \0\6\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310,\0\0\310,\0\0\5\0\0\0\0\20\0\0\1\0\0\0\254.\0\0\254>\0\0\254>\0\0\340\1\0\0\370\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\300.\0\0\300>\0\0\300>\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0\364\0\0\0\364\0\0\0\364\0\0\0$\0\0\0$\0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\254.\0\0\254>\0\0\254>\0\0T\1\0\0T\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0/N~\2623e\354\375{29a\243\236<\231\257\2166\377%\0\0\0005\0\0\0\0\0\0\0&\0\0\0\2\0\0\0-\0\0\0\36\0\0\0\0\0\0\0(\0\0\0\0\0\0\0+\0\0\0.\0\0\0\31\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\24\0\0\0\t\0\0\0\7\0\0\0\30\0\0\0,\0\0\0003\0\0\0\r\0\0\0\37\0\0\0\0\0\0\0002\0\0\0\0\0\0\0004\0\0\0\n\0\0\0'\0\0\0 \0\0\0\0\0\0\0*\0\0\0/\0\0\0\34\0\0\0\0\0\0\0!\0\0\0%\0\0\0\33\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
fstat64(3, {st_mode=S_IFREG|0644, st_size=13692, ...}) = 0
mmap2(NULL, 16548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x110000
mmap2(0x113000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2) = 0x113000
close(3)                                = 0
mprotect(0x113000, 4096, PROT_READ)     = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/etc.rb", 0xbfe53e40) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/etc.so", 0xbfe53e40) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/etc.rb", 0xbfe53e40) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/etc.so", 0xbfe53e40) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/etc.rb", 0xbfe53e40) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/etc.so", 0xbfe53e40) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/etc.rb", 0xbfe53e40) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/etc.so", 0xbfe53e40) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/etc.rb", 0xbfe53e40) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/etc.so", 0xbfe53e40) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/etc.rb", 0xbfe53e40) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/etc.so", 0xbfe53e40) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/etc.rb", 0xbfe53e40) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/etc.so", 0xbfe53e40) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/etc.rb", 0xbfe53e40) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/etc.so", 0xbfe53e40) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i486-linux/etc.rb", 0xbfe53e40) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i486-linux/etc.so", {st_mode=S_IFREG|0644, st_size=9592, ...}) = 0
open("/usr/lib/ruby/1.8/i486-linux/etc.so", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=9592, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/etc.so", 0xbfe53e50) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/etc.so", 0xbfe53e50) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/etc.so", 0xbfe53e50) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/etc.so", 0xbfe53e50) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/etc.so", 0xbfe53e50) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/etc.so", 0xbfe53e50) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/etc.so", 0xbfe53e50) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/etc.so", 0xbfe53e50) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i486-linux/etc.so", {st_mode=S_IFREG|0644, st_size=9592, ...}) = 0
open("/usr/lib/ruby/1.8/i486-linux/etc.so", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=9592, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/i486-linux/etc.so", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\0\f\0\0004\0\0\0h!\0\0\0\0\0\0004\0 \0\6\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\30\0\0\240\30\0\0\5\0\0\0\0\20\0\0\1\0\0\0\324\36\0\0\324.\0\0\324.\0\0\270\1\0\0\324\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\350\36\0\0\350.\0\0\350.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0\364\0\0\0\364\0\0\0\364\0\0\0$\0\0\0$\0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\324\36\0\0\324.\0\0\324.\0\0,\1\0\0,\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\366\2126js\205D?\374\237\210\203\314P\317D\340q/\17%\0\0\0,\0\0\0\24\0\0\0\5\0\0\0\37\0\0\0%\0\0\0 \0\0\0\30\0\0\0\16\0\0\0\0\0\0\0$\0\0\0\0\0\0\0\33\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\17\0\0\0\27\0\0\0'\0\0\0*\0\0\0\0\0\0\0\31\0\0\0\35\0\0\0\26\0\0\0\32\0\0\0+\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\"\0\0\0&\0\0\0\0\0\0\0#\0\0\0\0\0\0\0)\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\3\0\0\0\0\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\0\0\0\0\0\0\0\0(\0\0\0\7\0\0\0\0\0\0\0", 512) = 512
fstat64(3, {st_mode=S_IFREG|0644, st_size=9592, ...}) = 0
mmap2(NULL, 12456, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xa2c000
mmap2(0xa2e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1) = 0xa2e000
close(3)                                = 0
mprotect(0xa2e000, 4096, PROT_READ)     = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rbconfig.rb", 0xbfe53820) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rbconfig.so", 0xbfe53820) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/rbconfig.rb", 0xbfe53820) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/rbconfig.so", 0xbfe53820) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/rbconfig.rb", 0xbfe53820) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/rbconfig.so", 0xbfe53820) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/rbconfig.rb", 0xbfe53820) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/rbconfig.so", 0xbfe53820) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/rbconfig.rb", 0xbfe53820) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/rbconfig.so", 0xbfe53820) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/rbconfig.rb", 0xbfe53820) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/rbconfig.so", 0xbfe53820) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/rbconfig.rb", 0xbfe53820) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/rbconfig.so", 0xbfe53820) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/rbconfig.rb", 0xbfe53820) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/rbconfig.so", 0xbfe53820) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i486-linux/rbconfig.rb", {st_mode=S_IFREG|0644, st_size=7398, ...}) = 0
open("/usr/lib/ruby/1.8/i486-linux/rbconfig.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=7398, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/rbconfig.rb", 0xbfe53830) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/rbconfig.rb", 0xbfe53830) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/rbconfig.rb", 0xbfe53830) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/rbconfig.rb", 0xbfe53830) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/rbconfig.rb", 0xbfe53830) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/rbconfig.rb", 0xbfe53830) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/rbconfig.rb", 0xbfe53830) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/rbconfig.rb", 0xbfe53830) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i486-linux/rbconfig.rb", {st_mode=S_IFREG|0644, st_size=7398, ...}) = 0
open("/usr/lib/ruby/1.8/i486-linux/rbconfig.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=7398, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/i486-linux/rbconfig.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=7398, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/i486-linux/rbconfig.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/i486-linux/rbconfig.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=7398, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "\n# This file was created by mkconfig.rb when ruby was built.  Any\n# changes made to this file will be lost the next time ruby is built.\n\nmodule Config\n  RUBY_VERSION == \"1.8.7\" or\n    raise \"ruby lib version (1.8.7) doesn't match executable version (#{RUBY_VERSION})\"\n\n  TOPDIR = File.dirname(__FILE__).chomp!(\"/lib/ruby/1.8/i486-linux\")\n  DESTDIR = '' unless defined? DESTDIR\n  CONFIG = {}\n  CONFIG[\"DESTDIR\"] = DESTDIR\n  CONFIG[\"INSTALL\"] = '/usr/bin/install -c'\n  CONFIG[\"EXEEXT\"] = \"\"\n  CONFIG[\"prefix\"] = (TOPDIR || DESTDIR + \"/usr\")\n  CONFIG[\"ruby_install_name\"] = \"ruby1.8\"\n  CONFIG[\"RUBY_INSTALL_NAME\"] = \"ruby1.8\"\n  CONFIG[\"RUBY_SO_NAME\"] = \"ruby1.8\"\n  CONFIG[\"MANTYPE\"] = \"doc\"\n  CONFIG[\"NROFF\"] = \"/usr/bin/nroff\"\n  CONFIG[\"configure_args\"] = \" '--build=i486-linux-gnu' '--prefix=/usr' '--includedir=$(prefix)/include' '--mandir=$(prefix)/share/man' '--infodir=$(prefix)/share/info' '--sysconfdir=/etc' '--localstatedir=/var' '--libexecdir=$(prefix)/lib/ruby1.8' '--disable-maintainer-mode' '--disable-dependency-tracking' '--srcdir=.' '--enable-frame-address' '--with-extra-site-search-path=/usr/local/lib/site_ruby/1.8/i386-linux' '--with-extra-search-path=/usr/lib/ruby/1.8/i386-linux' '--program-suffix=1.8' '--enable-pthread' '--enable-shared' '--enable-ipv6' '--with-lookup-order-hack=INET' '--disable-rpath' '--disable-install-doc' '--with-sitedir=/usr/local/lib/site_ruby' '--with-default-kcode=none' '--with-dbm-type=gdbm_compat' '--with-tklib=tk8.4' '--with-tcllib=tcl8.4' '--with-tcl-include=/usr/include/tcl8.4' '--with-bundled-sha1' '--with-bundled-md5' '--with-bundled-rmd160' 'build_alias=i486-linux-gnu' 'CFLAGS=-fno-strict-aliasing -g -g -O2' 'LDFLAGS=-Wl,-Bsymbolic-functions' 'CPPFLAGS='\"\n  CONFIG[\"vendordir\"] = \"$(libdir)/ruby/vendor_ruby\"\n  CONFIG[\"sitedir\"] = \"$(DESTDIR)/usr/local/lib/site_ruby\"\n  CONFIG[\"sitearch\"] = \"i486-linux\"\n  CONFIG[\"arch\"] = \"i486-linux\"\n  CONFIG[\"MAKEFILES\"] = \"Makefile\"\n  CONFIG[\"EXPORT_PREFIX\"] = \"\"\n  CONFIG[\"COMMON_HEADERS\"] = \"\"\n  CONFIG[\"COMMON_MACROS\"] = \"\"\n  CONFIG[\"COMMON_LIBS\"] = \"\"\n  CONFIG[\"MAINLIBS\"] = \"\"\n  CONFIG[\"ENABLE_SHARED\"] = \"yes\"\n  CONFIG[\"DLDLIBS\"] = \" -lc\"\n  CONFIG[\"SOLIBS\"] = \"$(LIBS)\"\n  CONFIG[\"LIBRUBYARG_SHARED\"] = \"-l$(RUBY_SO_NAME)\"\n  CONFIG[\"LIBRUBYARG_STATIC\"] = \"-l$(RUBY_SO_NAME)-static\"\n  CONFIG[\"LIBRUBYARG\"] = \"$(LIBRUBYARG_SHARED)\"\n  CONFIG[\"LIBRUBY\"] = \"$(LIBRUBY_SO)\"\n  CONFIG[\"LIBRUBY_ALIASES\"] = \"lib$(RUBY_SO_NAME).so.$(MAJOR).$(MINOR) lib$(RUBY_SO_NAME).so\"\n  CONFIG[\"LIBRUBY_SO\"] = \"lib$(RUBY_SO_NAME).so.$(MAJOR).$(MINOR).$(TEENY)\"\n  CONFIG[\"LIBRUBY_A\"] = \"lib$(RUBY_SO_NAME)-static.a\"\n  CONFIG[\"RUBYW_INSTALL_NAME\"] = \"\"\n  CONFIG[\"rubyw_install_name\"] = \"\"\n  CONFIG[\"LIBRUBY_DLDFLAGS\"] = \"-Wl,-soname,lib$(RUBY_SO_NAME).so.$(MAJOR).$(MINOR)\"\n  CONFIG[\"LIBRUBY_LDSHARED\"] = \"$(CC) -shared\"\n  CONFIG[\"debugflags\"] = \"\"\n  CONFIG[\"optflags\"] = \"\"\n  CONFIG[\"cflags\"] = \"$(optflags) $(debugflags)\"\n  CONFIG[\"cppflags\"] = \"\"\n  CONFIG[\"RDOCTARGET\"] = \"\"\n  CONFIG[\"ARCHFILE\"] = \"\"\n  CONFIG[\"EXTOUT\"] = \".ext\"\n  CONFIG[\"PREP\"] = \"miniruby$(EXEEXT)\"\n  CONFIG[\"setup\"] = \"Setup\"\n  CONFIG[\"EXTSTATIC\"] = \"\"\n  CONFIG[\"STRIP\"] = \"strip -S -x\"\n  CONFIG[\"TRY_LINK\"] = \"\"\n  CONFIG[\"LIBPATHENV\"] = \"LD_LIBRARY_PATH\"\n  CONFIG[\"RPATHFLAG\"] = \"\"\n  CONFIG[\"LIBPATHFLAG\"] = \" -L%s\"\n  CONFIG[\"LINK_SO\"] = \"\"\n  CONFIG[\"LIBEXT\"] = \"a\"\n  CONFIG[\"DLEXT2\"] = \"\"\n  CONFIG[\"DLEXT\"] = \"so\"\n  CONFIG[\"LDSHARED\"] = \"$(CC) -shared\"\n  CONFIG[\"CCDLFLAGS\"] = \" -fPIC\"\n  CONFIG[\"STATIC\"] = \"\"\n  CONFIG[\"ARCH_FLAG\"] = \"\"\n  CONFIG[\"DLDFLAGS\"] = \"\"\n  CONFIG[\"ALLOCA\"] = \"\"\n  CONFIG[\"MAKEDIRS\"] = \"mkdir -p\"\n  CONFIG[\"CP\"] = \"cp\"\n  CONFIG[\"RM\"] = \"rm -f\"\n  CONFIG[\"INSTALL_DATA\"] = \"$(INSTALL) -m 644\"\n  CONFIG[\"INSTALL_SCRIPT\"] = \"$(INSTALL)\"\n  CONFIG[\"INSTALL_PROGRAM\"] = \"$(INSTALL)\"\n  CONFIG[\"SET_MAKE\"] = \"\"\n  CONFIG[\"LN_S\"] = \"ln -s\"\n  CONFIG[\"OBJDUMP\"] = \"\"\n  CONFIG[\"DLLWRAP\"] = \"\"\n  CONFIG[\"WINDRES\"] = \"\"\n  CONFIG[\"NM\"] = \"\"\n  CONFIG[\"ASFLAGS\"] = \"\"\n  CONFIG[\"AS\"] = \"as\"\n  CONFIG[\"AR\"] = \"ar\"\n  CONFIG[\"RANLIB\"] = \"ranli"..., 4096) = 4096
read(3, "PPOUTFILE\"] = \"-o conftest.i\"\n  CONFIG[\"GNU_LD\"] = \"yes\"\n  CONFIG[\"EGREP\"] = \"/bin/grep -E\"\n  CONFIG[\"GREP\"] = \"/bin/grep\"\n  CONFIG[\"CPP\"] = \"gcc -E\"\n  CONFIG[\"OBJEXT\"] = \"o\"\n  CONFIG[\"CPPFLAGS\"] = \" $(DEFS) $(cppflags)\"\n  CONFIG[\"LDFLAGS\"] = \"-L. -Wl,-Bsymbolic-functions -rdynamic -Wl,-export-dynamic\"\n  CONFIG[\"CFLAGS\"] = \"-fno-strict-aliasing -g -g -O2  -fPIC $(cflags)\"\n  CONFIG[\"CC\"] = \"gcc\"\n  CONFIG[\"target_os\"] = \"linux\"\n  CONFIG[\"target_vendor\"] = \"pc\"\n  CONFIG[\"target_cpu\"] = \"i486\"\n  CONFIG[\"target\"] = \"i486-pc-linux-gnu\"\n  CONFIG[\"host_os\"] = \"linux-gnu\"\n  CONFIG[\"host_vendor\"] = \"pc\"\n  CONFIG[\"host_cpu\"] = \"i486\"\n  CONFIG[\"host\"] = \"i486-pc-linux-gnu\"\n  CONFIG[\"build_os\"] = \"linux-gnu\"\n  CONFIG[\"build_vendor\"] = \"pc\"\n  CONFIG[\"build_cpu\"] = \"i486\"\n  CONFIG[\"build\"] = \"i486-pc-linux-gnu\"\n  CONFIG[\"TEENY\"] = \"7\"\n  CONFIG[\"MINOR\"] = \"8\"\n  CONFIG[\"MAJOR\"] = \"1\"\n  CONFIG[\"target_alias\"] = \"\"\n  CONFIG[\"host_alias\"] = \"\"\n  CONFIG[\"build_alias\"] = \"i486-linux-gnu\"\n  CONFIG[\"LIBS\"] = \"-lpthread -lrt -ldl -lcrypt -lm \"\n  CONFIG[\"ECHO_T\"] = \"\"\n  CONFIG[\"ECHO_N\"] = \"-n\"\n  CONFIG[\"ECHO_C\"] = \"\"\n  CONFIG[\"DEFS\"] = \"-D_FILE_OFFSET_BITS=64\"\n  CONFIG[\"mandir\"] = \"$(prefix)/share/man\"\n  CONFIG[\"localedir\"] = \"$(datarootdir)/locale\"\n  CONFIG[\"libdir\"] = \"$(exec_prefix)/lib\"\n  CONFIG[\"psdir\"] = \"$(docdir)\"\n  CONFIG[\"pdfdir\"] = \"$(docdir)\"\n  CONFIG[\"dvidir\"] = \"$(docdir)\"\n  CONFIG[\"htmldir\"] = \"$(docdir)\"\n  CONFIG[\"infodir\"] = \"$(prefix)/share/info\"\n  CONFIG[\"docdir\"] = \"$(datarootdir)/doc/$(PACKAGE)\"\n  CONFIG[\"oldincludedir\"] = \"/usr/include\"\n  CONFIG[\"includedir\"] = \"$(prefix)/include\"\n  CONFIG[\"localstatedir\"] = \"$(DESTDIR)/var\"\n  CONFIG[\"sharedstatedir\"] = \"$(prefix)/com\"\n  CONFIG[\"sysconfdir\"] = \"$(DESTDIR)/etc\"\n  CONFIG[\"datadir\"] = \"$(datarootdir)\"\n  CONFIG[\"datarootdir\"] = \"$(prefix)/share\"\n  CONFIG[\"libexecdir\"] = \"$(prefix)/lib/ruby1.8\"\n  CONFIG[\"sbindir\"] = \"$(exec_prefix)/sbin\"\n  CONFIG[\"bindir\"] = \"$(exec_prefix)/bin\"\n  CONFIG[\"exec_prefix\"] = \"$(prefix)\"\n  CONFIG[\"PACKAGE_URL\"] = \"\"\n  CONFIG[\"PACKAGE_BUGREPORT\"] = \"\"\n  CONFIG[\"PACKAGE_STRING\"] = \"\"\n  CONFIG[\"PACKAGE_VERSION\"] = \"\"\n  CONFIG[\"PACKAGE_TARNAME\"] = \"\"\n  CONFIG[\"PACKAGE_NAME\"] = \"\"\n  CONFIG[\"PATH_SEPARATOR\"] = \":\"\n  CONFIG[\"SHELL\"] = \"/bin/bash\"\n  CONFIG[\"ruby_version\"] = \"$(MAJOR).$(MINOR)\"\n  CONFIG[\"rubylibdir\"] = \"$(libdir)/ruby/$(ruby_version)\"\n  CONFIG[\"archdir\"] = \"$(rubylibdir)/$(arch)\"\n  CONFIG[\"sitelibdir\"] = \"$(sitedir)/$(ruby_version)\"\n  CONFIG[\"sitearchdir\"] = \"$(sitelibdir)/$(sitearch)\"\n  CONFIG[\"vendorlibdir\"] = \"$(vendordir)/$(ruby_version)\"\n  CONFIG[\"vendorarchdir\"] = \"$(vendorlibdir)/$(sitearch)\"\n  CONFIG[\"topdir\"] = File.dirname(__FILE__)\n  MAKEFILE_CONFIG = {}\n  CONFIG.each{|k,v| MAKEFILE_CONFIG[k] = v.dup}\n  def Config::expand(val, config = CONFIG)\n    val.gsub!(/\\$\\$|\\$\\(([^()]+)\\)|\\$\\{([^{}]+)\\}/) do |var|\n      if !(v = $1 || $2)\n\t'$'\n      elsif key = config[v = v[/\\A[^:]+(?=(?::(.*?)=(.*))?\\z)/]]\n\tpat, sub = $1, $2\n\tconfig[v] = false\n\tConfig::expand(key, config)\n\tconfig[v] = key\n\tkey = key.gsub(/#{Regexp.quote(pat)}(?=\\s|\\z)/n) {sub} if pat\n\tkey\n      else\n\tvar\n      end\n    end\n    val\n  end\n  CONFIG.each_value do |val|\n    Config::expand(val)\n  end\nend\nRbConfig = Config # compatibility for ruby-1.9\nCROSS_COMPILING = nil unless defined? CROSS_COMPILING\n", 4096) = 3302
mmap2(NULL, 360448, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb77c7000
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/exceptions.rb", {st_mode=S_IFREG|0644, st_size=2216, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/exceptions.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2216, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/exceptions.rb", {st_mode=S_IFREG|0644, st_size=2216, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/exceptions.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2216, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/exceptions.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2216, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/exceptions.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/exceptions.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2216, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "##\n# Base exception class for RubyGems.  All exception raised by RubyGems are a\n# subclass of this one.\nclass Gem::Exception < RuntimeError; end\n\nclass Gem::CommandLineError < Gem::Exception; end\n\nclass Gem::DependencyError < Gem::Exception; end\n\nclass Gem::DependencyRemovalException < Gem::Exception; end\n\n##\n# Raised when attempting to uninstall a gem that isn't in GEM_HOME.\n\nclass Gem::GemNotInHomeException < Gem::Exception\n  attr_accessor :spec\nend\n\nclass Gem::DocumentError < Gem::Exception; end\n\n##\n# Potentially raised when a specification is validated.\nclass Gem::EndOfYAMLException < Gem::Exception; end\n\n##\n# Signals that a file permission error is preventing the user from\n# installing in the requested directories.\nclass Gem::FilePermissionError < Gem::Exception\n  def initialize(path)\n    super(\"You don't have write permissions into the #{path} directory.\")\n  end\nend\n\n##\n# Used to raise parsing and loading errors\nclass Gem::FormatException < Gem::Exception\n  attr_accessor :file_path\nend\n\nclass Gem::GemNotFoundException < Gem::Exception; end\n\nclass Gem::InstallError < Gem::Exception; end\n\n##\n# Potentially raised when a specification is validated.\nclass Gem::InvalidSpecificationException < Gem::Exception; end\n\nclass Gem::OperationNotSupportedError < Gem::Exception; end\n\n##\n# Signals that a remote operation cannot be conducted, probably due to not\n# being connected (or just not finding host).\n#--\n# TODO: create a method that tests connection to the preferred gems server.\n# All code dealing with remote operations will want this.  Failure in that\n# method should raise this error.\nclass Gem::RemoteError < Gem::Exception; end\n\nclass Gem::RemoteInstallationCancelled < Gem::Exception; end\n\nclass Gem::RemoteInstallationSkipped < Gem::Exception; end\n\n##\n# Represents an error communicating via HTTP.\nclass Gem::RemoteSourceException < Gem::Exception; end\n\nclass Gem::VerificationError < Gem::Exception; end\n\n##\n# Raised to indicate that a system exit should occur with the specified\n# exit_code\n\nclass Gem::SystemExitException < SystemExit\n  attr_accessor :exit_code\n\n  def initialize(exit_code)\n    @exit_code = exit_code\n\n    super \"Exiting RubyGems with exit_code #{exit_code}\"\n  end\n\nend\n", 4096) = 2216
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/version.rb", {st_mode=S_IFREG|0644, st_size=5617, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/version.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5617, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/version.rb", {st_mode=S_IFREG|0644, st_size=5617, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/version.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5617, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/version.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5617, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/version.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/version.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5617, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\n##\n# The Version class processes string versions into comparable\n# values. A version string should normally be a series of numbers\n# separated by periods. Each part (digits separated by periods) is\n# considered its own number, and these are used for sorting. So for\n# instance, 3.10 sorts higher than 3.2 because ten is greater than\n# two.\n#\n# If any part contains letters (currently only a-z are supported) then\n# that version is considered prerelease. Versions with a prerelease\n# part in the Nth part sort less than versions with N-1 parts. Prerelease\n# parts are sorted alphabetically using the normal Ruby string sorting\n# rules.\n#\n# Prereleases sort between real releases (newest to oldest):\n#\n# 1. 1.0\n# 2. 1.0.b\n# 3. 1.0.a\n# 4. 0.9\n\nclass Gem::Version\n\n  class Part\n    include Comparable\n\n    attr_reader :value\n\n    def initialize(value)\n      @value = (value =~ /\\A\\d+\\z/) ? value.to_i : value\n    end\n\n    def to_s\n      self.value.to_s\n    end\n\n    def inspect\n      @value\n    end\n\n    def alpha?\n      String === value\n    end\n\n    def numeric?\n      Fixnum === value\n    end\n\n    def <=>(other)\n      if    self.numeric? && other.alpha? then\n        1\n      elsif self.alpha? && other.numeric? then\n        -1\n      else\n        self.value <=> other.value\n      end\n    end\n\n    def succ\n      self.class.new(self.value.succ)\n    end\n  end\n\n  include Comparable\n\n  VERSION_PATTERN = '[0-9]+(\\.[0-9a-z]+)*'\n\n  attr_reader :version\n\n  def self.correct?(version)\n    pattern = /\\A\\s*(#{VERSION_PATTERN})*\\s*\\z/\n\n    version.is_a? Integer or\n      version =~ pattern or\n      version.to_s =~ pattern\n  end\n\n  ##\n  # Factory method to create a Version object.  Input may be a Version or a\n  # String.  Intended to simplify client code.\n  #\n  #   ver1 = Version.create('1.3.17')   # -> (Version object)\n  #   ver2 = Version.create(ver1)       # -> (ver1)\n  #   ver3 = Version.create(nil)        # -> nil\n\n  def self.create(input)\n    if input.respond_to? :version then\n      input\n    elsif input.nil? then\n      nil\n    else\n      new input\n    end\n  end\n\n  ##\n  # Constructs a Version from the +version+ string.  A version string is a\n  # series of digits or ASCII letters separated by dots.\n\n  def initialize(version)\n    raise ArgumentError, \"Malformed version number string #{version}\" unless\n      self.class.correct?(version)\n\n    self.version = version\n  end\n\n  def inspect # :nodoc:\n    \"#<#{self.class} #{@version.inspect}>\"\n  end\n\n  ##\n  # Dump only the raw version string, not the complete object\n\n  def marshal_dump\n    [@version]\n  end\n\n  ##\n  # Load custom marshal format\n\n  def marshal_load(array)\n    self.version = array[0]\n  end\n\n  def parts\n    @parts ||= normalize\n  end\n\n  ##\n  # Strip ignored trailing zeros.\n\n  def normalize\n    parts_arr = parse_parts_from_version_string\n    if parts_arr.length != 1\n      parts_arr.pop while parts_arr.last && parts_arr.last.value == 0\n      parts_arr = [Part.new(0)] if parts_arr.empty?\n    end\n    parts_arr\n  end\n\n  ##\n  # Returns the text representation of the version\n\n  def to_s\n    @version\n  end\n\n  def to_yaml_properties\n    ['@version']\n  end\n\n  def version=(version)\n    @version = version.to_s.strip\n    normalize\n  end\n\n  ##\n  # A version is considered a prerelease if any part contains a letter.\n\n  def prerelease?\n    parts.any? { |part| part.alpha? }\n  end\n  \n  ##\n  # The release for this version (e.g. 1.2.0.a -> 1.2.0)\n  # Non-prerelease versions return themselves\n  def release\n    return self unless prerelease?\n    rel_parts = parts.dup\n    rel_parts.pop while rel_parts.any? { |part| part.alpha? }\n    self.class.new(rel_parts.join('.'))\n  end\n\n  def yaml_initialize(tag, values)\n    self.version = values['version']\n  end\n\n  ##\n  # Compares this version with +other+ returning -1, 0, or 1 if the other\n  # version is larger, the same, or smaller than this one.\n\n  def <"..., 4096) = 4096
read(3, "= balance(self.parts.dup, other.parts.dup)\n    mine <=> theirs\n  end\n\n  def balance(a, b)\n    a << Part.new(0) while a.size < b.size\n    b << Part.new(0) while b.size < a.size\n    [a, b]\n  end\n\n  ##\n  # A Version is only eql? to another version if it has the same version\n  # string.  \"1.0\" is not the same version as \"1\".\n\n  def eql?(other)\n    self.class === other and @version == other.version\n  end\n\n  def hash # :nodoc:\n    @version.hash\n  end\n\n  ##\n  # Return a new version object where the next to the last revision number is\n  # one greater. (e.g.  5.3.1 => 5.4)\n  #\n  # Pre-release (alpha) parts are ignored. (e.g 5.3.1.b2 => 5.4)\n\n  def bump\n    parts = parse_parts_from_version_string\n    parts.pop while parts.any? { |part| part.alpha? }\n    parts.pop if parts.size > 1\n    parts[-1] = parts[-1].succ\n    self.class.new(parts.join(\".\"))\n  end\n\n  def parse_parts_from_version_string # :nodoc:\n    @version.to_s.scan(/[0-9a-z]+/i).map { |s| Part.new(s) }\n  end\n\n  def pretty_print(q) # :nodoc:\n    q.text \"Gem::Version.new(#{@version.inspect})\"\n  end\n\n  #:stopdoc:\n\n  require 'rubygems/requirement'\n\n  ##\n  # Gem::Requirement's original definition is nested in Version.\n  # Although an inappropriate place, current gems specs reference the nested\n  # class name explicitly.  To remain compatible with old software loading\n  # gemspecs, we leave a copy of original definition in Version, but define an\n  # alias Gem::Requirement for use everywhere else.\n\n  Requirement = ::Gem::Requirement\n\n  # :startdoc:\n\nend\n\n", 4096) = 1521
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/requirement.rb", {st_mode=S_IFREG|0644, st_size=3970, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/requirement.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3970, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/requirement.rb", {st_mode=S_IFREG|0644, st_size=3970, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/requirement.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3970, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/requirement.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3970, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/requirement.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/requirement.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3970, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\n##\n# Requirement version includes a prefaced comparator in addition\n# to a version number.\n#\n# A Requirement object can actually contain multiple, er,\n# requirements, as in (> 1.2, < 2.0).\n\nclass Gem::Requirement\n\n  include Comparable\n\n  attr_reader :requirements\n\n  OPS = {\n    \"=\"  =>  lambda { |v, r| v == r },\n    \"!=\" =>  lambda { |v, r| v != r },\n    \">\"  =>  lambda { |v, r| v > r },\n    \"<\"  =>  lambda { |v, r| v < r },\n    \">=\" =>  lambda { |v, r| v >= r },\n    \"<=\" =>  lambda { |v, r| v <= r },\n    \"~>\" =>  lambda { |v, r| v = v.release; v >= r && v < r.bump }\n  }\n\n  OP_RE = OPS.keys.map{ |k| Regexp.quote k }.join '|'\n\n  ##\n  # Factory method to create a Gem::Requirement object.  Input may be a\n  # Version, a String, or nil.  Intended to simplify client code.\n  #\n  # If the input is \"weird\", the default version requirement is returned.\n\n  def self.create(input)\n    case input\n    when Gem::Requirement then\n      input\n    when Gem::Version, Array then\n      new input\n    else\n      if input.respond_to? :to_str then\n        self.new [input.to_str]\n      else\n        self.default\n      end\n    end\n  end\n\n  ##\n  # A default \"version requirement\" can surely _only_ be '>= 0'.\n  #--\n  # This comment once said:\n  #\n  # \"A default \"version requirement\" can surely _only_ be '> 0'.\"\n\n  def self.default\n    self.new ['>= 0']\n  end\n\n  ##\n  # Constructs a Requirement from +requirements+ which can be a String, a\n  # Gem::Version, or an Array of those.  See #parse for details on the\n  # formatting of requirement strings.\n\n  def initialize(requirements)\n    @requirements = case requirements\n                    when Array then\n                      requirements.map do |requirement|\n                        parse(requirement)\n                      end\n                    else\n                      [parse(requirements)]\n                    end\n    @version = nil   # Avoid warnings.\n  end\n\n  ##\n  # Marshal raw requirements, rather than the full object\n\n  def marshal_dump # :nodoc:\n    [@requirements]\n  end\n\n  ##\n  # Load custom marshal format\n\n  def marshal_load(array) # :nodoc:\n    @requirements = array[0]\n    @version = nil\n  end\n\n  def to_s # :nodoc:\n    as_list.join(\", \")\n  end\n\n  def pretty_print(q) # :nodoc:\n    q.group 1, 'Gem::Requirement.new(', ')' do\n      q.pp as_list\n    end\n  end\n\n  def as_list\n    normalize\n    @requirements.map do |op, version| \"#{op} #{version}\" end\n  end\n\n  def normalize\n    return if not defined? @version or @version.nil?\n    @requirements = [parse(@version)]\n    @nums = nil\n    @version = nil\n    @op = nil\n  end\n\n  ##\n  # True if this requirement satisfied by the Gem::Version +version+.\n\n  def satisfied_by?(version)\n    normalize\n    @requirements.all? { |op, rv| satisfy?(op, version, rv) }\n  end\n\n  ##\n  # Is \"+version+ +op+ +required_version+\" satisfied?\n\n  def satisfy?(op, version, required_version)\n    OPS[op].call(version, required_version)\n  end\n\n  def prerelease?\n    # TODO: why is @requirements a nested array?\n    @requirements.any?{ |r| r[1].prerelease? }\n  end\n\n  ##\n  # Parse the version requirement obj returning the operator and version.\n  #\n  # The requirement can be a String or a Gem::Version.  A String can be an\n  # operator (<, <=, =, >=, >, !=, ~>), a version number, or both, operator\n  # first.\n\n  def parse(obj)\n    case obj\n    when /^\\s*(#{OP_RE})\\s*(#{Gem::Version::VERSION_PATTERN})\\s*$/o then\n      [$1, Gem::Version.new($2)]\n    when /^\\s*(#{Gem::Version::VERSION_PATTERN})\\s*$/o then\n      ['=', Gem::Version.new($1)]\n    when /^\\s*(#{OP_RE})\\s*$/o then\n      [$1, Gem::Version.new('0')]\n    when Gem::Version then\n      ['=', obj]\n    else\n      fail ArgumentError, \"Illformed requirement [#{obj.inspect}]\"\n    end\n  end\n\n  def <=>(other) # :nodoc:\n    to_s <=> other.to_s\n  end\n\n  def hash # :nodoc:\n    to_s.hash\n  end\n\nend\n\n", 4096) = 3970
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/requirement.rb", {st_mode=S_IFREG|0644, st_size=3970, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/requirement.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3970, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/dependency.rb", {st_mode=S_IFREG|0644, st_size=3249, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/dependency.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3249, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/dependency.rb", {st_mode=S_IFREG|0644, st_size=3249, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/dependency.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3249, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/dependency.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3249, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/dependency.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/dependency.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3249, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\n##\n# The Dependency class holds a Gem name and a Gem::Requirement\n\nclass Gem::Dependency\n\n  ##\n  # Valid dependency types.\n  #--\n  # When this list is updated, be sure to change\n  # Gem::Specification::CURRENT_SPECIFICATION_VERSION as well.\n\n  TYPES = [\n    :development,\n    :runtime,\n  ]\n\n  ##\n  # Dependency name or regular expression.\n\n  attr_accessor :name\n\n  ##\n  # Dependency type.\n\n  attr_reader :type\n\n  ##\n  # Dependent versions.\n\n  attr_writer :version_requirements\n\n  ##\n  # Orders dependencies by name only.\n\n  def <=>(other)\n    [@name] <=> [other.name]\n  end\n\n  ##\n  # Constructs a dependency with +name+ and +requirements+.\n\n  def initialize(name, version_requirements, type=:runtime)\n    @name = name\n\n    unless TYPES.include? type\n      raise ArgumentError, \"Valid types are #{TYPES.inspect}, not #{@type.inspect}\"\n    end\n\n    @type = type\n\n    @version_requirements = Gem::Requirement.create version_requirements\n    @version_requirement = nil   # Avoid warnings.\n  end\n\n  def version_requirements\n    normalize if defined? @version_requirement and @version_requirement\n    @version_requirements\n  end\n\n  def requirement_list\n    version_requirements.as_list\n  end\n\n  alias requirements_list requirement_list\n\n  def normalize\n    ver = @version_requirement.instance_variable_get :@version\n    @version_requirements = Gem::Requirement.new([ver])\n    @version_requirement = nil\n  end\n\n  def to_s # :nodoc:\n    \"#{name} (#{version_requirements}, #{@type || :runtime})\"\n  end\n\n  def pretty_print(q) # :nodoc:\n    q.group 1, 'Gem::Dependency.new(', ')' do\n      q.pp @name\n      q.text ','\n      q.breakable\n\n      q.pp @version_requirements\n\n      q.text ','\n      q.breakable\n\n      q.pp @type\n    end\n  end\n\n  def ==(other) # :nodoc:\n    self.class === other &&\n      self.name == other.name &&\n      self.type == other.type &&\n      self.version_requirements == other.version_requirements\n  end\n\n  ##\n  # Uses this dependency as a pattern to compare to +other+.  This dependency\n  # will match if the name matches the other's name, and other has only an\n  # equal version requirement that satisfies this dependency.\n\n  def =~(other)\n    other = if self.class === other then\n              other\n            else\n              return false unless other.respond_to? :name and\n                                  other.respond_to? :version\n\n              Gem::Dependency.new other.name, other.version\n            end\n\n    pattern = @name\n    pattern = /\\A#{Regexp.escape @name}\\Z/ unless Regexp === pattern\n\n    return false unless pattern =~ other.name\n\n    reqs = other.version_requirements.requirements\n\n    return false unless reqs.length == 1\n    return false unless reqs.first.first == '='\n\n    version = reqs.first.last\n\n    version_requirements.satisfied_by? version\n  end\n\n  ##\n  # A dependency's hash is the sum of the hash of the #name, #type and\n  # #version_requirements\n\n  def hash\n    name.hash + type.hash + version_requirements.hash\n  end\n\n  def inspect # :nodoc:\n    \"<%s type=%p name=%p requirements=%p>\" % [self.class, @type, @name,\n      version_requirements.to_s]\n  end\n\nend\n\n", 4096) = 3249
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/gem_path_searcher.rb", {st_mode=S_IFREG|0644, st_size=2766, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/gem_path_searcher.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2766, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/gem_path_searcher.rb", {st_mode=S_IFREG|0644, st_size=2766, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/gem_path_searcher.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2766, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/gem_path_searcher.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2766, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/gem_path_searcher.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/gem_path_searcher.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2766, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\n##\n# GemPathSearcher has the capability to find loadable files inside\n# gems.  It generates data up front to speed up searches later.\n\nclass Gem::GemPathSearcher\n\n  ##\n  # Initialise the data we need to make searches later.\n\n  def initialize\n    # We want a record of all the installed gemspecs, in the order\n    # we wish to examine them.\n    @gemspecs = init_gemspecs\n    # Map gem spec to glob of full require_path directories.\n    # Preparing this information may speed up searches later.\n    @lib_dirs = {}\n    @gemspecs.each do |spec|\n      @lib_dirs[spec.object_id] = lib_dirs_for(spec)\n    end\n  end\n\n  ##\n  # Look in all the installed gems until a matching _path_ is found.\n  # Return the _gemspec_ of the gem where it was found.  If no match\n  # is found, return nil.\n  #\n  # The gems are searched in alphabetical order, and in reverse\n  # version order.\n  #\n  # For example:\n  #\n  #   find('log4r')              # -> (log4r-1.1 spec)\n  #   find('log4r.rb')           # -> (log4r-1.1 spec)\n  #   find('rake/rdoctask')      # -> (rake-0.4.12 spec)\n  #   find('foobarbaz')          # -> nil\n  #\n  # Matching paths can have various suffixes ('.rb', '.so', and\n  # others), which may or may not already be attached to _file_.\n  # This method doesn't care about the full filename that matches;\n  # only that there is a match.\n\n  def find(path)\n    @gemspecs.find do |spec| matching_file? spec, path end\n  end\n\n  ##\n  # Works like #find, but finds all gemspecs matching +path+.\n\n  def find_all(path)\n    @gemspecs.select do |spec|\n      matching_file? spec, path\n    end\n  end\n\n  ##\n  # Attempts to find a matching path using the require_paths of the given\n  # +spec+.\n\n  def matching_file?(spec, path)\n    !matching_files(spec, path).empty?\n  end\n\n  ##\n  # Returns files matching +path+ in +spec+.\n  #--\n  # Some of the intermediate results are cached in @lib_dirs for speed.\n\n  def matching_files(spec, path)\n    glob = File.join @lib_dirs[spec.object_id], \"#{path}#{Gem.suffix_pattern}\"\n    Dir[glob].select { |f| File.file? f.untaint }\n  end\n\n  ##\n  # Return a list of all installed gemspecs, sorted by alphabetical order and\n  # in reverse version order.  (bar-2, bar-1, foo-2)\n\n  def init_gemspecs\n    specs = Gem.source_index.map { |_, spec| spec }\n\n    specs.sort { |a, b|\n      names = a.name <=> b.name\n      next names if names.nonzero?\n      b.version <=> a.version\n    }\n  end\n\n  ##\n  # Returns library directories glob for a gemspec.  For example,\n  #   '/usr/local/lib/ruby/gems/1.8/gems/foobar-1.0/{lib,ext}'\n\n  def lib_dirs_for(spec)\n    \"#{spec.full_gem_path}/{#{spec.require_paths.join(',')}}\"\n  end\n\nend\n\n", 4096) = 2766
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/source_index.rb", {st_mode=S_IFREG|0644, st_size=15182, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/source_index.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=15182, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/source_index.rb", {st_mode=S_IFREG|0644, st_size=15182, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/source_index.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=15182, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/source_index.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=15182, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/source_index.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/source_index.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=15182, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\nrequire 'rubygems/user_interaction'\nrequire 'rubygems/specification'\n\n# :stopdoc:\nmodule Gem\n  autoload :SpecFetcher, 'rubygems/spec_fetcher'\nend\n# :startdoc:\n\n##\n# The SourceIndex object indexes all the gems available from a\n# particular source (e.g. a list of gem directories, or a remote\n# source).  A SourceIndex maps a gem full name to a gem\n# specification.\n#\n# NOTE:: The class used to be named Cache, but that became\n#        confusing when cached source fetchers where introduced. The\n#        constant Gem::Cache is an alias for this class to allow old\n#        YAMLized source index objects to load properly.\n\nclass Gem::SourceIndex\n\n  include Enumerable\n\n  include Gem::UserInteraction\n\n  attr_reader :gems # :nodoc:\n\n  ##\n  # Directories to use to refresh this SourceIndex when calling refresh!\n\n  attr_accessor :spec_dirs\n\n  class << self\n    include Gem::UserInteraction\n\n    ##\n    # Factory method to construct a source index instance for a given\n    # path.\n    #\n    # deprecated::\n    #   If supplied, from_installed_gems will act just like\n    #   +from_gems_in+.  This argument is deprecated and is provided\n    #   just for backwards compatibility, and should not generally\n    #   be used.\n    #\n    # return::\n    #   SourceIndex instance\n\n    def from_installed_gems(*deprecated)\n      if deprecated.empty?\n        from_gems_in(*installed_spec_directories)\n      else\n        from_gems_in(*deprecated) # HACK warn\n      end\n    end\n\n    ##\n    # Returns a list of directories from Gem.path that contain specifications.\n\n    def installed_spec_directories\n      Gem.path.collect { |dir| File.join(dir, \"specifications\") }\n    end\n\n    ##\n    # Creates a new SourceIndex from the ruby format gem specifications in\n    # +spec_dirs+.\n\n    def from_gems_in(*spec_dirs)\n      source_index = new\n      source_index.spec_dirs = spec_dirs\n      source_index.refresh!\n    end\n\n    ##\n    # Loads a ruby-format specification from +file_name+ and returns the\n    # loaded spec.\n\n    def load_specification(file_name)\n      return nil unless file_name and File.exist? file_name\n\n      spec_code = if RUBY_VERSION < '1.9' then\n                    File.read file_name\n                  else\n                    File.read file_name, :encoding => 'UTF-8'\n                  end.untaint\n\n      begin\n        gemspec = eval spec_code, binding, file_name\n\n        if gemspec.is_a?(Gem::Specification)\n          gemspec.loaded_from = file_name\n          return gemspec\n        end\n        alert_warning \"File '#{file_name}' does not evaluate to a gem specification\"\n      rescue SignalException, SystemExit\n        raise\n      rescue SyntaxError => e\n        alert_warning e\n        alert_warning spec_code\n      rescue Exception => e\n        alert_warning \"#{e.inspect}\\n#{spec_code}\"\n        alert_warning \"Invalid .gemspec format in '#{file_name}'\"\n      end\n\n      return nil\n    end\n\n  end\n\n  ##\n  # Constructs a source index instance from the provided specifications, which\n  # is a Hash of gem full names and Gem::Specifications.\n  #--\n  # TODO merge @gems and @prerelease_gems and provide a separate method\n  # #prerelease_gems\n\n  def initialize(specifications={})\n    @gems = {}\n    specifications.each{ |full_name, spec| add_spec spec }\n    @spec_dirs = nil\n  end\n\n  # TODO: remove method\n  def all_gems\n    @gems\n  end\n\n  def prerelease_gems\n    @gems.reject{ |name, gem| !gem.version.prerelease? }\n  end\n\n  def released_gems\n    @gems.reject{ |name, gem| gem.version.prerelease? }\n  end\n\n  ##\n  # Reconstruct the source index from the specifications in +spec_dirs+.\n\n  def load_gems_in(*spec_dirs)\n    @gems.clear\n\n    spec_dirs.reverse_each do |spec_dir|\n      spec_files = Dir.glob File.join(spec_dir, '*.gemspec')\n\n      spec_files.each do |spec_file|\n        gemspec = self.class.load_specification spec_file.untaint\n        add_spec gemspec "..., 4096) = 4096
read(3, "atest released versions\n  # of each gem in this index.\n\n  def latest_specs\n    result = Hash.new { |h,k| h[k] = [] }\n    latest = {}\n\n    sort.each do |_, spec|\n      name = spec.name\n      curr_ver = spec.version\n      prev_ver = latest.key?(name) ? latest[name].version : nil\n\n      next if curr_ver.prerelease?\n      next unless prev_ver.nil? or curr_ver >= prev_ver or\n                  latest[name].platform != Gem::Platform::RUBY\n\n      if prev_ver.nil? or\n         (curr_ver > prev_ver and spec.platform == Gem::Platform::RUBY) then\n        result[name].clear\n        latest[name] = spec\n      end\n\n      if spec.platform != Gem::Platform::RUBY then\n        result[name].delete_if do |result_spec|\n          result_spec.platform == spec.platform\n        end\n      end\n\n      result[name] << spec\n    end\n\n    # TODO: why is this a hash while @gems is an array? Seems like\n    # structural similarity would be good.\n    result.values.flatten\n  end\n\n  ##\n  # An array including only the prerelease gemspecs\n\n  def prerelease_specs\n    prerelease_gems.values\n  end\n\n  ##\n  # An array including only the released gemspecs\n\n  def released_specs\n    released_gems.values\n  end\n\n  ##\n  # Add a gem specification to the source index.\n\n  def add_spec(gem_spec, name = gem_spec.full_name)\n    # No idea why, but the Indexer wants to insert them using original_name\n    # instead of full_name. So we make it an optional arg.\n    @gems[name] = gem_spec\n  end\n\n  ##\n  # Add gem specifications to the source index.\n\n  def add_specs(*gem_specs)\n    gem_specs.each do |spec|\n      add_spec spec\n    end\n  end\n\n  ##\n  # Remove a gem specification named +full_name+.\n\n  def remove_spec(full_name)\n    @gems.delete full_name\n  end\n\n  ##\n  # Iterate over the specifications in the source index.\n\n  def each(&block) # :yields: gem.full_name, gem\n    @gems.each(&block)\n  end\n\n  ##\n  # The gem specification given a full gem spec name.\n\n  def specification(full_name)\n    @gems[full_name]\n  end\n\n  ##\n  # The signature for the source index.  Changes in the signature indicate a\n  # change in the index.\n\n  def index_signature\n    require 'rubygems/digest/sha2'\n\n    Gem::SHA256.new.hexdigest(@gems.keys.sort.join(',')).to_s\n  end\n\n  ##\n  # The signature for the given gem specification.\n\n  def gem_signature(gem_full_name)\n    require 'rubygems/digest/sha2'\n\n    Gem::SHA256.new.hexdigest(@gems[gem_full_name].to_yaml).to_s\n  end\n\n  def size\n    @gems.size\n  end\n  alias length size\n\n  ##\n  # Find a gem by an exact match on the short name.\n\n  def find_name(gem_name, version_requirement = Gem::Requirement.default)\n    dep = Gem::Dependency.new gem_name, version_requirement\n    search dep\n  end\n\n  ##\n  # Search for a gem by Gem::Dependency +gem_pattern+.  If +only_platform+\n  # is true, only gems matching Gem::Platform.local will be returned.  An\n  # Array of matching Gem::Specification objects is returned.\n  #\n  # For backwards compatibility, a String or Regexp pattern may be passed as\n  # +gem_pattern+, and a Gem::Requirement for +platform_only+.  This\n  # behavior is deprecated and will be removed.\n\n  def search(gem_pattern, platform_only = false)\n    version_requirement = nil\n    only_platform = false\n\n    # TODO - Remove support and warning for legacy arguments after 2008/11\n    unless Gem::Dependency === gem_pattern\n      warn \"#{Gem.location_of_caller.join ':'}:Warning: Gem::SourceIndex#search support for #{gem_pattern.class} patterns is deprecated, use #find_name\"\n    end\n\n    case gem_pattern\n    when Regexp then\n      version_requirement = platform_only || Gem::Requirement.default\n    when Gem::Dependency then\n      only_platform = platform_only\n      version_requirement = gem_pattern.version_requirements\n      gem_pattern = if Regexp === gem_pattern.name then\n                      gem_pattern.name\n                    elsif gem_pattern.name.empty? then\n                      //\n                    else\n                      /^#{Regexp.escape gem_pattern.name}$/\n                 "..., 4096) = 4096
read(3, "pattern = /#{gem_pattern}/i\n    end\n\n    unless Gem::Requirement === version_requirement then\n      version_requirement = Gem::Requirement.create version_requirement\n    end\n\n    specs = all_gems.values.select do |spec|\n      spec.name =~ gem_pattern and\n        version_requirement.satisfied_by? spec.version\n    end\n\n    if only_platform then\n      specs = specs.select do |spec|\n        Gem::Platform.match spec.platform\n      end\n    end\n\n    specs.sort_by { |s| s.sort_obj }\n  end\n\n  ##\n  # Replaces the gems in the source index from specifications in the\n  # directories this source index was created from.  Raises an exception if\n  # this source index wasn't created from a directory (via from_gems_in or\n  # from_installed_gems, or having spec_dirs set).\n\n  def refresh!\n    raise 'source index not created from disk' if @spec_dirs.nil?\n    load_gems_in(*@spec_dirs)\n  end\n\n  ##\n  # Returns an Array of Gem::Specifications that are not up to date.\n\n  def outdated\n    outdateds = []\n\n    latest_specs.each do |local|\n      dependency = Gem::Dependency.new local.name, \">= #{local.version}\"\n\n      begin\n        fetcher = Gem::SpecFetcher.fetcher\n        remotes = fetcher.find_matching dependency\n        remotes = remotes.map { |(name, version,_),_| version }\n      rescue Gem::RemoteFetcher::FetchError => e\n        raise unless fetcher.warn_legacy e do\n          require 'rubygems/source_info_cache'\n\n          specs = Gem::SourceInfoCache.search_with_source dependency, true\n\n          remotes = specs.map { |spec,| spec.version }\n        end\n      end\n\n      latest = remotes.sort.last\n\n      outdateds << local.name if latest and local.version < latest\n    end\n\n    outdateds\n  end\n\n  ##\n  # Updates this SourceIndex from +source_uri+.  If +all+ is false, only the\n  # latest gems are fetched.\n\n  def update(source_uri, all)\n    source_uri = URI.parse source_uri unless URI::Generic === source_uri\n    source_uri.path += '/' unless source_uri.path =~ /\\/$/\n\n    use_incremental = false\n\n    begin\n      gem_names = fetch_quick_index source_uri, all\n      remove_extra gem_names\n      missing_gems = find_missing gem_names\n\n      return false if missing_gems.size.zero?\n\n      say \"Missing metadata for #{missing_gems.size} gems\" if\n      missing_gems.size > 0 and Gem.configuration.really_verbose\n\n      use_incremental = missing_gems.size <= Gem.configuration.bulk_threshold\n    rescue Gem::OperationNotSupportedError => ex\n      alert_error \"Falling back to bulk fetch: #{ex.message}\" if\n      Gem.configuration.really_verbose\n      use_incremental = false\n    end\n\n    if use_incremental then\n      update_with_missing(source_uri, missing_gems)\n    else\n      new_index = fetch_bulk_index(source_uri)\n      @gems.replace(new_index.gems)\n    end\n\n    true\n  end\n\n  def ==(other) # :nodoc:\n    self.class === other and @gems == other.gems \n  end\n\n  def dump\n    Marshal.dump(self)\n  end\n\n  private\n\n  def fetcher\n    require 'rubygems/remote_fetcher'\n\n    Gem::RemoteFetcher.fetcher\n  end\n\n  def fetch_index_from(source_uri)\n    @fetch_error = nil\n\n    indexes = %W[\n        Marshal.#{Gem.marshal_version}.Z\n        Marshal.#{Gem.marshal_version}\n        yaml.Z\n        yaml\n      ]\n\n    indexes.each do |name|\n      spec_data = nil\n      index = source_uri + name\n      begin\n        spec_data = fetcher.fetch_path index\n        spec_data = unzip(spec_data) if name =~ /\\.Z$/\n\n        if name =~ /Marshal/ then\n          return Marshal.load(spec_data)\n        else\n          return YAML.load(spec_data)\n        end\n      rescue => e\n        if Gem.configuration.really_verbose then\n          alert_error \"Unable to fetch #{name}: #{e.message}\"\n        end\n\n        @fetch_error = e\n      end\n    end\n\n    nil\n  end\n\n  def fetch_bulk_index(source_uri)\n    say \"Bulk updating Gem source index for: #{source_uri}\" if\n      Gem.configuration.verbose\n\n    index = fetch_index_from(source_uri)\n    if index.nil? then\n      raise Gem::RemoteSourceException,\n              \"Error fetching rem"..., 4096) = 4096
read(3, " quick index needed for incremental updates.\n\n  def fetch_quick_index(source_uri, all)\n    index = all ? 'index' : 'latest_index'\n\n    zipped_index = fetcher.fetch_path source_uri + \"quick/#{index}.rz\"\n\n    unzip(zipped_index).split(\"\\n\")\n  rescue ::Exception => e\n    unless all then\n      say \"Latest index not found, using quick index\" if\n        Gem.configuration.really_verbose\n\n      fetch_quick_index source_uri, true\n    else\n      raise Gem::OperationNotSupportedError,\n            \"No quick index found: #{e.message}\"\n    end\n  end\n\n  ##\n  # Make a list of full names for all the missing gemspecs.\n\n  def find_missing(spec_names)\n    unless defined? @originals then\n      @originals = {}\n      each do |full_name, spec|\n        @originals[spec.original_name] = spec\n      end\n    end\n\n    spec_names.find_all { |full_name|\n      @originals[full_name].nil?\n    }\n  end\n\n  def remove_extra(spec_names)\n    dictionary = spec_names.inject({}) { |h, k| h[k] = true; h }\n    each do |name, spec|\n      remove_spec name unless dictionary.include? spec.original_name\n    end\n  end\n\n  ##\n  # Unzip the given string.\n\n  def unzip(string)\n    require 'zlib'\n    Gem.inflate string\n  end\n\n  ##\n  # Tries to fetch Marshal representation first, then YAML\n\n  def fetch_single_spec(source_uri, spec_name)\n    @fetch_error = nil\n\n    begin\n      marshal_uri = source_uri + \"quick/Marshal.#{Gem.marshal_version}/#{spec_name}.gemspec.rz\"\n      zipped = fetcher.fetch_path marshal_uri\n      return Marshal.load(unzip(zipped))\n    rescue => ex\n      @fetch_error = ex\n\n      if Gem.configuration.really_verbose then\n        say \"unable to fetch marshal gemspec #{marshal_uri}: #{ex.class} - #{ex}\"\n      end\n    end\n\n    begin\n      yaml_uri = source_uri + \"quick/#{spec_name}.gemspec.rz\"\n      zipped = fetcher.fetch_path yaml_uri\n      return YAML.load(unzip(zipped))\n    rescue => ex\n      @fetch_error = ex\n      if Gem.configuration.really_verbose then\n        say \"unable to fetch YAML gemspec #{yaml_uri}: #{ex.class} - #{ex}\"\n      end\n    end\n\n    nil\n  end\n\n  ##\n  # Update the cached source index with the missing names.\n\n  def update_with_missing(source_uri, missing_names)\n    progress = ui.progress_reporter(missing_names.size,\n        \"Updating metadata for #{missing_names.size} gems from #{source_uri}\")\n    missing_names.each do |spec_name|\n      gemspec = fetch_single_spec(source_uri, spec_name)\n      if gemspec.nil? then\n        ui.say \"Failed to download spec #{spec_name} from #{source_uri}:\\n\" \\\n                 \"\\t#{@fetch_error.message}\"\n      else\n        add_spec gemspec\n        progress.updated spec_name\n      end\n      @fetch_error = nil\n    end\n    progress.done\n    progress.count\n  end\n\nend\n\n# :stopdoc:\nmodule Gem\n\n  ##\n  # Cache is an alias for SourceIndex to allow older YAMLized source index\n  # objects to load properly.\n\n  Cache = SourceIndex\n\nend\n# :startdoc:\n\n", 4096) = 2894
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/user_interaction.rb", {st_mode=S_IFREG|0644, st_size=7438, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/user_interaction.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=7438, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/user_interaction.rb", {st_mode=S_IFREG|0644, st_size=7438, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/user_interaction.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=7438, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/user_interaction.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=7438, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/user_interaction.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/user_interaction.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=7438, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\n##\n# Module that defines the default UserInteraction.  Any class including this\n# module will have access to the +ui+ method that returns the default UI.\n\nmodule Gem::DefaultUserInteraction\n\n  ##\n  # The default UI is a class variable of the singleton class for this\n  # module.\n\n  @ui = nil\n\n  ##\n  # Return the default UI.\n\n  def self.ui\n    @ui ||= Gem::ConsoleUI.new\n  end\n\n  ##\n  # Set the default UI.  If the default UI is never explicitly set, a simple\n  # console based UserInteraction will be used automatically.\n\n  def self.ui=(new_ui)\n    @ui = new_ui\n  end\n\n  ##\n  # Use +new_ui+ for the duration of +block+.\n\n  def self.use_ui(new_ui)\n    old_ui = @ui\n    @ui = new_ui\n    yield\n  ensure\n    @ui = old_ui\n  end\n\n  ##\n  # See DefaultUserInteraction::ui\n\n  def ui\n    Gem::DefaultUserInteraction.ui\n  end\n\n  ##\n  # See DefaultUserInteraction::ui=\n\n  def ui=(new_ui)\n    Gem::DefaultUserInteraction.ui = new_ui\n  end\n\n  ##\n  # See DefaultUserInteraction::use_ui\n\n  def use_ui(new_ui, &block)\n    Gem::DefaultUserInteraction.use_ui(new_ui, &block)\n  end\n\nend\n\n##\n# Make the default UI accessable without the \"ui.\" prefix.  Classes\n# including this module may use the interaction methods on the default UI\n# directly.  Classes may also reference the ui and ui= methods.\n#\n# Example:\n#\n#   class X\n#     include Gem::UserInteraction\n#\n#     def get_answer\n#       n = ask(\"What is the meaning of life?\")\n#     end\n#   end\n\nmodule Gem::UserInteraction\n\n  include Gem::DefaultUserInteraction\n\n  ##\n  # :method: alert\n\n  ##\n  # :method: alert_error\n\n  ##\n  # :method: alert_warning\n\n  ##\n  # :method: ask\n\n  ##\n  # :method: ask_yes_no\n\n  ##\n  # :method: choose_from_list\n\n  ##\n  # :method: say\n\n  ##\n  # :method: terminate_interaction\n\n  [:alert,\n   :alert_error,\n   :alert_warning,\n   :ask,\n   :ask_yes_no,\n   :choose_from_list,\n   :say,\n   :terminate_interaction ].each do |methname|\n    class_eval %{\n      def #{methname}(*args)\n        ui.#{methname}(*args)\n      end\n    }, __FILE__, __LINE__\n  end\nend\n\n##\n# Gem::StreamUI implements a simple stream based user interface.\n\nclass Gem::StreamUI\n\n  attr_reader :ins, :outs, :errs\n\n  def initialize(in_stream, out_stream, err_stream=STDERR)\n    @ins = in_stream\n    @outs = out_stream\n    @errs = err_stream\n  end\n\n  ##\n  # Choose from a list of options.  +question+ is a prompt displayed above\n  # the list.  +list+ is a list of option strings.  Returns the pair\n  # [option_name, option_index].\n\n  def choose_from_list(question, list)\n    @outs.puts question\n\n    list.each_with_index do |item, index|\n      @outs.puts \" #{index+1}. #{item}\"\n    end\n\n    @outs.print \"> \"\n    @outs.flush\n\n    result = @ins.gets\n\n    return nil, nil unless result\n\n    result = result.strip.to_i - 1\n    return list[result], result\n  end\n\n  ##\n  # Ask a question.  Returns a true for yes, false for no.  If not connected\n  # to a tty, raises an exception if default is nil, otherwise returns\n  # default.\n\n  def ask_yes_no(question, default=nil)\n    unless @ins.tty? then\n      if default.nil? then\n        raise Gem::OperationNotSupportedError,\n              \"Not connected to a tty and no default specified\"\n      else\n        return default\n      end\n    end\n\n    qstr = case default\n           when nil\n             'yn'\n           when true\n             'Yn'\n           else\n             'yN'\n           end\n\n    result = nil\n\n    while result.nil?\n      result = ask(\"#{question} [#{qstr}]\")\n      result = case result\n      when /^[Yy].*/\n        true\n      when /^[Nn].*/\n        false\n      when /^$/\n        default\n      else\n        nil\n      end\n    end\n\n    return result\n  end\n\n  ##\n  # Ask a question.  Returns an answer if connected to a tty, nil otherwise.\n\n  def ask(question)\n    return nil if not @ins.tty?\n\n    @outs.print(question + \"  \")\n    @outs.flush\n\n    result = @ins.gets\n    result.chomp! if"..., 4096) = 4096
brk(0x9e5d000)                          = 0x9e5d000
read(3, "statement\n  end\n\n  ##\n  # Display an informational alert.  Will ask +question+ if it is not nil.\n\n  def alert(statement, question=nil)\n    @outs.puts \"INFO:  #{statement}\"\n    ask(question) if question\n  end\n\n  ##\n  # Display a warning in a location expected to get error messages.  Will\n  # ask +question+ if it is not nil.\n\n  def alert_warning(statement, question=nil)\n    @errs.puts \"WARNING:  #{statement}\"\n    ask(question) if question\n  end\n\n  ##\n  # Display an error message in a location expected to get error messages.\n  # Will ask +question+ if it is not nil.\n\n  def alert_error(statement, question=nil)\n    @errs.puts \"ERROR:  #{statement}\"\n    ask(question) if question\n  end\n\n  ##\n  # Display a debug message on the same location as error messages.\n\n  def debug(statement)\n    @errs.puts statement\n  end\n\n  ##\n  # Terminate the application with exit code +status+, running any exit\n  # handlers that might have been defined.\n\n  def terminate_interaction(status = 0)\n    raise Gem::SystemExitException, status\n  end\n\n  ##\n  # Return a progress reporter object chosen from the current verbosity.\n\n  def progress_reporter(*args)\n    case Gem.configuration.verbose\n    when nil, false\n      SilentProgressReporter.new(@outs, *args)\n    when true\n      SimpleProgressReporter.new(@outs, *args)\n    else\n      VerboseProgressReporter.new(@outs, *args)\n    end\n  end\n\n  ##\n  # An absolutely silent progress reporter.\n\n  class SilentProgressReporter\n    attr_reader :count\n\n    def initialize(out_stream, size, initial_message, terminal_message = nil)\n    end\n\n    def updated(message)\n    end\n\n    def done\n    end\n  end\n\n  ##\n  # A basic dotted progress reporter.\n\n  class SimpleProgressReporter\n\n    include Gem::DefaultUserInteraction\n\n    attr_reader :count\n\n    def initialize(out_stream, size, initial_message,\n                   terminal_message = \"complete\")\n      @out = out_stream\n      @total = size\n      @count = 0\n      @terminal_message = terminal_message\n\n      @out.puts initial_message\n    end\n\n    ##\n    # Prints out a dot and ignores +message+.\n\n    def updated(message)\n      @count += 1\n      @out.print \".\"\n      @out.flush\n    end\n\n    ##\n    # Prints out the terminal message.\n\n    def done\n      @out.puts \"\\n#{@terminal_message}\"\n    end\n\n  end\n\n  ##\n  # A progress reporter that prints out messages about the current progress.\n\n  class VerboseProgressReporter\n\n    include Gem::DefaultUserInteraction\n\n    attr_reader :count\n\n    def initialize(out_stream, size, initial_message,\n                   terminal_message = 'complete')\n      @out = out_stream\n      @total = size\n      @count = 0\n      @terminal_message = terminal_message\n\n      @out.puts initial_message\n    end\n\n    ##\n    # Prints out the position relative to the total and the +message+.\n\n    def updated(message)\n      @count += 1\n      @out.puts \"#{@count}/#{@total}: #{message}\"\n    end\n\n    ##\n    # Prints out the terminal message.\n\n    def done\n      @out.puts @terminal_message\n    end\n  end\n\nend\n\n##\n# Subclass of StreamUI that instantiates the user interaction using STDIN,\n# STDOUT, and STDERR.\n\nclass Gem::ConsoleUI < Gem::StreamUI\n  def initialize\n    super STDIN, STDOUT, STDERR\n  end\nend\n\n##\n# SilentUI is a UI choice that is absolutely silent.\n\nclass Gem::SilentUI\n  def method_missing(sym, *args, &block)\n    self\n  end\nend\n\n", 4096) = 3342
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/specification.rb", {st_mode=S_IFREG|0644, st_size=36767, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/specification.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=36767, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/specification.rb", {st_mode=S_IFREG|0644, st_size=36767, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/specification.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=36767, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/specification.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=36767, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/specification.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/specification.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=36767, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\nrequire 'rubygems/version'\nrequire 'rubygems/requirement'\nrequire 'rubygems/platform'\n\n# :stopdoc:\nclass Date; end # for ruby_code if date.rb wasn't required\n# :startdoc:\n\n##\n# The Specification class contains the metadata for a Gem.  Typically\n# defined in a .gemspec file or a Rakefile, and looks like this:\n#\n#   spec = Gem::Specification.new do |s|\n#     s.name = 'rfoo'\n#     s.version = '1.0'\n#     s.summary = 'Example gem specification'\n#     ...\n#   end\n#\n# For a great way to package gems, use Hoe.\n\nclass Gem::Specification\n\n  ##\n  # Allows deinstallation of gems with legacy platforms.\n\n  attr_accessor :original_platform # :nodoc:\n\n  ##\n  # The the version number of a specification that does not specify one\n  # (i.e. RubyGems 0.7 or earlier).\n\n  NONEXISTENT_SPECIFICATION_VERSION = -1\n\n  ##\n  # The specification version applied to any new Specification instances\n  # created.  This should be bumped whenever something in the spec format\n  # changes.\n  #--\n  # When updating this number, be sure to also update #to_ruby.\n  #\n  # NOTE RubyGems < 1.2 cannot load specification versions > 2.\n\n  CURRENT_SPECIFICATION_VERSION = 3\n\n  ##\n  # An informal list of changes to the specification.  The highest-valued\n  # key should be equal to the CURRENT_SPECIFICATION_VERSION.\n\n  SPECIFICATION_VERSION_HISTORY = {\n    -1 => ['(RubyGems versions up to and including 0.7 did not have versioned specifications)'],\n    1  => [\n      'Deprecated \"test_suite_file\" in favor of the new, but equivalent, \"test_files\"',\n      '\"test_file=x\" is a shortcut for \"test_files=[x]\"'\n    ],\n    2  => [\n      'Added \"required_rubygems_version\"',\n      'Now forward-compatible with future versions',\n    ],\n    3 => [\n       'Added Fixnum validation to the specification_version'\n    ]\n  }\n\n  # :stopdoc:\n  MARSHAL_FIELDS = { -1 => 16, 1 => 16, 2 => 16, 3 => 17 }\n\n  now = Time.at(Time.now.to_i)\n  TODAY = now - ((now.to_i + now.gmt_offset) % 86400)\n  # :startdoc:\n\n  ##\n  # Optional block used to gather newly defined instances.\n\n  @@gather = nil\n\n  ##\n  # List of attribute names: [:name, :version, ...]\n\n  @@required_attributes = []\n\n  ##\n  # List of _all_ attributes and default values:\n  #\n  #   [[:name, nil],\n  #    [:bindir, 'bin'],\n  #    ...]\n\n  @@attributes = []\n\n  @@nil_attributes = []\n  @@non_nil_attributes = [:@original_platform]\n\n  ##\n  # List of array attributes\n\n  @@array_attributes = []\n\n  ##\n  # Map of attribute names to default values.\n\n  @@default_value = {}\n\n  ##\n  # Names of all specification attributes\n\n  def self.attribute_names\n    @@attributes.map { |name, default| name }\n  end\n\n  ##\n  # Default values for specification attributes\n\n  def self.attribute_defaults\n    @@attributes.dup\n  end\n\n  ##\n  # The default value for specification attribute +name+\n\n  def self.default_value(name)\n    @@default_value[name]\n  end\n\n  ##\n  # Required specification attributes\n\n  def self.required_attributes\n    @@required_attributes.dup\n  end\n\n  ##\n  # Is +name+ a required attribute?\n\n  def self.required_attribute?(name)\n    @@required_attributes.include? name.to_sym\n  end\n\n  ##\n  # Specification attributes that are arrays (appendable and so-forth)\n\n  def self.array_attributes\n    @@array_attributes.dup\n  end\n\n  ##\n  # Specifies the +name+ and +default+ for a specification attribute, and\n  # creates a reader and writer method like Module#attr_accessor.\n  #\n  # The reader method returns the default if the value hasn't been set.\n\n  def self.attribute(name, default=nil)\n    ivar_name = \"@#{name}\".intern\n    if default.nil? then\n      @@nil_attributes << ivar_name\n    else\n      @@non_nil_attributes << [ivar_name, default]\n    end\n\n    @@attributes << [name, default]\n    @@default_value[name] = default\n    attr_accessor(name)\n  end\n\n  ##\n  # Same as :attribute, but ensures that values assigned to the attribute\n  # are array values by applyi"..., 4096) = 4096
read(3, ".intern, []]\n\n    @@array_attributes << name\n    @@attributes << [name, []]\n    @@default_value[name] = []\n    code = %{\n      def #{name}\n        @#{name} ||= []\n      end\n      def #{name}=(value)\n        @#{name} = Array(value)\n      end\n    }\n\n    module_eval code, __FILE__, __LINE__ - 9\n  end\n\n  ##\n  # Same as attribute above, but also records this attribute as mandatory.\n\n  def self.required_attribute(*args)\n    @@required_attributes << args.first\n    attribute(*args)\n  end\n\n  ##\n  # Sometimes we don't want the world to use a setter method for a\n  # particular attribute.\n  #\n  # +read_only+ makes it private so we can still use it internally.\n\n  def self.read_only(*names)\n    names.each do |name|\n      private \"#{name}=\"\n    end\n  end\n\n  # Shortcut for creating several attributes at once (each with a default\n  # value of +nil+).\n\n  def self.attributes(*args)\n    args.each do |arg|\n      attribute(arg, nil)\n    end\n  end\n\n  ##\n  # Some attributes require special behaviour when they are accessed.  This\n  # allows for that.\n\n  def self.overwrite_accessor(name, &block)\n    remove_method name\n    define_method(name, &block)\n  end\n\n  ##\n  # Defines a _singular_ version of an existing _plural_ attribute (i.e. one\n  # whose value is expected to be an array).  This means just creating a\n  # helper method that takes a single value and appends it to the array.\n  # These are created for convenience, so that in a spec, one can write\n  #\n  #   s.require_path = 'mylib'\n  #\n  # instead of:\n  #\n  #   s.require_paths = ['mylib']\n  #\n  # That above convenience is available courtesy of:\n  #\n  #   attribute_alias_singular :require_path, :require_paths\n\n  def self.attribute_alias_singular(singular, plural)\n    define_method(\"#{singular}=\") { |val|\n      send(\"#{plural}=\", [val])\n    }\n    define_method(\"#{singular}\") {\n      val = send(\"#{plural}\")\n      val.nil? ? nil : val.first\n    }\n  end\n\n  ##\n  # Dump only crucial instance variables.\n  #--\n  # MAINTAIN ORDER!\n\n  def _dump(limit)\n    Marshal.dump [\n      @rubygems_version,\n      @specification_version,\n      @name,\n      @version,\n      (Time === @date ? @date : (require 'time'; Time.parse(@date.to_s))),\n      @summary,\n      @required_ruby_version,\n      @required_rubygems_version,\n      @original_platform,\n      @dependencies,\n      @rubyforge_project,\n      @email,\n      @authors,\n      @description,\n      @homepage,\n      @has_rdoc,\n      @new_platform,\n      @licenses\n    ]\n  end\n\n  ##\n  # Load custom marshal format, re-initializing defaults as needed\n\n  def self._load(str)\n    array = Marshal.load str\n\n    spec = Gem::Specification.new\n    spec.instance_variable_set :@specification_version, array[1]\n\n    current_version = CURRENT_SPECIFICATION_VERSION\n\n    field_count = if spec.specification_version > current_version then\n                    spec.instance_variable_set :@specification_version,\n                                               current_version\n                    MARSHAL_FIELDS[current_version]\n                  else\n                    MARSHAL_FIELDS[spec.specification_version]\n                  end\n\n    if array.size < field_count then\n      raise TypeError, \"invalid Gem::Specification format #{array.inspect}\"\n    end\n\n    spec.instance_variable_set :@rubygems_version,          array[0]\n    # spec version\n    spec.instance_variable_set :@name,                      array[2]\n    spec.instance_variable_set :@version,                   array[3]\n    spec.instance_variable_set :@date,                      array[4]\n    spec.instance_variable_set :@summary,                   array[5]\n    spec.instance_variable_set :@required_ruby_version,     array[6]\n    spec.instance_variable_set :@required_rubygems_version, array[7]\n    spec.instance_variable_set :@original_platform,         array[8]\n    spec.instance_variable_set :@dependencies,              array[9]\n    spec.instance_variable_set :@rubyforge_project,         array[10]\n    spec.instance_variable_set :@email,                "..., 4096) = 4096
read(3, "stance_variable_set :@description,               array[13]\n    spec.instance_variable_set :@homepage,                  array[14]\n    spec.instance_variable_set :@has_rdoc,                  array[15]\n    spec.instance_variable_set :@new_platform,              array[16]\n    spec.instance_variable_set :@platform,                  array[16].to_s\n    spec.instance_variable_set :@license,                   array[17]\n    spec.instance_variable_set :@loaded,                    false\n\n    spec\n  end\n\n  ##\n  # List of depedencies that will automatically be activated at runtime.\n\n  def runtime_dependencies\n    dependencies.select { |d| d.type == :runtime || d.type == nil }\n  end\n\n  ##\n  # List of dependencies that are used for development\n\n  def development_dependencies\n    dependencies.select { |d| d.type == :development }\n  end\n\n  def test_suite_file # :nodoc:\n    warn 'test_suite_file deprecated, use test_files'\n    test_files.first\n  end\n\n  def test_suite_file=(val) # :nodoc:\n    warn 'test_suite_file= deprecated, use test_files='\n    @test_files = [] unless defined? @test_files\n    @test_files << val\n  end\n\n  ##\n  # true when this gemspec has been loaded from a specifications directory.\n  # This attribute is not persisted.\n\n  attr_accessor :loaded\n\n  ##\n  # Path this gemspec was loaded from.  This attribute is not persisted.\n\n  attr_accessor :loaded_from\n\n  ##\n  # Returns an array with bindir attached to each executable in the\n  # executables list\n\n  def add_bindir(executables)\n    return nil if executables.nil?\n\n    if @bindir then\n      Array(executables).map { |e| File.join(@bindir, e) }\n    else\n      executables\n    end\n  rescue\n    return nil\n  end\n\n  ##\n  # Files in the Gem under one of the require_paths\n\n  def lib_files\n    @files.select do |file|\n      require_paths.any? do |path|\n        file.index(path) == 0\n      end\n    end\n  end\n\n  ##\n  # True if this gem was loaded from disk\n\n  alias :loaded? :loaded\n\n  ##\n  # True if this gem has files in test_files\n\n  def has_unit_tests?\n    not test_files.empty?\n  end\n\n  # :stopdoc:\n  alias has_test_suite? has_unit_tests?\n  # :startdoc:\n\n  ##\n  # Specification constructor.  Assigns the default values to the attributes\n  # and yields itself for further initialization.\n\n  def initialize\n    @new_platform = nil\n    assign_defaults\n    @loaded = false\n    @loaded_from = nil\n\n    yield self if block_given?\n\n    @@gather.call(self) if @@gather\n  end\n\n  ##\n  # Duplicates array_attributes from +other_spec+ so state isn't shared.\n\n  def initialize_copy(other_spec)\n    other_ivars = other_spec.instance_variables\n    other_ivars = other_ivars.map { |ivar| ivar.intern } if # for 1.9\n      other_ivars.any? { |ivar| String === ivar }\n\n    self.class.array_attributes.each do |name|\n      name = :\"@#{name}\"\n      next unless other_ivars.include? name\n      instance_variable_set name, other_spec.instance_variable_get(name).dup\n    end\n  end\n\n  ##\n  # Each attribute has a default value (possibly nil).  Here, we initialize\n  # all attributes to their default value.  This is done through the\n  # accessor methods, so special behaviours will be honored.  Furthermore,\n  # we take a _copy_ of the default so each specification instance has its\n  # own empty arrays, etc.\n\n  def assign_defaults\n    @@nil_attributes.each do |name|\n      instance_variable_set name, nil\n    end\n\n    @@non_nil_attributes.each do |name, default|\n      value = case default\n              when Time, Numeric, Symbol, true, false, nil then default\n              else default.dup\n              end\n\n      instance_variable_set name, value\n    end\n\n    # HACK\n    instance_variable_set :@new_platform, Gem::Platform::RUBY\n  end\n\n  ##\n  # Special loader for YAML files.  When a Specification object is loaded\n  # from a YAML file, it bypasses the normal Ruby object initialization\n  # routine (#initialize).  This method makes up for that and deals with\n  # gems of different ages.\n  #\n  # 'input' can be anything that YAML.load() accepts: String "..., 4096) = 4096
read(3, "input\n\n    if spec && spec.class == FalseClass then\n      raise Gem::EndOfYAMLException\n    end\n\n    unless Gem::Specification === spec then\n      raise Gem::Exception, \"YAML data doesn't evaluate to gem specification\"\n    end\n\n    unless (spec.instance_variables.include? '@specification_version' or\n            spec.instance_variables.include? :@specification_version) and\n           spec.instance_variable_get :@specification_version\n      spec.instance_variable_set :@specification_version,\n                                 NONEXISTENT_SPECIFICATION_VERSION\n    end\n\n    spec\n  end\n\n  ##\n  # Loads ruby format gemspec from +filename+\n\n  def self.load(filename)\n    gemspec = nil\n    fail \"NESTED Specification.load calls not allowed!\" if @@gather\n    @@gather = proc { |gs| gemspec = gs }\n    data = File.read(filename)\n    eval(data)\n    gemspec\n  ensure\n    @@gather = nil\n  end\n\n  ##\n  # Make sure the YAML specification is properly formatted with dashes\n\n  def self.normalize_yaml_input(input)\n    result = input.respond_to?(:read) ? input.read : input\n    result = \"--- \" + result unless result =~ /^--- /\n    result\n  end\n\n  ##\n  # Sets the rubygems_version to the current RubyGems version\n\n  def mark_version\n    @rubygems_version = Gem::RubyGemsVersion\n  end\n\n  ##\n  # Ignore unknown attributes while loading\n\n  def method_missing(sym, *a, &b) # :nodoc:\n    if @specification_version > CURRENT_SPECIFICATION_VERSION and\n      sym.to_s =~ /=$/ then\n      warn \"ignoring #{sym} loading #{full_name}\" if $DEBUG\n    else\n      super\n    end\n  end\n\n  ##\n  # Adds a development dependency named +gem+ with +requirements+ to this\n  # Gem.  For example:\n  #\n  #   spec.add_development_dependency 'jabber4r', '> 0.1', '<= 0.5'\n  #\n  # Development dependencies aren't installed by default and aren't\n  # activated when a gem is required.\n\n  def add_development_dependency(gem, *requirements)\n    add_dependency_with_type(gem, :development, *requirements)\n  end\n\n  ##\n  # Adds a runtime dependency named +gem+ with +requirements+ to this Gem.\n  # For example:\n  #\n  #   spec.add_runtime_dependency 'jabber4r', '> 0.1', '<= 0.5'\n\n  def add_runtime_dependency(gem, *requirements)\n    add_dependency_with_type(gem, :runtime, *requirements)\n  end\n\n  ##\n  # Adds a runtime dependency\n\n  alias add_dependency add_runtime_dependency\n\n  ##\n  # Returns the full name (name-version) of this Gem.  Platform information\n  # is included (name-version-platform) if it is specified and not the\n  # default Ruby platform.\n\n  def full_name\n    if platform == Gem::Platform::RUBY or platform.nil? then\n      \"#{@name}-#{@version}\"\n    else\n      \"#{@name}-#{@version}-#{platform}\"\n    end\n  end\n\n  ##\n  # Returns the full name (name-version) of this gemspec using the original\n  # platform.  For use with legacy gems.\n\n  def original_name # :nodoc:\n    if platform == Gem::Platform::RUBY or platform.nil? then\n      \"#{@name}-#{@version}\"\n    else\n      \"#{@name}-#{@version}-#{@original_platform}\"\n    end\n  end\n\n  ##\n  # The full path to the gem (install path + full name).\n\n  def full_gem_path\n    path = File.join installation_path, 'gems', full_name\n    return path if File.directory? path\n    File.join installation_path, 'gems', original_name\n  end\n\n  ##\n  # The default (generated) file name of the gem.\n\n  def file_name\n    full_name + \".gem\"\n  end\n\n  ##\n  # The directory that this gem was installed into.\n\n  def installation_path\n    unless @loaded_from then\n      raise Gem::Exception, \"spec #{full_name} is not from an installed gem\"\n    end\n\n    File.expand_path File.dirname(File.dirname(@loaded_from))\n  end\n\n  ##\n  # Checks if this specification meets the requirement of +dependency+.\n\n  def satisfies_requirement?(dependency)\n    return @name == dependency.name &&\n      dependency.version_requirements.satisfied_by?(@version)\n  end\n\n  ##\n  # Returns an object you can use to sort specifications in #sort_by.\n\n  def sort_obj\n    [@name, @version, @new_platform == Gem::Platform::RUBY ? -1 : 1]\n  end"..., 4096) = 4096
brk(0x9e7e000)                          = 0x9e7e000
read(3, "ality (across all attributes).\n\n  def ==(other) # :nodoc:\n    self.class === other && same_attributes?(other)\n  end\n\n  alias eql? == # :nodoc:\n\n  ##\n  # True if this gem has the same attributes as +other+.\n\n  def same_attributes?(other)\n    @@attributes.each do |name, default|\n      return false unless self.send(name) == other.send(name)\n    end\n    true\n  end\n\n  private :same_attributes?\n\n  def hash # :nodoc:\n    @@attributes.inject(0) { |hash_code, (name, default_value)|\n      n = self.send(name).hash\n      hash_code + n\n    }\n  end\n\n  def to_yaml(opts = {}) # :nodoc:\n    mark_version\n\n    attributes = @@attributes.map { |name,| name.to_s }.sort\n    attributes = attributes - %w[name version platform]\n\n    yaml = YAML.quick_emit object_id, opts do |out|\n      out.map taguri, to_yaml_style do |map|\n        map.add 'name', @name\n        map.add 'version', @version\n        platform = case @original_platform\n                   when nil, '' then\n                     'ruby'\n                   when String then\n                     @original_platform\n                   else\n                     @original_platform.to_s\n                   end\n        map.add 'platform', platform\n\n        attributes.each do |name|\n          map.add name, instance_variable_get(\"@#{name}\")\n        end\n      end\n    end\n  end\n\n  def yaml_initialize(tag, vals) # :nodoc:\n    vals.each do |ivar, val|\n      instance_variable_set \"@#{ivar}\", val\n    end\n\n    @original_platform = @platform # for backwards compatibility\n    self.platform = Gem::Platform.new @platform\n  end\n\n  ##\n  # Returns a Ruby code representation of this specification, such that it\n  # can be eval'ed and reconstruct the same specification later.  Attributes\n  # that still have their default values are omitted.\n\n  def to_ruby\n    mark_version\n    result = []\n    result << \"# -*- encoding: utf-8 -*-\"\n    result << nil\n    result << \"Gem::Specification.new do |s|\"\n\n    result << \"  s.name = #{ruby_code name}\"\n    result << \"  s.version = #{ruby_code version}\"\n    unless platform.nil? or platform == Gem::Platform::RUBY then\n      result << \"  s.platform = #{ruby_code original_platform}\"\n    end\n    result << \"\"\n    result << \"  s.required_rubygems_version = #{ruby_code required_rubygems_version} if s.respond_to? :required_rubygems_version=\"\n\n    handled = [\n      :dependencies,\n      :name,\n      :platform,\n      :required_rubygems_version,\n      :specification_version,\n      :version,\n    ]\n\n    attributes = @@attributes.sort_by { |attr_name,| attr_name.to_s }\n\n    attributes.each do |attr_name, default|\n      next if handled.include? attr_name\n      current_value = self.send(attr_name)\n      if current_value != default or\n         self.class.required_attribute? attr_name then\n        result << \"  s.#{attr_name} = #{ruby_code current_value}\"\n      end\n    end\n\n    result << nil\n    result << \"  if s.respond_to? :specification_version then\"\n    result << \"    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\"\n    result << \"    s.specification_version = #{specification_version}\"\n    result << nil\n\n    result << \"    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\"\n\n    unless dependencies.empty? then\n      dependencies.each do |dep|\n        version_reqs_param = dep.requirements_list.inspect\n        dep.instance_variable_set :@type, :runtime if dep.type.nil? # HACK\n        result << \"      s.add_#{dep.type}_dependency(%q<#{dep.name}>, #{version_reqs_param})\"\n      end\n    end\n\n    result << \"    else\"\n\n    unless dependencies.empty? then\n      dependencies.each do |dep|\n        version_reqs_param = dep.requirements_list.inspect\n        result << \"      s.add_dependency(%q<#{dep.name}>, #{version_reqs_param})\"\n      end\n    end\n\n    result << '    end'\n\n    result << \"  else\"\n      dependencies.each do |dep|\n        version_reqs_param = dep.requirements_list.inspect\n        result << \"    s.add_dependency(%q<#{dep.name}>, #{version_reqs_param})\"\n      e"..., 4096) = 4096
read(3, "#\n  # Checks that the specification contains all required fields, and does a\n  # very basic sanity check.\n  #\n  # Raises InvalidSpecificationException if the spec does not pass the\n  # checks..\n\n  def validate\n    extend Gem::UserInteraction\n    normalize\n\n    if rubygems_version != Gem::RubyGemsVersion then\n      raise Gem::InvalidSpecificationException,\n            \"expected RubyGems version #{Gem::RubyGemsVersion}, was #{rubygems_version}\"\n    end\n\n    @@required_attributes.each do |symbol|\n      unless self.send symbol then\n        raise Gem::InvalidSpecificationException,\n              \"missing value for attribute #{symbol}\"\n      end\n    end\n\n    unless String === name then\n      raise Gem::InvalidSpecificationException,\n            \"invalid value for attribute name: \\\"#{name.inspect}\\\"\"\n    end\n\n    if require_paths.empty? then\n      raise Gem::InvalidSpecificationException,\n            'specification must have at least one require_path'\n    end\n\n    @files.delete_if            do |file| File.directory? file end\n    @test_files.delete_if       do |file| File.directory? file end\n    @executables.delete_if      do |file|\n      File.directory? File.join(bindir, file)\n    end\n    @extra_rdoc_files.delete_if do |file| File.directory? file end\n    @extensions.delete_if       do |file| File.directory? file end\n\n    non_files = files.select do |file|\n      !File.file? file\n    end\n\n    unless non_files.empty? then\n      non_files = non_files.map { |file| file.inspect }\n      raise Gem::InvalidSpecificationException,\n            \"[#{non_files.join \", \"}] are not files\"\n    end\n\n    unless specification_version.is_a?(Fixnum)\n      raise Gem::InvalidSpecificationException,\n            'specification_version must be a Fixnum (did you mean version?)'\n    end\n\n    case platform\n    when Gem::Platform, Gem::Platform::RUBY then # ok\n    else\n      raise Gem::InvalidSpecificationException,\n            \"invalid platform #{platform.inspect}, see Gem::Platform\"\n    end\n\n    unless Array === authors and\n           authors.all? { |author| String === author } then\n      raise Gem::InvalidSpecificationException,\n            'authors must be Array of Strings'\n    end\n\n    licenses.each { |license|\n      if license.length > 64\n        raise Gem::InvalidSpecificationException,\n          \"each license must be 64 characters or less\"\n      end\n    }\n\n    # reject FIXME and TODO\n\n    unless authors.grep(/FIXME|TODO/).empty? then\n      raise Gem::InvalidSpecificationException,\n            '\"FIXME\" or \"TODO\" is not an author'\n    end\n\n    unless Array(email).grep(/FIXME|TODO/).empty? then\n      raise Gem::InvalidSpecificationException,\n            '\"FIXME\" or \"TODO\" is not an email address'\n    end\n\n    if description =~ /FIXME|TODO/ then\n      raise Gem::InvalidSpecificationException,\n            '\"FIXME\" or \"TODO\" is not a description'\n    end\n\n    if summary =~ /FIXME|TODO/ then\n      raise Gem::InvalidSpecificationException,\n            '\"FIXME\" or \"TODO\" is not a summary'\n    end\n\n    if homepage and not homepage.empty? and\n       homepage !~ /\\A[a-z][a-z\\d+.-]*:/i then\n      raise Gem::InvalidSpecificationException,\n            \"\\\"#{homepage}\\\" is not a URI\"\n    end\n\n    # Warnings\n\n    %w[author description email homepage rubyforge_project summary].each do |attribute|\n      value = self.send attribute\n      alert_warning \"no #{attribute} specified\" if value.nil? or value.empty?\n    end\n\n    if summary and not summary.empty? and description == summary then\n      alert_warning 'description and summary are identical'\n    end\n\n    alert_warning \"deprecated autorequire specified\" if autorequire\n\n    executables.each do |executable|\n      executable_path = File.join bindir, executable\n      shebang = File.read(executable_path, 2) == '#!'\n\n      alert_warning \"#{executable_path} is missing #! line\" unless shebang\n    end\n\n    true\n  end\n\n  ##\n  # Normalize the list of files so that:\n  # * All file lists have redundancies removed.\n  # * Files referenced"..., 4096) = 4096
read(3, "fined?(@extra_rdoc_files) and @extra_rdoc_files then\n      @extra_rdoc_files.uniq!\n      @files ||= []\n      @files.concat(@extra_rdoc_files)\n    end\n    @files.uniq! if @files\n  end\n\n  ##\n  # Return a list of all gems that have a dependency on this gemspec.  The\n  # list is structured with entries that conform to:\n  #\n  #   [depending_gem, dependency, [list_of_gems_that_satisfy_dependency]]\n\n  def dependent_gems\n    out = []\n    Gem.source_index.each do |name,gem|\n      gem.dependencies.each do |dep|\n        if self.satisfies_requirement?(dep) then\n          sats = []\n          find_all_satisfiers(dep) do |sat|\n            sats << sat\n          end\n          out << [gem, dep, sats]\n        end\n      end\n    end\n    out\n  end\n\n  def to_s # :nodoc:\n    \"#<Gem::Specification name=#{@name} version=#{@version}>\"\n  end\n\n  def pretty_print(q) # :nodoc:\n    q.group 2, 'Gem::Specification.new do |s|', 'end' do\n      q.breakable\n\n      attributes = @@attributes.sort_by { |attr_name,| attr_name.to_s }\n\n      attributes.each do |attr_name, default|\n        current_value = self.send attr_name\n        if current_value != default or\n           self.class.required_attribute? attr_name then\n\n          q.text \"s.#{attr_name} = \"\n\n          if attr_name == :date then\n            current_value = current_value.utc\n\n            q.text \"Time.utc(#{current_value.year}, #{current_value.month}, #{current_value.day})\"\n          else\n            q.pp current_value\n          end\n\n          q.breakable\n        end\n      end\n    end\n  end\n\n  ##\n  # Adds a dependency on gem +dependency+ with type +type+ that requires\n  # +requirements+.  Valid types are currently <tt>:runtime</tt> and\n  # <tt>:development</tt>.\n\n  def add_dependency_with_type(dependency, type, *requirements)\n    requirements = if requirements.empty? then\n                     Gem::Requirement.default\n                   else\n                     requirements.flatten\n                   end\n\n    unless dependency.respond_to?(:name) &&\n      dependency.respond_to?(:version_requirements)\n\n      dependency = Gem::Dependency.new(dependency, requirements, type)\n    end\n\n    dependencies << dependency\n  end\n\n  private :add_dependency_with_type\n\n  ##\n  # Finds all gems that satisfy +dep+\n\n  def find_all_satisfiers(dep)\n    Gem.source_index.each do |_, gem|\n      yield gem if gem.satisfies_requirement? dep\n    end\n  end\n\n  private :find_all_satisfiers\n\n  ##\n  # Return a string containing a Ruby code representation of the given\n  # object.\n\n  def ruby_code(obj)\n    case obj\n    when String            then '%q{' + obj + '}'\n    when Array             then obj.inspect\n    when Gem::Version      then obj.to_s.inspect\n    when Date              then '%q{' + obj.strftime('%Y-%m-%d') + '}'\n    when Time              then '%q{' + obj.strftime('%Y-%m-%d') + '}'\n    when Numeric           then obj.inspect\n    when true, false, nil  then obj.inspect\n    when Gem::Platform     then \"Gem::Platform.new(#{obj.to_a.inspect})\"\n    when Gem::Requirement  then \"Gem::Requirement.new(#{obj.to_s.inspect})\"\n    else raise Gem::Exception, \"ruby_code case not handled: #{obj.class}\"\n    end\n  end\n\n  private :ruby_code\n\n  # :section: Required gemspec attributes\n\n  ##\n  # :attr_accessor: rubygems_version\n  #\n  # The version of RubyGems used to create this gem\n\n  required_attribute :rubygems_version, Gem::RubyGemsVersion\n\n  ##\n  # :attr_accessor: specification_version\n  #\n  # The Gem::Specification version of this gemspec\n\n  required_attribute :specification_version, CURRENT_SPECIFICATION_VERSION\n\n  ##\n  # :attr_accessor: name\n  #\n  # This gem's name\n\n  required_attribute :name\n\n  ##\n  # :attr_accessor: version\n  #\n  # This gem's version\n\n  required_attribute :version\n\n  ##\n  # :attr_accessor: date\n  #\n  # The date this gem was created\n\n  required_attribute :date, TODAY\n\n  ##\n  # :attr_accessor: summary\n  #\n  # A short summary of this gem's description.  Displayed in `gem list -d`.\n\n  required_attribute :summary\n\n  ##\n  # :attr_ac"..., 4096) = 4096
read(3, "  required_attribute :require_paths, ['lib']\n\n  # :section: Optional gemspec attributes\n\n  ##\n  # :attr_accessor: email\n  #\n  # A contact email for this gem\n\n  attribute :email\n\n  ##\n  # :attr_accessor: homepage\n  #\n  # The URL of this gem's home page\n\n  attribute :homepage\n\n  ##\n  # :attr_accessor: rubyforge_project\n  #\n  # The rubyforge project this gem lives under.  i.e. RubyGems'\n  # rubyforge_project is \"rubygems\".\n\n  attribute :rubyforge_project\n\n  ##\n  # :attr_accessor: description\n  #\n  # A long description of this gem\n\n  attribute :description\n\n  ##\n  # :attr_accessor: autorequire\n  #\n  # Autorequire was used by old RubyGems to automatically require a file.\n  # It no longer is supported.\n\n  attribute :autorequire\n\n  ##\n  # :attr_accessor: default_executable\n  #\n  # The default executable for this gem.\n\n  attribute :default_executable\n\n  ##\n  # :attr_accessor: bindir\n  #\n  # The path in the gem for executable scripts\n\n  attribute :bindir, 'bin'\n\n  ##\n  # :attr_accessor: has_rdoc\n  #\n  # Deprecated and ignored, defaults to true.\n  #\n  # Formerly used to indicate this gem was RDoc-capable.\n\n  attribute :has_rdoc, true\n\n  ##\n  # True if this gem supports RDoc\n\n  alias :has_rdoc? :has_rdoc\n\n  ##\n  # :attr_accessor: required_ruby_version\n  #\n  # The ruby of version required by this gem\n\n  attribute :required_ruby_version, Gem::Requirement.default\n\n  ##\n  # :attr_accessor: required_rubygems_version\n  #\n  # The RubyGems version required by this gem\n\n  attribute :required_rubygems_version, Gem::Requirement.default\n\n  ##\n  # :attr_accessor: platform\n  #\n  # The platform this gem runs on.  See Gem::Platform for details.\n\n  attribute :platform, Gem::Platform::RUBY\n\n  ##\n  # :attr_accessor: signing_key\n  #\n  # The key used to sign this gem.  See Gem::Security for details.\n\n  attribute :signing_key, nil\n\n  ##\n  # :attr_accessor: cert_chain\n  #\n  # The certificate chain used to sign this gem.  See Gem::Security for\n  # details.\n\n  attribute :cert_chain, []\n\n  ##\n  # :attr_accessor: post_install_message\n  #\n  # A message that gets displayed after the gem is installed\n\n  attribute :post_install_message, nil\n\n  ##\n  # :attr_accessor: authors\n  #\n  # The list of authors who wrote this gem\n\n  array_attribute :authors\n\n  ##\n  # :attr_accessor: licenses\n  #\n  # The license(s) for the library.  Each license must be a short name, no\n  # more than 64 characters.\n\n  array_attribute :licenses\n\n  ##\n  # :attr_accessor: files\n  #\n  # Files included in this gem.  You cannot append to this accessor, you must\n  # assign to it.\n  #\n  # Only add files you can require to this list, not directories, etc.\n  #\n  # Directories are automatically stripped from this list when building a gem,\n  # other non-files cause an error.\n\n  array_attribute :files\n\n  ##\n  # :attr_accessor: test_files\n  #\n  # Test files included in this gem.  You cannot append to this accessor, you\n  # must assign to it.\n\n  array_attribute :test_files\n\n  ##\n  # :attr_accessor: rdoc_options\n  #\n  # An ARGV-style array of options to RDoc\n\n  array_attribute :rdoc_options\n\n  ##\n  # :attr_accessor: extra_rdoc_files\n  #\n  # Extra files to add to RDoc\n\n  array_attribute :extra_rdoc_files\n\n  ##\n  # :attr_accessor: executables\n  #\n  # Executables included in the gem\n\n  array_attribute :executables\n\n  ##\n  # :attr_accessor: extensions\n  #\n  # Extensions to build when installing the gem.  See\n  # Gem::Installer#build_extensions for valid values.\n\n  array_attribute :extensions\n\n  ##\n  # :attr_accessor: requirements\n  #\n  # An array or things required by this gem.  Not used by anything\n  # presently.\n\n  array_attribute :requirements\n\n  ##\n  # :attr_reader: dependencies\n  #\n  # A list of Gem::Dependency objects this gem depends on.\n\n  array_attribute :dependencies\n\n  read_only :dependencies\n\n  # :section: Aliased gemspec attributes\n\n  ##\n  # Singular accessor for #executables\n\n  attribute_alias_singular :executable, :executables\n\n  ##\n  # Singular accessor for #authors\n\n  attribute_alias_singular :auth"..., 4096) = 4096
read(3, "censes\n\n  ##\n  # Singular accessor for #require_paths\n\n  attribute_alias_singular :require_path, :require_paths\n\n  ##\n  # Singular accessor for #test_files\n\n  attribute_alias_singular :test_file, :test_files\n\n  ##\n  # has_rdoc is now ignored\n\n  overwrite_accessor :has_rdoc do\n    true\n  end\n\n  ##\n  # has_rdoc is now ignored\n\n  overwrite_accessor :has_rdoc= do |value|\n    @has_rdoc = true\n  end\n\n  overwrite_accessor :version= do |version|\n    @version = Gem::Version.create(version)\n    self.required_rubygems_version = '> 1.3.1' if @version.prerelease?\n    return @version\n  end\n\n  overwrite_accessor :platform do\n    @new_platform\n  end\n\n  overwrite_accessor :platform= do |platform|\n    if @original_platform.nil? or\n       @original_platform == Gem::Platform::RUBY then\n      @original_platform = platform\n    end\n\n    case platform\n    when Gem::Platform::CURRENT then\n      @new_platform = Gem::Platform.local\n      @original_platform = @new_platform.to_s\n\n    when Gem::Platform then\n      @new_platform = platform\n\n    # legacy constants\n    when nil, Gem::Platform::RUBY then\n      @new_platform = Gem::Platform::RUBY\n    when 'mswin32' then # was Gem::Platform::WIN32\n      @new_platform = Gem::Platform.new 'x86-mswin32'\n    when 'i586-linux' then # was Gem::Platform::LINUX_586\n      @new_platform = Gem::Platform.new 'x86-linux'\n    when 'powerpc-darwin' then # was Gem::Platform::DARWIN\n      @new_platform = Gem::Platform.new 'ppc-darwin'\n    else\n      @new_platform = Gem::Platform.new platform\n    end\n\n    @platform = @new_platform.to_s\n\n    @new_platform\n  end\n\n  overwrite_accessor :required_ruby_version= do |value|\n    @required_ruby_version = Gem::Requirement.create(value)\n  end\n\n  overwrite_accessor :required_rubygems_version= do |value|\n    @required_rubygems_version = Gem::Requirement.create(value)\n  end\n\n  overwrite_accessor :date= do |date|\n    # We want to end up with a Time object with one-day resolution.\n    # This is the cleanest, most-readable, faster-than-using-Date\n    # way to do it.\n    case date\n    when String then\n      @date = if /\\A(\\d{4})-(\\d{2})-(\\d{2})\\Z/ =~ date then\n                Time.local($1.to_i, $2.to_i, $3.to_i)\n              else\n                require 'time'\n                Time.parse date\n              end\n    when Time then\n      @date = Time.local(date.year, date.month, date.day)\n    when Date then\n      @date = Time.local(date.year, date.month, date.day)\n    else\n      @date = TODAY\n    end\n  end\n\n  overwrite_accessor :date do\n    self.date = nil if @date.nil?  # HACK Sets the default value for date\n    @date\n  end\n\n  overwrite_accessor :summary= do |str|\n    @summary = if str then\n                 str.strip.\n                 gsub(/(\\w-)\\n[ \\t]*(\\w)/, '\\1\\2').\n                 gsub(/\\n[ \\t]*/, \" \")\n               end\n  end\n\n  overwrite_accessor :description= do |str|\n    @description = str.to_s\n  end\n\n  overwrite_accessor :default_executable do\n    begin\n      if defined?(@default_executable) and @default_executable\n        result = @default_executable\n      elsif @executables and @executables.size == 1\n        result = Array(@executables).first\n      else\n        result = nil\n      end\n      result\n    rescue\n      nil\n    end\n  end\n\n  overwrite_accessor :test_files do\n    # Handle the possibility that we have @test_suite_file but not\n    # @test_files.  This will happen when an old gem is loaded via\n    # YAML.\n    if defined? @test_suite_file then\n      @test_files = [@test_suite_file].flatten\n      @test_suite_file = nil\n    end\n    if defined?(@test_files) and @test_files then\n      @test_files\n    else\n      @test_files = []\n    end\n  end\n\n  overwrite_accessor :files do\n    result = []\n    result.push(*@files) if defined?(@files)\n    result.push(*@test_files) if defined?(@test_files)\n    result.push(*(add_bindir(@executables)))\n    result.push(*@extra_rdoc_files) if defined?(@extra_rdoc_files)\n    result.push(*@extensions) if defined?(@extensions)\n    result.uniq.compact\n  end\n\nend\n\n", 4096) = 3999
brk(0x9e9f000)                          = 0x9e9f000
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/version.rb", {st_mode=S_IFREG|0644, st_size=5617, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/version.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5617, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/requirement.rb", {st_mode=S_IFREG|0644, st_size=3970, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/requirement.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3970, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/platform.rb", {st_mode=S_IFREG|0644, st_size=5280, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/platform.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5280, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/platform.rb", {st_mode=S_IFREG|0644, st_size=5280, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/platform.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5280, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/platform.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5280, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/platform.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/platform.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5280, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "##\n# Available list of platforms for targeting Gem installations.\n\nclass Gem::Platform\n\n  @local = nil\n\n  attr_accessor :cpu\n\n  attr_accessor :os\n\n  attr_accessor :version\n\n  def self.local\n    arch = Gem::ConfigMap[:arch]\n    arch = \"#{arch}_60\" if arch =~ /mswin32$/\n    @local ||= new(arch)\n  end\n\n  def self.match(platform)\n    Gem.platforms.any? do |local_platform|\n      platform.nil? or local_platform == platform or\n        (local_platform != Gem::Platform::RUBY and local_platform =~ platform)\n    end\n  end\n\n  def self.new(arch) # :nodoc:\n    case arch\n    when Gem::Platform::CURRENT then\n      Gem::Platform.local\n    when Gem::Platform::RUBY, nil, '' then\n      Gem::Platform::RUBY\n    else\n      super\n    end\n  end\n\n  def initialize(arch)\n    case arch\n    when Array then\n      @cpu, @os, @version = arch\n    when String then\n      arch = arch.split '-'\n\n      if arch.length > 2 and arch.last !~ /\\d/ then # reassemble x86-linux-gnu\n        extra = arch.pop\n        arch.last << \"-#{extra}\"\n      end\n\n      cpu = arch.shift\n\n      @cpu = case cpu\n             when /i\\d86/ then 'x86'\n             else cpu\n             end\n\n      if arch.length == 2 and arch.last =~ /^\\d+(\\.\\d+)?$/ then # for command-line\n        @os, @version = arch\n        return\n      end\n\n      os, = arch\n      @cpu, os = nil, cpu if os.nil? # legacy jruby\n\n      @os, @version = case os\n                      when /aix(\\d+)/ then             [ 'aix',       $1  ]\n                      when /cygwin/ then               [ 'cygwin',    nil ]\n                      when /darwin(\\d+)?/ then         [ 'darwin',    $1  ]\n                      when /freebsd(\\d+)/ then         [ 'freebsd',   $1  ]\n                      when /hpux(\\d+)/ then            [ 'hpux',      $1  ]\n                      when /^java$/, /^jruby$/ then    [ 'java',      nil ]\n                      when /^java([\\d.]*)/ then        [ 'java',      $1  ]\n                      when /linux/ then                [ 'linux',     $1  ]\n                      when /mingw32/ then              [ 'mingw32',   nil ]\n                      when /(mswin\\d+)(\\_(\\d+))?/ then\n                        os, version = $1, $3\n                        @cpu = 'x86' if @cpu.nil? and os =~ /32$/\n                        [os, version]\n                      when /netbsdelf/ then            [ 'netbsdelf', nil ]\n                      when /openbsd(\\d+\\.\\d+)/ then    [ 'openbsd',   $1  ]\n                      when /solaris(\\d+\\.\\d+)/ then    [ 'solaris',   $1  ]\n                      # test\n                      when /^(\\w+_platform)(\\d+)/ then [ $1,          $2  ]\n                      else                             [ 'unknown',   nil ]\n                      end\n    when Gem::Platform then\n      @cpu = arch.cpu\n      @os = arch.os\n      @version = arch.version\n    else\n      raise ArgumentError, \"invalid argument #{arch.inspect}\"\n    end\n  end\n\n  def inspect\n    \"#<%s:0x%x @cpu=%p, @os=%p, @version=%p>\" % [self.class, object_id, *to_a]\n  end\n\n  def to_a\n    [@cpu, @os, @version]\n  end\n\n  def to_s\n    to_a.compact.join '-'\n  end\n  \n  def empty?\n    to_s.empty?\n  end\n\n  ##\n  # Is +other+ equal to this platform?  Two platforms are equal if they have\n  # the same CPU, OS and version.\n\n  def ==(other)\n    self.class === other and\n      @cpu == other.cpu and @os == other.os and @version == other.version\n  end\n\n  ##\n  # Does +other+ match this platform?  Two platforms match if they have the\n  # same CPU, or either has a CPU of 'universal', they have the same OS, and\n  # they have the same version, or either has no version.\n\n  def ===(other)\n    return nil unless Gem::Platform === other\n\n    # cpu\n    (@cpu == 'universal' or other.cpu == 'universal' or @cpu == other.cpu) and\n\n    # os\n    @os == other.os and\n\n    # version\n    (@version.nil? or other.version.nil? or @version == other.version)\n  end\n\n  ##\n  # Does +other+ match this platform?  If +other+ is a String it will be\n  # converted to a Gem::Platform first.  See #=== for matching rule"..., 4096) = 4096
read(3, "# This data is from http://gems.rubyforge.org/gems/yaml on 19 Aug 2007\n      other = case other\n              when /^i686-darwin(\\d)/     then ['x86',       'darwin',  $1    ]\n              when /^i\\d86-linux/         then ['x86',       'linux',   nil   ]\n              when 'java', 'jruby'        then [nil,         'java',    nil   ]\n              when /mswin32(\\_(\\d+))?/    then ['x86',       'mswin32', $2    ]\n              when 'powerpc-darwin'       then ['powerpc',   'darwin',  nil   ]\n              when /powerpc-darwin(\\d)/   then ['powerpc',   'darwin',  $1    ]\n              when /sparc-solaris2.8/     then ['sparc',     'solaris', '2.8' ]\n              when /universal-darwin(\\d)/ then ['universal', 'darwin',  $1    ]\n              else                             other\n              end\n\n      other = Gem::Platform.new other\n    else\n      return nil\n    end\n\n    self === other\n  end\n\n  ##\n  # A pure-ruby gem that may use Gem::Specification#extensions to build\n  # binary files.\n\n  RUBY = 'ruby'\n\n  ##\n  # A platform-specific gem that is built for the packaging ruby's platform.\n  # This will be replaced with Gem::Platform::local.\n\n  CURRENT = 'current'\n\nend\n\n", 4096) = 1184
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
gettimeofday({1263334812, 189238}, NULL) = 0
open("/etc/localtime", O_RDONLY)        = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "TZif2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3\0\0\0\3\0\0\0\0\0\0\0r\0\0\0\3\0\0\0\t\25#\353\220\26\23\334\220\27\3\315\220\27\363\276\220\30\343\257\220\31\323\240\220\32\303\221\220\33\274\275\20\34\254\256\20\35\234\237\20\36\214\220\20\37|\201\20 lr\20!\\c\20\"LT\20#<E\20$,6\20%\34'\20&\f\30\20'\5C\220'\3654\220(\345%\220)\325\26\220*\305\7\220+\264\370\220,\244\351\220-\224\332\220.\204\313\220/t\274\2200d\255\2201]\331\0202r\264\0203=\273\0204R\226\0205\35\235\02062x\0206\375\177\0208\33\224\2208\335a\0209\373v\220:\275C\20;\333X\220<\246_\220=\273:\220>\206A\220?\233\34\220@f#\220A\2049\20BF\5\220Cd\33\20D%\347\220EC\375\20F\5\311\220G#\337\20G\356\346\20I\3\301\20I\316\310\20J\343\243\20K\256\252\20L\314\277\220M\216\214\20N\254\241\220Onn\20P\214\203\220QW\212\220Rle\220S7l\220TLG\220U\27N\220V,)\220V\3670\220X\25F\20X\327\22\220Y\365(\20Z\266\364\220[\325\n\20\\\240\21\20]\264\354\20^\177\363\20_\224\316\20`_\325\20a}\352\220b?\267\20c]\314\220d\37\231\20e=\256\220f\10\265\220g\35\220\220g\350\227\220h\375r\220i\310y\220j\335T\220k\250[\220l\306q\20m\210=\220n\246S\20oh\37\220p\2065\20qQ<\20rf\27\20s1\36\20tE\371\20u\21\0\20v/\25\220v\360\342\20x\16\367\220x\320\304\20y\356\331\220z\260\246\20{\316\273\220|\231\302\220}\256\235\220~y\244\220\177\216\177\220\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\1\2\0\0\16\20\0\0\0\0\34 \1\4\0\0\16\20\0\0CET\0CEST\0\0\1\1\0\1\1TZif2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\0\0\0\0s\0\0\0\4\0\0\0\r\377\377\377\377q\324\4\224\0\0\0\0\25#\353\220\0\0\0\0\26\23\334\220\0\0\0\0\27\3\315\220\0\0\0\0\27\363\276\220\0\0\0\0\30\343\257\220\0\0\0\0\31\323\240\220\0\0\0\0\32\303\221\220\0\0\0\0\33\274\275\20\0\0\0\0\34\254\256\20\0\0\0\0\35\234\237\20\0\0\0\0\36\214\220\20\0\0\0\0\37|\201\20\0\0\0\0 lr\20\0\0\0\0!\\c\20\0\0\0\0\"LT\20\0\0\0\0#<E\20\0\0\0\0$,6\20\0\0\0\0%\34'\20\0\0\0\0&\f\30\20\0\0\0\0'\5C\220\0\0\0\0'\3654\220\0\0\0\0(\345%\220\0\0\0\0)\325\26\220\0\0\0\0*\305\7\220\0\0\0\0+\264\370\220\0\0\0\0,\244\351\220\0\0\0\0-\224\332\220\0\0\0\0.\204\313\220\0\0\0\0/t\274\220\0\0\0\0000d\255\220\0\0\0\0001]\331\20\0\0\0\0002r\264\20\0\0\0\0003=\273\20\0\0\0\0004R\226\20\0\0\0\0005\35\235\20\0\0\0\00062x\20\0\0\0\0006\375\177\20\0\0\0\0008\33\224\220\0\0\0\0008\335a\20\0\0\0\0009\373v\220\0\0\0\0:\275C\20\0\0\0\0;\333X\220\0\0\0\0<\246_\220\0\0\0\0=\273:\220\0\0\0\0>\206A\220\0\0\0\0?\233\34\220\0\0\0\0@f#\220\0\0\0\0A\2049\20\0\0\0\0BF\5\220\0\0\0\0Cd\33\20\0\0\0\0D%\347\220\0\0\0\0EC\375\20\0\0\0\0F\5\311\220\0\0\0\0G#\337\20\0\0\0\0G\356\346\20\0\0\0\0I\3\301\20\0\0\0\0I\316\310\20\0\0\0\0J\343\243\20\0\0\0\0K\256\252\20\0\0\0\0L\314\277\220\0\0\0\0M\216\214\20\0\0\0\0N\254\241\220\0\0\0\0Onn\20\0\0\0\0P\214\203\220\0\0\0\0QW\212\220\0\0\0\0Rle\220\0\0\0\0S7l\220\0\0\0\0TLG\220\0\0\0\0U\27N\220\0\0\0\0V,)\220\0\0\0\0V\3670\220\0\0\0\0X\25F\20\0\0\0\0X\327\22\220\0\0\0\0Y\365(\20\0\0\0\0Z\266\364\220\0\0\0\0[\325\n\20\0\0\0\0\\\240\21\20\0\0\0\0]\264\354\20\0\0\0\0^\177\363\20\0\0\0\0_\224\316\20\0\0\0\0`_\325\20\0\0\0\0a}\352\220\0\0\0\0b?\267\20\0\0\0\0c]\314\220\0\0\0\0d\37\231\20\0\0\0\0e=\256\220\0\0\0\0f\10\265\220\0\0\0\0g\35\220\220\0\0\0\0g\350\227\220\0\0\0\0h\375r\220\0\0\0\0i\310y\220\0\0\0\0j\335T\220\0\0\0\0k\250[\220\0\0\0\0l\306q\20\0\0\0\0m\210=\220\0\0\0\0n\246S\20\0\0\0\0oh\37\220\0\0\0\0p\2065\20\0\0\0\0qQ<\20\0\0\0\0rf\27\20\0\0\0\0s1\36\20\0\0\0\0tE\371\20\0\0\0\0u\21\0\20\0\0\0\0v/\25\220\0\0\0\0v\360\342\20\0\0\0\0x\16\367\220\0\0\0\0x\320\304\20\0\0\0\0y\356\331\220\0\0\0\0z\260\246\20\0\0\0\0{\316\273\220\0\0\0\0|\231\302\220\0\0\0\0}\256\235\220\0\0\0\0~y\244\220\0\0\0\0\177\216\177\220\1\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\0\0\10\354\0\0\0\0\16\20\0\4\0\0\34 \1\10\0\0\16\20\0\4LMT\0CET\0CEST\0\0\0\1\1\0\0\1\1\nCET-1CEST,M3.5.0,M10.5.0/3\n", 4096) = 1799
_llseek(3, -28, [1771], SEEK_CUR)       = 0
read(3, "\nCET-1CEST,M3.5.0,M10.5.0/3\n", 4096) = 28
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/platform.rb", {st_mode=S_IFREG|0644, st_size=5280, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/platform.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5280, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/builder.rb", {st_mode=S_IFREG|0644, st_size=2060, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/builder.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2060, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/builder.rb", {st_mode=S_IFREG|0644, st_size=2060, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/builder.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2060, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/builder.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2060, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/builder.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/builder.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2060, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\n##\n# The Builder class processes RubyGem specification files\n# to produce a .gem file.\n\nclass Gem::Builder\n\n  include Gem::UserInteraction\n  ##\n  # Constructs a builder instance for the provided specification\n  #\n  # spec:: [Gem::Specification] The specification instance\n\n  def initialize(spec)\n    require \"yaml\"\n    require \"rubygems/package\"\n    require \"rubygems/security\"\n\n    @spec = spec\n  end\n\n  ##\n  # Builds the gem from the specification.  Returns the name of the file\n  # written.\n\n  def build\n    @spec.mark_version\n    @spec.validate\n    @signer = sign\n    write_package\n    say success\n    @spec.file_name\n  end\n\n  def success\n    <<-EOM\n  Successfully built RubyGem\n  Name: #{@spec.name}\n  Version: #{@spec.version}\n  File: #{@spec.full_name+'.gem'}\nEOM\n  end\n\n  private\n\n  ##\n  # If the signing key was specified, then load the file, and swap to the\n  # public key (TODO: we should probably just omit the signing key in favor of\n  # the signing certificate, but that's for the future, also the signature\n  # algorithm should be configurable)\n\n  def sign\n    signer = nil\n\n    if @spec.respond_to?(:signing_key) and @spec.signing_key then\n      signer = Gem::Security::Signer.new @spec.signing_key, @spec.cert_chain\n      @spec.signing_key = nil\n      @spec.cert_chain = signer.cert_chain.map { |cert| cert.to_s }\n    end\n\n    signer\n  end\n\n  def write_package\n    open @spec.file_name, 'wb' do |gem_io|\n      Gem::Package.open gem_io, 'w', @signer do |pkg|\n        pkg.metadata = @spec.to_yaml\n\n        @spec.files.each do |file|\n          next if File.directory? file\n          next if file == @spec.file_name # Don't add gem onto itself\n\n          stat = File.stat file\n          mode = stat.mode & 0777\n          size = stat.size\n\n          pkg.add_file_simple file, mode, size do |tar_io|\n            tar_io.write open(file, \"rb\") { |f| f.read }\n          end\n        end\n      end\n    end\n  end\nend\n\n", 4096) = 2060
brk(0x9ec0000)                          = 0x9ec0000
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/defaults/operating_system.rb", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/defaults/operating_system.so", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/rubygems/defaults/operating_system.rb", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/rubygems/defaults/operating_system.so", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/rubygems/defaults/operating_system.rb", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/rubygems/defaults/operating_system.so", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/rubygems/defaults/operating_system.rb", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/rubygems/defaults/operating_system.so", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/rubygems/defaults/operating_system.rb", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/rubygems/defaults/operating_system.so", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/rubygems/defaults/operating_system.rb", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/rubygems/defaults/operating_system.so", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/rubygems/defaults/operating_system.rb", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/rubygems/defaults/operating_system.so", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/rubygems/defaults/operating_system.rb", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/rubygems/defaults/operating_system.so", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i486-linux/rubygems/defaults/operating_system.rb", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i486-linux/rubygems/defaults/operating_system.so", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i386-linux/rubygems/defaults/operating_system.rb", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i386-linux/rubygems/defaults/operating_system.so", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("./rubygems/defaults/operating_system.rb", 0xbfe53940) = -1 ENOENT (No such file or directory)
stat64("./rubygems/defaults/operating_system.so", 0xbfe53940) = -1 ENOENT (No such file or directory)
rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/config_file.rb", {st_mode=S_IFREG|0644, st_size=7551, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/config_file.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=7551, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/config_file.rb", {st_mode=S_IFREG|0644, st_size=7551, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/config_file.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=7551, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/config_file.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=7551, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/config_file.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/config_file.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=7551, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\nrequire 'yaml'\n\n# Store the gem command options specified in the configuration file.  The\n# config file object acts much like a hash.\n\nclass Gem::ConfigFile\n\n  DEFAULT_BACKTRACE = false\n  DEFAULT_BENCHMARK = false\n  DEFAULT_BULK_THRESHOLD = 1000\n  DEFAULT_VERBOSITY = true\n  DEFAULT_UPDATE_SOURCES = true\n\n  ##\n  # For Ruby packagers to set configuration defaults.  Set in\n  # rubygems/defaults/operating_system.rb\n\n  OPERATING_SYSTEM_DEFAULTS = {}\n\n  ##\n  # For Ruby implementers to set configuration defaults.  Set in\n  # rubygems/defaults/#{RUBY_ENGINE}.rb\n\n  PLATFORM_DEFAULTS = {}\n\n  system_config_path =\n    begin\n      require 'Win32API'\n\n      CSIDL_COMMON_APPDATA = 0x0023\n      path = 0.chr * 260\n      if RUBY_VERSION > '1.9' then\n        SHGetFolderPath = Win32API.new 'shell32', 'SHGetFolderPath', 'PLPLP',\n                                       'L', :stdcall\n        SHGetFolderPath.call nil, CSIDL_COMMON_APPDATA, nil, 1, path\n      else\n        SHGetFolderPath = Win32API.new 'shell32', 'SHGetFolderPath', 'LLLLP',\n                                       'L'\n        SHGetFolderPath.call 0, CSIDL_COMMON_APPDATA, 0, 1, path\n      end\n\n      path.strip\n    rescue LoadError\n      '/etc'\n    end\n\n  SYSTEM_WIDE_CONFIG_FILE = File.join system_config_path, 'gemrc'\n\n  # List of arguments supplied to the config file object.\n  attr_reader :args\n\n  # Where to look for gems\n  attr_accessor :path\n\n  attr_accessor :home\n\n  # True if we print backtraces on errors.\n  attr_writer :backtrace\n\n  # True if we are benchmarking this run.\n  attr_accessor :benchmark\n\n  # Bulk threshold value.  If the number of missing gems are above\n  # this threshold value, then a bulk download technique is used.\n  attr_accessor :bulk_threshold\n\n  # Verbose level of output:\n  # * false -- No output\n  # * true -- Normal output\n  # * :loud -- Extra output\n  attr_accessor :verbose\n\n  # True if we want to update the SourceInfoCache every time, false otherwise\n  attr_accessor :update_sources\n\n  # Create the config file object.  +args+ is the list of arguments\n  # from the command line.\n  #\n  # The following command line options are handled early here rather\n  # than later at the time most command options are processed.\n  #\n  # * --config-file and --config-file==NAME -- Obviously these need\n  #   to be handled by the ConfigFile object to ensure we get the\n  #   right config file.\n  #\n  # * --backtrace -- Backtrace needs to be turned on early so that\n  #   errors before normal option parsing can be properly handled.\n  #\n  # * --debug -- Enable Ruby level debug messages.  Handled early\n  #   for the same reason as --backtrace.\n  #\n  def initialize(arg_list)\n    @config_file_name = nil\n    need_config_file_name = false\n\n    arg_list = arg_list.map do |arg|\n      if need_config_file_name then\n        @config_file_name = arg\n        need_config_file_name = false\n        nil\n      elsif arg =~ /^--config-file=(.*)/ then\n        @config_file_name = $1\n        nil\n      elsif arg =~ /^--config-file$/ then\n        need_config_file_name = true\n        nil\n      else\n        arg\n      end\n    end.compact\n\n    @backtrace = DEFAULT_BACKTRACE\n    @benchmark = DEFAULT_BENCHMARK\n    @bulk_threshold = DEFAULT_BULK_THRESHOLD\n    @verbose = DEFAULT_VERBOSITY\n    @update_sources = DEFAULT_UPDATE_SOURCES\n\n    operating_system_config = Marshal.load Marshal.dump(OPERATING_SYSTEM_DEFAULTS)\n    platform_config = Marshal.load Marshal.dump(PLATFORM_DEFAULTS)\n    system_config = load_file SYSTEM_WIDE_CONFIG_FILE\n    user_config = load_file config_file_name.dup.untaint\n\n    @hash = operating_system_config.merge platform_config\n    @hash = @hash.merge system_config\n    @hash = @hash.merge user_config\n\n    # HACK these override command-line args, which is bad\n    @backtrace = @hash[:backtrace] if @hash.key? :backtrace\n    @benchmark = @hash[:benchmark] if @hash.key? :be"..., 4096) = 4096
read(3, "es = @hash[:sources] if @hash.key? :sources\n    @verbose = @hash[:verbose] if @hash.key? :verbose\n    @update_sources = @hash[:update_sources] if @hash.key? :update_sources\n    @path = @hash[:gempath] if @hash.key? :gempath\n    @home = @hash[:gemhome] if @hash.key? :gemhome\n\n    handle_arguments arg_list\n  end\n\n  def load_file(filename)\n    begin\n      YAML.load(File.read(filename)) if filename and File.exist?(filename)\n    rescue ArgumentError\n      warn \"Failed to load #{config_file_name}\"\n    rescue Errno::EACCES\n      warn \"Failed to load #{config_file_name} due to permissions problem.\"\n    end or {}\n  end\n\n  # True if the backtrace option has been specified, or debug is on.\n  def backtrace\n    @backtrace or $DEBUG\n  end\n\n  # The name of the configuration file.\n  def config_file_name\n    @config_file_name || Gem.config_file\n  end\n\n  # Delegates to @hash\n  def each(&block)\n    hash = @hash.dup\n    hash.delete :update_sources\n    hash.delete :verbose\n    hash.delete :benchmark\n    hash.delete :backtrace\n    hash.delete :bulk_threshold\n\n    yield :update_sources, @update_sources\n    yield :verbose, @verbose\n    yield :benchmark, @benchmark\n    yield :backtrace, @backtrace\n    yield :bulk_threshold, @bulk_threshold\n\n    yield 'config_file_name', @config_file_name if @config_file_name\n\n    hash.each(&block)\n  end\n\n  # Handle the command arguments.\n  def handle_arguments(arg_list)\n    @args = []\n\n    arg_list.each do |arg|\n      case arg\n      when /^--(backtrace|traceback)$/ then\n        @backtrace = true\n      when /^--bench(mark)?$/ then\n        @benchmark = true\n      when /^--debug$/ then\n        $DEBUG = true\n      else\n        @args << arg\n      end\n    end\n  end\n\n  # Really verbose mode gives you extra output.\n  def really_verbose\n    case verbose\n    when true, false, nil then false\n    else true\n    end\n  end\n\n  # to_yaml only overwrites things you can't override on the command line.\n  def to_yaml # :nodoc:\n    yaml_hash = {}\n    yaml_hash[:backtrace] = @hash.key?(:backtrace) ? @hash[:backtrace] :\n      DEFAULT_BACKTRACE\n    yaml_hash[:benchmark] = @hash.key?(:benchmark) ? @hash[:benchmark] :\n      DEFAULT_BENCHMARK\n    yaml_hash[:bulk_threshold] = @hash.key?(:bulk_threshold) ?\n      @hash[:bulk_threshold] : DEFAULT_BULK_THRESHOLD\n    yaml_hash[:sources] = Gem.sources\n    yaml_hash[:update_sources] = @hash.key?(:update_sources) ?\n      @hash[:update_sources] : DEFAULT_UPDATE_SOURCES\n    yaml_hash[:verbose] = @hash.key?(:verbose) ? @hash[:verbose] :\n      DEFAULT_VERBOSITY\n\n    keys = yaml_hash.keys.map { |key| key.to_s }\n    keys << 'debug'\n    re = Regexp.union(*keys)\n\n    @hash.each do |key, value|\n      key = key.to_s\n      next if key =~ re\n      yaml_hash[key.to_s] = value\n    end\n\n    yaml_hash.to_yaml\n  end\n\n  # Writes out this config file, replacing its source.\n  def write\n    File.open config_file_name, 'w' do |fp|\n      fp.write self.to_yaml\n    end\n  end\n\n  # Return the configuration information for +key+.\n  def [](key)\n    @hash[key.to_s]\n  end\n\n  # Set configuration option +key+ to +value+.\n  def []=(key, value)\n    @hash[key.to_s] = value\n  end\n\n  def ==(other) # :nodoc:\n    self.class === other and\n    @backtrace == other.backtrace and\n    @benchmark == other.benchmark and\n    @bulk_threshold == other.bulk_threshold and\n    @verbose == other.verbose and\n    @update_sources == other.update_sources and\n    @hash == other.hash\n  end\n\n  protected\n\n  attr_reader :hash\n\nend\n\n", 4096) = 3455
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml.rb", 0xbfe531b0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/yaml.so", 0xbfe531b0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml.rb", 0xbfe531b0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml.so", 0xbfe531b0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml.rb", 0xbfe531b0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml.so", 0xbfe531b0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml.rb", 0xbfe531b0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml.so", 0xbfe531b0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml.rb", 0xbfe531b0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml.so", 0xbfe531b0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml.rb", 0xbfe531b0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml.so", 0xbfe531b0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml.rb", 0xbfe531b0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml.so", 0xbfe531b0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml.rb", {st_mode=S_IFREG|0644, st_size=12652, ...}) = 0
open("/usr/lib/ruby/1.8/yaml.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=12652, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml.rb", 0xbfe531c0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml.rb", 0xbfe531c0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml.rb", 0xbfe531c0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml.rb", 0xbfe531c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml.rb", 0xbfe531c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml.rb", 0xbfe531c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml.rb", 0xbfe531c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml.rb", {st_mode=S_IFREG|0644, st_size=12652, ...}) = 0
open("/usr/lib/ruby/1.8/yaml.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=12652, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=12652, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/yaml.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=12652, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "# -*- mode: ruby; ruby-indent-level: 4; tab-width: 4 -*- vim: sw=4 ts=4\n# $Id: yaml.rb 16084 2008-04-19 11:45:39Z knu $\n#\n# = yaml.rb: top-level module with methods for loading and parsing YAML documents\n#\n# Author:: why the lucky stiff\n# \n\nrequire 'stringio'\nrequire 'yaml/error'\nrequire 'yaml/syck'\nrequire 'yaml/tag'\nrequire 'yaml/stream'\nrequire 'yaml/constants'\n\n# == YAML\n#\n# YAML(tm) (rhymes with 'camel') is a\n# straightforward machine parsable data serialization format designed for\n# human readability and interaction with scripting languages such as Perl\n# and Python. YAML is optimized for data serialization, formatted\n# dumping, configuration files, log files, Internet messaging and\n# filtering. This specification describes the YAML information model and\n# serialization format. Together with the Unicode standard for characters, it\n# provides all the information necessary to understand YAML Version 1.0\n# and construct computer programs to process it.\n#                         \n# See http://yaml.org/ for more information.  For a quick tutorial, please\n# visit YAML In Five Minutes (http://yaml.kwiki.org/?YamlInFiveMinutes).\n#                              \n# == About This Library\n#                         \n# The YAML 1.0 specification outlines four stages of YAML loading and dumping.\n# This library honors all four of those stages, although data is really only\n# available to you in three stages.\n#     \n# The four stages are: native, representation, serialization, and presentation.\n#     \n# The native stage refers to data which has been loaded completely into Ruby's\n# own types. (See +YAML::load+.)\n#\n# The representation stage means data which has been composed into\n# +YAML::BaseNode+ objects.  In this stage, the document is available as a\n# tree of node objects.  You can perform YPath queries and transformations\n# at this level.  (See +YAML::parse+.)\n#   \n# The serialization stage happens inside the parser.  The YAML parser used in\n# Ruby is called Syck.  Serialized nodes are available in the extension as\n# SyckNode structs.\n#       \n# The presentation stage is the YAML document itself.  This is accessible\n# to you as a string.  (See +YAML::dump+.)\n#   \n# For more information about the various information models, see Chapter\n# 3 of the YAML 1.0 Specification (http://yaml.org/spec/#id2491269).\n#\n# The YAML module provides quick access to the most common loading (YAML::load)\n# and dumping (YAML::dump) tasks.  This module also provides an API for registering\n# global types (YAML::add_domain_type).\n#\n# == Example\n#\n# A simple round-trip (load and dump) of an object.\n#\n#     require \"yaml\"\n#\n#     test_obj = [\"dogs\", \"cats\", \"badgers\"]\n#\n#     yaml_obj = YAML::dump( test_obj )\n#                         # -> ---\n#                              - dogs\n#                              - cats\n#                              - badgers\n#     ruby_obj = YAML::load( yaml_obj )\n#                         # => [\"dogs\", \"cats\", \"badgers\"]\n#     ruby_obj == test_obj\n#                         # => true\n#\n# To register your custom types with the global resolver, use +add_domain_type+.\n#\n#     YAML::add_domain_type( \"your-site.com,2004\", \"widget\" ) do |type, val|\n#         Widget.new( val )\n#     end\n#\nmodule YAML\n\n    Resolver = YAML::Syck::Resolver\n    DefaultResolver = YAML::Syck::DefaultResolver\n    DefaultResolver.use_types_at( @@tagged_classes )\n    GenericResolver = YAML::Syck::GenericResolver\n    Parser = YAML::Syck::Parser\n    Emitter = YAML::Syck::Emitter\n\n    # Returns a new default parser\n    def YAML.parser; Parser.new.set_resolver( YAML.resolver ); end\n    # Returns a new generic parser\n    def YAML.generic_parser; Parser.new.set_resolver( GenericResolver ); end\n    # Returns the default resolver\n    def YAML.resolver; DefaultResolver; end\n    # Returns a new default emitter\n    def YAML.emitter; Emitter.new.set_resolver( YAML.resolver ); end\n\n\t#\n\t# Converts _obj_ to YAML and writes the YAML result to _io_.\n    #     \n    #   File.open("..., 4096) = 4096
read(3, "#   end\n    #\n    # If no _io_ is provided, a string containing the dumped YAML\n    # is returned.\n\t#\n    #   YAML.dump( :locked )\n    #      #=> \"--- :locked\"\n    #\n\tdef YAML.dump( obj, io = nil )\n        obj.to_yaml( io || io2 = StringIO.new )\n        io || ( io2.rewind; io2.read )\n\tend\n\n\t#\n\t# Load a document from the current _io_ stream.\n\t#\n    #   File.open( 'animals.yaml' ) { |yf| YAML::load( yf ) }\n    #      #=> ['badger', 'elephant', 'tiger']\n    #\n    # Can also load from a string.\n    #\n    #   YAML.load( \"--- :locked\" )\n    #      #=> :locked\n    #\n\tdef YAML.load( io )\n\t\typ = parser.load( io )\n\tend\n\n    #\n    # Load a document from the file located at _filepath_.\n    #\n    #   YAML.load_file( 'animals.yaml' )\n    #      #=> ['badger', 'elephant', 'tiger']\n    #\n    def YAML.load_file( filepath )\n        File.open( filepath ) do |f|\n            load( f )\n        end\n    end\n\n\t#\n\t# Parse the first document from the current _io_ stream\n\t#\n    #   File.open( 'animals.yaml' ) { |yf| YAML::load( yf ) }\n    #      #=> #<YAML::Syck::Node:0x82ccce0\n    #           @kind=:seq,\n    #           @value=\n    #            [#<YAML::Syck::Node:0x82ccd94\n    #              @kind=:scalar,\n    #              @type_id=\"str\",\n    #              @value=\"badger\">,\n    #             #<YAML::Syck::Node:0x82ccd58\n    #              @kind=:scalar,\n    #              @type_id=\"str\",\n    #              @value=\"elephant\">,\n    #             #<YAML::Syck::Node:0x82ccd1c\n    #              @kind=:scalar,\n    #              @type_id=\"str\",\n    #              @value=\"tiger\">]>\n    #\n    # Can also load from a string.\n    #\n    #   YAML.parse( \"--- :locked\" )\n    #      #=> #<YAML::Syck::Node:0x82edddc \n    #            @type_id=\"tag:ruby.yaml.org,2002:sym\", \n    #            @value=\":locked\", @kind=:scalar>\n    #\n\tdef YAML.parse( io )\n\t\typ = generic_parser.load( io )\n\tend\n\n    #\n    # Parse a document from the file located at _filepath_.\n    #\n    #   YAML.parse_file( 'animals.yaml' )\n    #      #=> #<YAML::Syck::Node:0x82ccce0\n    #           @kind=:seq,\n    #           @value=\n    #            [#<YAML::Syck::Node:0x82ccd94\n    #              @kind=:scalar,\n    #              @type_id=\"str\",\n    #              @value=\"badger\">,\n    #             #<YAML::Syck::Node:0x82ccd58\n    #              @kind=:scalar,\n    #              @type_id=\"str\",\n    #              @value=\"elephant\">,\n    #             #<YAML::Syck::Node:0x82ccd1c\n    #              @kind=:scalar,\n    #              @type_id=\"str\",\n    #              @value=\"tiger\">]>\n    #\n    def YAML.parse_file( filepath )\n        File.open( filepath ) do |f|\n            parse( f )\n        end\n    end\n\n\t#\n\t# Calls _block_ with each consecutive document in the YAML\n    # stream contained in _io_.\n    #\n    #   File.open( 'many-docs.yaml' ) do |yf|\n    #     YAML.each_document( yf ) do |ydoc|\n    #       ## ydoc contains the single object\n    #       ## from the YAML document\n    #     end\n    #   end\n\t#\n\tdef YAML.each_document( io, &block )\n\t\typ = parser.load_documents( io, &block )\n    end\n\n\t#\n\t# Calls _block_ with each consecutive document in the YAML\n    # stream contained in _io_.\n    #\n    #   File.open( 'many-docs.yaml' ) do |yf|\n    #     YAML.load_documents( yf ) do |ydoc|\n    #       ## ydoc contains the single object\n    #       ## from the YAML document\n    #     end\n    #   end\n\t#\n\tdef YAML.load_documents( io, &doc_proc )\n\t\tYAML.each_document( io, &doc_proc )\n    end\n\n\t#\n\t# Calls _block_ with a tree of +YAML::BaseNodes+, one tree for\n    # each consecutive document in the YAML stream contained in _io_.\n    #\n    #   File.open( 'many-docs.yaml' ) do |yf|\n    #     YAML.each_node( yf ) do |ydoc|\n    #       ## ydoc contains a tree of nodes\n    #       ## from the YAML document\n    #     end\n    #   end\n\t#\n\tdef YAML.each_node( io, &doc_proc )\n\t\typ = generic_parser.load_documents( io, &doc_proc )\n    end\n\n\t#\n\t# Calls _block_ with a tree of +YAML::BaseNodes+, one tree for\n    # each consecutive "..., 4096) = 4096
read(3, "f|\n    #     YAML.parse_documents( yf ) do |ydoc|\n    #       ## ydoc contains a tree of nodes\n    #       ## from the YAML document\n    #     end\n    #   end\n\t#\n\tdef YAML.parse_documents( io, &doc_proc )\n\t\tYAML.each_node( io, &doc_proc )\n    end\n\n\t#\n\t# Loads all documents from the current _io_ stream, \n    # returning a +YAML::Stream+ object containing all\n    # loaded documents.\n\t#\n\tdef YAML.load_stream( io )\n\t\td = nil\n\t\tparser.load_documents( io ) do |doc|\n\t\t\td = YAML::Stream.new if not d\n\t\t\td.add( doc ) \n        end\n\t\treturn d\n\tend\n\n\t#\n    # Returns a YAML stream containing each of the items in +objs+,\n    # each having their own document.\n    #\n    #   YAML.dump_stream( 0, [], {} )\n    #     #=> --- 0\n    #         --- []\n    #         --- {}\n    #\n\tdef YAML.dump_stream( *objs )\n\t\td = YAML::Stream.new\n        objs.each do |doc|\n\t\t\td.add( doc ) \n        end\n        d.emit\n\tend\n\n\t#\n\t# Add a global handler for a YAML domain type.\n\t#\n\tdef YAML.add_domain_type( domain, type_tag, &transfer_proc )\n        resolver.add_type( \"tag:#{ domain }:#{ type_tag }\", transfer_proc )\n\tend\n\n\t#\n\t# Add a transfer method for a builtin type\n\t#\n\tdef YAML.add_builtin_type( type_tag, &transfer_proc )\n\t    resolver.add_type( \"tag:yaml.org,2002:#{ type_tag }\", transfer_proc )\n\tend\n\n\t#\n\t# Add a transfer method for a builtin type\n\t#\n\tdef YAML.add_ruby_type( type_tag, &transfer_proc )\n\t    resolver.add_type( \"tag:ruby.yaml.org,2002:#{ type_tag }\", transfer_proc )\n\tend\n\n\t#\n\t# Add a private document type\n\t#\n\tdef YAML.add_private_type( type_re, &transfer_proc )\n\t    resolver.add_type( \"x-private:\" + type_re, transfer_proc )\n\tend\n\n    #\n    # Detect typing of a string\n    #\n    def YAML.detect_implicit( val )\n        resolver.detect_implicit( val )\n    end\n\n    #\n    # Convert a type_id to a taguri\n    #\n    def YAML.tagurize( val )\n        resolver.tagurize( val )\n    end\n\n    #\n    # Apply a transfer method to a Ruby object\n    #\n    def YAML.transfer( type_id, obj )\n        resolver.transfer( YAML.tagurize( type_id ), obj )\n    end\n\n\t#\n\t# Apply any implicit a node may qualify for\n\t#\n\tdef YAML.try_implicit( obj )\n\t\tYAML.transfer( YAML.detect_implicit( obj ), obj )\n\tend\n\n    #\n    # Method to extract colon-seperated type and class, returning\n    # the type and the constant of the class\n    #\n    def YAML.read_type_class( type, obj_class )\n        scheme, domain, type, tclass = type.split( ':', 4 )\n        tclass.split( \"::\" ).each { |c| obj_class = obj_class.const_get( c ) } if tclass\n        return [ type, obj_class ]\n    end\n\n    #\n    # Allocate blank object\n    #\n    def YAML.object_maker( obj_class, val )\n        if Hash === val\n            o = obj_class.allocate\n            val.each_pair { |k,v|\n                o.instance_variable_set(\"@#{k}\", v)\n            }\n            o\n        else\n            raise YAML::Error, \"Invalid object explicitly tagged !ruby/Object: \" + val.inspect\n        end\n    end\n\n\t#\n\t# Allocate an Emitter if needed\n\t#\n\tdef YAML.quick_emit( oid, opts = {}, &e )\n        out = \n            if opts.is_a? YAML::Emitter\n                opts\n            else\n                emitter.reset( opts )\n            end\n        oid =\n            case oid when Fixnum, NilClass; oid\n            else oid = \"#{oid.object_id}-#{oid.hash}\"\n            end\n        out.emit( oid, &e )\n\tend\n\t\nend\n\nrequire 'yaml/rubytypes'\nrequire 'yaml/types'\n\nmodule Kernel\n    #\n    # ryan:: You know how Kernel.p is a really convenient way to dump ruby\n    #        structures?  The only downside is that it's not as legible as\n    #        YAML.\n    #\n    # _why:: (listening)\n    #\n    # ryan:: I know you don't want to urinate all over your users' namespaces.\n    #        But, on the other hand, convenience of dumping for debugging is,\n    #        IMO, a big YAML use case.\n    #\n    # _why:: Go nuts!  Have a pony parade!\n    #\n    # ryan:: Either way, I certainly will have a pony parade.\n    #\n\n    # Prints any supplied _objects_ out in YAML.  Intended as\n    # a variat"..., 4096) = 4096
read(3, "#   y s\n    #\n    # _produces:_\n    #\n    #   --- !ruby/struct:S \n    #   name: dave\n    #   state: TX\n    #\n    def y( object, *objects )\n        objects.unshift object\n        puts( if objects.length == 1\n                  YAML::dump( *objects )\n              else\n                  YAML::dump_stream( *objects )\n              end )\n    end\n    private :y\nend\n\n\n", 4096) = 364
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/stringio.rb", 0xbfe52640) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/stringio.so", 0xbfe52640) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/stringio.rb", 0xbfe52640) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/stringio.so", 0xbfe52640) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/stringio.rb", 0xbfe52640) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/stringio.so", 0xbfe52640) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/stringio.rb", 0xbfe52640) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/stringio.so", 0xbfe52640) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/stringio.rb", 0xbfe52640) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/stringio.so", 0xbfe52640) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/stringio.rb", 0xbfe52640) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/stringio.so", 0xbfe52640) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/stringio.rb", 0xbfe52640) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/stringio.so", 0xbfe52640) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/stringio.rb", 0xbfe52640) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/stringio.so", 0xbfe52640) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i486-linux/stringio.rb", 0xbfe52640) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i486-linux/stringio.so", {st_mode=S_IFREG|0644, st_size=17848, ...}) = 0
open("/usr/lib/ruby/1.8/i486-linux/stringio.so", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=17848, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/stringio.so", 0xbfe52650) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/stringio.so", 0xbfe52650) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/stringio.so", 0xbfe52650) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/stringio.so", 0xbfe52650) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/stringio.so", 0xbfe52650) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/stringio.so", 0xbfe52650) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/stringio.so", 0xbfe52650) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/stringio.so", 0xbfe52650) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i486-linux/stringio.so", {st_mode=S_IFREG|0644, st_size=17848, ...}) = 0
open("/usr/lib/ruby/1.8/i486-linux/stringio.so", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=17848, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/i486-linux/stringio.so", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\300\22\0\0004\0\0\0\250A\0\0\0\0\0\0004\0 \0\6\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\30<\0\0\30<\0\0\5\0\0\0\0\20\0\0\1\0\0\0\230>\0\0\230N\0\0\230N\0\0000\2\0\0008\2\0\0\6\0\0\0\0\20\0\0\2\0\0\0\254>\0\0\254N\0\0\254N\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0\364\0\0\0\364\0\0\0\364\0\0\0$\0\0\0$\0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\230>\0\0\230N\0\0\230N\0\0h\1\0\0h\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\223\27\25\267\304\ry\2\340\260\241A\246\215<$\210\226\206$C\0\0\0I\0\0\0\0\0\0\0\n\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\35\0\0\0004\0\0\0\21\0\0\0E\0\0\0\0\0\0\0\0\0\0\0\24\0\0\0\0\0\0\0%\0\0\0000\0\0\0\0\0\0\0\17\0\0\0 \0\0\0<\0\0\0,\0\0\0008\0\0\0001\0\0\0;\0\0\0A\0\0\0G\0\0\0002\0\0\0\16\0\0\0D\0\0\0\0\0\0\0\0\0\0\0.\0\0\0\25\0\0\0\34\0\0\0=\0\0\0>\0\0\0\26\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0@\0\0\0\0\0\0\0/\0\0\0B\0\0\0\0\0\0\0?\0\0\0\f\0\0\0009\0\0\0F\0\0\0\0\0\0\0\20\0\0\0(\0\0\0\27\0\0\0\36\0\0\0:\0\0\0", 512) = 512
fstat64(3, {st_mode=S_IFREG|0644, st_size=17848, ...}) = 0
mmap2(NULL, 20688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xe1b000
mmap2(0xe1f000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x3) = 0xe1f000
close(3)                                = 0
mprotect(0xe1f000, 4096, PROT_READ)     = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml/error.rb", 0xbfe52620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/yaml/error.so", 0xbfe52620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/error.rb", 0xbfe52620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/error.so", 0xbfe52620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/error.rb", 0xbfe52620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/error.so", 0xbfe52620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/error.rb", 0xbfe52620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/error.so", 0xbfe52620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/error.rb", 0xbfe52620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/error.so", 0xbfe52620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/error.rb", 0xbfe52620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/error.so", 0xbfe52620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/error.rb", 0xbfe52620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/error.so", 0xbfe52620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml/error.rb", {st_mode=S_IFREG|0644, st_size=1069, ...}) = 0
open("/usr/lib/ruby/1.8/yaml/error.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1069, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml/error.rb", 0xbfe52630) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/error.rb", 0xbfe52630) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/error.rb", 0xbfe52630) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/error.rb", 0xbfe52630) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/error.rb", 0xbfe52630) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/error.rb", 0xbfe52630) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/error.rb", 0xbfe52630) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml/error.rb", {st_mode=S_IFREG|0644, st_size=1069, ...}) = 0
open("/usr/lib/ruby/1.8/yaml/error.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1069, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml/error.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1069, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/yaml/error.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml/error.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1069, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "#\n# Error messages and exception class\n#\n\nmodule YAML\n\n\t#\n\t# Error messages\n\t#\n\n\tERROR_NO_HEADER_NODE = \"With UseHeader=false, the node Array or Hash must have elements\"\n\tERROR_NEED_HEADER = \"With UseHeader=false, the node must be an Array or Hash\"\n\tERROR_BAD_EXPLICIT = \"Unsupported explicit transfer: '%s'\"\n    ERROR_MANY_EXPLICIT = \"More than one explicit transfer\"\n\tERROR_MANY_IMPLICIT = \"More than one implicit request\"\n\tERROR_NO_ANCHOR = \"No anchor for alias '%s'\"\n\tERROR_BAD_ANCHOR = \"Invalid anchor: %s\"\n\tERROR_MANY_ANCHOR = \"More than one anchor\"\n\tERROR_ANCHOR_ALIAS = \"Can't define both an anchor and an alias\"\n\tERROR_BAD_ALIAS = \"Invalid alias: %s\"\n\tERROR_MANY_ALIAS = \"More than one alias\"\n\tERROR_ZERO_INDENT = \"Can't use zero as an indentation width\"\n\tERROR_UNSUPPORTED_VERSION = \"This release of YAML.rb does not support YAML version %s\"\n\tERROR_UNSUPPORTED_ENCODING = \"Attempt to use unsupported encoding: %s\"\n\n\t#\n\t# YAML Error classes\n\t#\n    \n\tclass Error < StandardError; end\n\tclass ParseError < Error; end\n    class TypeError < StandardError; end\n\nend\n", 4096) = 1069
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml/syck.rb", 0xbfe52600) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/yaml/syck.so", 0xbfe52600) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/syck.rb", 0xbfe52600) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/syck.so", 0xbfe52600) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/syck.rb", 0xbfe52600) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/syck.so", 0xbfe52600) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/syck.rb", 0xbfe52600) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/syck.so", 0xbfe52600) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/syck.rb", 0xbfe52600) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/syck.so", 0xbfe52600) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/syck.rb", 0xbfe52600) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/syck.so", 0xbfe52600) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/syck.rb", 0xbfe52600) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/syck.so", 0xbfe52600) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml/syck.rb", {st_mode=S_IFREG|0644, st_size=271, ...}) = 0
open("/usr/lib/ruby/1.8/yaml/syck.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=271, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml/syck.rb", 0xbfe52610) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/syck.rb", 0xbfe52610) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/syck.rb", 0xbfe52610) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/syck.rb", 0xbfe52610) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/syck.rb", 0xbfe52610) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/syck.rb", 0xbfe52610) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/syck.rb", 0xbfe52610) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml/syck.rb", {st_mode=S_IFREG|0644, st_size=271, ...}) = 0
open("/usr/lib/ruby/1.8/yaml/syck.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=271, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml/syck.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=271, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/yaml/syck.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml/syck.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=271, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "#\n# YAML::Syck module\n# .. glues syck and yaml.rb together ..\n#\nrequire 'syck'\nrequire 'yaml/basenode'\n\nmodule YAML\n    module Syck\n\n        #\n        # Mixin BaseNode functionality\n        #\n        class Node\n            include YAML::BaseNode\n        end\n\n    end\nend\n", 4096) = 271
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/syck.rb", 0xbfe51a90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/syck.so", 0xbfe51a90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/syck.rb", 0xbfe51a90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/syck.so", 0xbfe51a90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/syck.rb", 0xbfe51a90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/syck.so", 0xbfe51a90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/syck.rb", 0xbfe51a90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/syck.so", 0xbfe51a90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/syck.rb", 0xbfe51a90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/syck.so", 0xbfe51a90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/syck.rb", 0xbfe51a90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/syck.so", 0xbfe51a90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/syck.rb", 0xbfe51a90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/syck.so", 0xbfe51a90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/syck.rb", 0xbfe51a90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/syck.so", 0xbfe51a90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i486-linux/syck.rb", 0xbfe51a90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i486-linux/syck.so", {st_mode=S_IFREG|0644, st_size=104104, ...}) = 0
open("/usr/lib/ruby/1.8/i486-linux/syck.so", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=104104, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/syck.so", 0xbfe51aa0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/syck.so", 0xbfe51aa0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/syck.so", 0xbfe51aa0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/syck.so", 0xbfe51aa0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/syck.so", 0xbfe51aa0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/syck.so", 0xbfe51aa0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/syck.so", 0xbfe51aa0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/syck.so", 0xbfe51aa0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i486-linux/syck.so", {st_mode=S_IFREG|0644, st_size=104104, ...}) = 0
open("/usr/lib/ruby/1.8/i486-linux/syck.so", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=104104, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/i486-linux/syck.so", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\220D\0\0004\0\0\0p\222\1\0\0\0\0\0004\0 \0\6\0(\0\33\0\32\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\270\213\1\0\270\213\1\0\5\0\0\0\0\20\0\0\1\0\0\0\260\214\1\0\260\234\1\0\260\234\1\0\330\4\0\0004\n\0\0\6\0\0\0\0\20\0\0\2\0\0\0\264\215\1\0\264\235\1\0\264\235\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0\364\0\0\0\364\0\0\0\364\0\0\0$\0\0\0$\0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\260\214\1\0\260\234\1\0\260\234\1\0P\3\0\0P\3\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\345g\240\210\324U\232\353\253\224\271\2\301-6\315]\366\33\236\7\1\0\0&\1\0\0\0\0\0\0\24\0\0\0v\0\0\0\323\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\1\0\0\30\1\0\0\0\0\0\0\0\0\0\0_\0\0\0\16\1\0\0+\0\0\0k\0\0\0\0\0\0\0%\1\0\0\0\0\0\0\0\0\0\0I\0\0\0\10\1\0\0?\0\0\0\306\0\0\0\362\0\0\0 \1\0\0\3\1\0\0\300\0\0\0\372\0\0\0B\0\0\0\0\0\0\0\247\0\0\0\0\0\0\0Q\0\0\0 \0\0\0i\0\0\0}\0\0\0f\0\0\0\261\0\0\0\f\0\0\0d\0\0\0\233\0\0\0\203\0\0\0\316\0\0\0\0\0\0\0l\0\0\0\360\0\0\0\264\0\0\0\0\0\0\0\0\0\0\0u\0\0\0\320\0\0\0\344\0\0\0\357\0\0\0\356\0\0\0", 512) = 512
fstat64(3, {st_mode=S_IFREG|0644, st_size=104104, ...}) = 0
mmap2(NULL, 108260, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x115000
mmap2(0x12e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x18) = 0x12e000
close(3)                                = 0
mprotect(0x12e000, 4096, PROT_READ)     = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml/basenode.rb", 0xbfe51a70) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/yaml/basenode.so", 0xbfe51a70) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/basenode.rb", 0xbfe51a70) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/basenode.so", 0xbfe51a70) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/basenode.rb", 0xbfe51a70) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/basenode.so", 0xbfe51a70) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/basenode.rb", 0xbfe51a70) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/basenode.so", 0xbfe51a70) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/basenode.rb", 0xbfe51a70) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/basenode.so", 0xbfe51a70) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/basenode.rb", 0xbfe51a70) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/basenode.so", 0xbfe51a70) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/basenode.rb", 0xbfe51a70) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/basenode.so", 0xbfe51a70) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml/basenode.rb", {st_mode=S_IFREG|0644, st_size=6128, ...}) = 0
open("/usr/lib/ruby/1.8/yaml/basenode.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=6128, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml/basenode.rb", 0xbfe51a80) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/basenode.rb", 0xbfe51a80) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/basenode.rb", 0xbfe51a80) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/basenode.rb", 0xbfe51a80) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/basenode.rb", 0xbfe51a80) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/basenode.rb", 0xbfe51a80) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/basenode.rb", 0xbfe51a80) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml/basenode.rb", {st_mode=S_IFREG|0644, st_size=6128, ...}) = 0
open("/usr/lib/ruby/1.8/yaml/basenode.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=6128, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml/basenode.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=6128, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/yaml/basenode.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml/basenode.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=6128, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "#\n# YAML::BaseNode class\n#\nrequire 'yaml/ypath'\n\nmodule YAML\n\n    #\n    # YAML Generic Model container\n    #\n    module BaseNode\n\n        #\n        # Search for YPath entry and return\n        # qualified nodes.\n        #\n        def select( ypath_str )\n            matches = match_path( ypath_str )\n\n            #\n            # Create a new generic view of the elements selected\n            #\n            if matches\n                result = []\n                matches.each { |m|\n                    result.push m.last\n                }\n                YAML.transfer( 'seq', result )\n            end\n        end\n\n        #\n        # Search for YPath entry and return\n        # transformed nodes.\n        #\n        def select!( ypath_str )\n            matches = match_path( ypath_str )\n\n            #\n            # Create a new generic view of the elements selected\n            #\n            if matches\n                result = []\n                matches.each { |m|\n                    result.push m.last.transform\n                }\n                result\n            end\n        end\n\n        #\n        # Search for YPath entry and return a list of\n        # qualified paths.\n        #\n        def search( ypath_str )\n            matches = match_path( ypath_str )\n\n            if matches\n                matches.collect { |m|\n                    path = []\n                    m.each_index { |i|\n                        path.push m[i] if ( i % 2 ).zero?\n                    }\n                    \"/\" + path.compact.join( \"/\" )\n                }\n            end\n        end\n\n        def at( seg )\n            if Hash === @value\n                self[seg]\n            elsif Array === @value and seg =~ /\\A\\d+\\Z/ and @value[seg.to_i]\n                @value[seg.to_i]\n            end\n        end\n\n        #\n        # YPath search returning a complete depth array\n        #\n        def match_path( ypath_str )\n            depth = 0\n            matches = []\n            YPath.each_path( ypath_str ) do |ypath|\n                seg = match_segment( ypath, 0 )\n                matches += seg if seg\n            end\n            matches.uniq\n        end\n\n        #\n        # Search a node for a single YPath segment\n        #\n        def match_segment( ypath, depth )\n            deep_nodes = []\n            seg = ypath.segments[ depth ]\n            if seg == \"/\"\n                unless String === @value\n                    idx = -1\n                    @value.collect { |v|\n                        idx += 1\n                        if Hash === @value\n                            match_init = [v[0].transform, v[1]]\n                            match_deep = v[1].match_segment( ypath, depth )\n                        else\n                            match_init = [idx, v]\n                            match_deep = v.match_segment( ypath, depth )\n                        end\n                        if match_deep\n                            match_deep.each { |m|\n                                deep_nodes.push( match_init + m )\n                            }\n                        end\n                    }\n                end\n                depth += 1\n                seg = ypath.segments[ depth ]\n            end\n            match_nodes =\n                case seg\n                when \".\"\n                    [[nil, self]]\n                when \"..\"\n                    [[\"..\", nil]]\n                when \"*\"\n                    if @value.is_a? Enumerable\n                        idx = -1\n                        @value.collect { |h|\n                            idx += 1\n                            if Hash === @value\n                                [h[0].transform, h[1]]\n                            else\n                                [idx, h]\n                            end\n                        }\n                    end\n                else\n                    if seg =~ /^\"(.*)\"$/\n                        seg = $1\n                    elsif seg =~ /^'(.*)'$/\n                        seg = $1\n              "..., 4096) = 4096
read(3, "            end\n                end\n            return deep_nodes unless match_nodes\n            pred = ypath.predicates[ depth ]\n            if pred\n                case pred\n                when /^\\.=/\n                    pred = $'   # '\n                    match_nodes.reject! { |n|\n                        n.last.value != pred\n                    }\n                else\n                    match_nodes.reject! { |n|\n                        n.last.at( pred ).nil?\n                    }\n                end\n            end\n            return match_nodes + deep_nodes unless ypath.segments.length > depth + 1\n\n            #puts \"DEPTH: #{depth + 1}\"\n            deep_nodes = []\n            match_nodes.each { |n|\n                if n[1].is_a? BaseNode\n                    match_deep = n[1].match_segment( ypath, depth + 1 )\n                    if match_deep\n                        match_deep.each { |m|\n                            deep_nodes.push( n + m )\n                        }\n                    end\n                else\n                    deep_nodes = []\n                end\n            }\n            deep_nodes = nil if deep_nodes.length == 0\n            deep_nodes\n        end\n\n        #\n        # We want the node to act like as Hash\n        # if it is.\n        #\n        def []( *key )\n            if Hash === @value\n                v = @value.detect { |k,| k.transform == key.first }\n                v[1] if v\n            elsif Array === @value\n                @value.[]( *key )\n            end\n        end\n\n        def children\n            if Hash === @value\n                @value.values.collect { |c| c[1] }\n            elsif Array === @value\n                @value\n            end\n        end\n\n        def children_with_index\n            if Hash === @value\n                @value.keys.collect { |i| [self[i], i] }\n            elsif Array === @value\n                i = -1; @value.collect { |v| i += 1; [v, i] }\n            end\n        end\n\n        def emit\n            transform.to_yaml\n        end\n    end\n\nend\n\n", 4096) = 2032
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml/ypath.rb", 0xbfe50f00) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/yaml/ypath.so", 0xbfe50f00) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/ypath.rb", 0xbfe50f00) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/ypath.so", 0xbfe50f00) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/ypath.rb", 0xbfe50f00) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/ypath.so", 0xbfe50f00) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/ypath.rb", 0xbfe50f00) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/ypath.so", 0xbfe50f00) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/ypath.rb", 0xbfe50f00) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/ypath.so", 0xbfe50f00) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/ypath.rb", 0xbfe50f00) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/ypath.so", 0xbfe50f00) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/ypath.rb", 0xbfe50f00) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/ypath.so", 0xbfe50f00) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml/ypath.rb", {st_mode=S_IFREG|0644, st_size=1328, ...}) = 0
open("/usr/lib/ruby/1.8/yaml/ypath.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1328, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml/ypath.rb", 0xbfe50f10) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/ypath.rb", 0xbfe50f10) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/ypath.rb", 0xbfe50f10) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/ypath.rb", 0xbfe50f10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/ypath.rb", 0xbfe50f10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/ypath.rb", 0xbfe50f10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/ypath.rb", 0xbfe50f10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml/ypath.rb", {st_mode=S_IFREG|0644, st_size=1328, ...}) = 0
open("/usr/lib/ruby/1.8/yaml/ypath.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1328, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml/ypath.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1328, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/yaml/ypath.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml/ypath.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1328, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "#\n# YAML::YPath\n#\n\nmodule YAML\n\n    class YPath\n        attr_accessor :segments, :predicates, :flags\n        def initialize( str )\n            @segments = []\n            @predicates = []\n            @flags = nil\n            while str =~ /^\\/?(\\/|[^\\/\\[]+)(?:\\[([^\\]]+)\\])?/\n                @segments.push $1\n                @predicates.push $2\n                str = $'\n            end\n            unless str.to_s.empty?\n                @segments += str.split( \"/\" )\n            end\n            if @segments.length == 0\n                @segments.push \".\"\n            end\n        end\n        def YPath.each_path( str )\n            #\n            # Find choices\n            #\n            paths = []\n            str = \"(#{ str })\"\n            while str.sub!( /\\(([^()]+)\\)/, \"\\n#{ paths.length }\\n\" )\n                paths.push $1.split( '|' )\n            end\n\n            #\n            # Construct all possible paths\n            #\n            all = [ str ]\n            ( paths.length - 1 ).downto( 0 ) do |i|\n                all = all.collect do |a|\n                    paths[i].collect do |p|\n                        a.gsub( /\\n#{ i }\\n/, p )\n                    end\n                end.flatten.uniq\n            end\n            all.collect do |path|\n                yield YPath.new( path )\n            end\n        end\n    end\n\nend\n", 4096) = 1328
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml/tag.rb", 0xbfe525e0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/yaml/tag.so", 0xbfe525e0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/tag.rb", 0xbfe525e0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/tag.so", 0xbfe525e0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/tag.rb", 0xbfe525e0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/tag.so", 0xbfe525e0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/tag.rb", 0xbfe525e0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/tag.so", 0xbfe525e0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/tag.rb", 0xbfe525e0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/tag.so", 0xbfe525e0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/tag.rb", 0xbfe525e0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/tag.so", 0xbfe525e0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/tag.rb", 0xbfe525e0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/tag.so", 0xbfe525e0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml/tag.rb", {st_mode=S_IFREG|0644, st_size=3151, ...}) = 0
open("/usr/lib/ruby/1.8/yaml/tag.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3151, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml/tag.rb", 0xbfe525f0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/tag.rb", 0xbfe525f0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/tag.rb", 0xbfe525f0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/tag.rb", 0xbfe525f0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/tag.rb", 0xbfe525f0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/tag.rb", 0xbfe525f0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/tag.rb", 0xbfe525f0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml/tag.rb", {st_mode=S_IFREG|0644, st_size=3151, ...}) = 0
open("/usr/lib/ruby/1.8/yaml/tag.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3151, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml/tag.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3151, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/yaml/tag.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml/tag.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3151, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "# -*- mode: ruby; ruby-indent-level: 4; tab-width: 4 -*- vim: sw=4 ts=4\n# $Id: tag.rb 16084 2008-04-19 11:45:39Z knu $\n#\n# = yaml/tag.rb: methods for associating a taguri to a class.\n#\n# Author:: why the lucky stiff\n# \nmodule YAML\n    # A dictionary of taguris which map to\n    # Ruby classes.\n    @@tagged_classes = {}\n    \n    # \n    # Associates a taguri _tag_ with a Ruby class _cls_.  The taguri is used to give types\n    # to classes when loading YAML.  Taguris are of the form:\n    #\n    #   tag:authorityName,date:specific\n    #\n    # The +authorityName+ is a domain name or email address.  The +date+ is the date the type\n    # was issued in YYYY or YYYY-MM or YYYY-MM-DD format.  The +specific+ is a name for\n    # the type being added.\n    # \n    # For example, built-in YAML types have 'yaml.org' as the +authorityName+ and '2002' as the\n    # +date+.  The +specific+ is simply the name of the type:\n    #\n    #  tag:yaml.org,2002:int\n    #  tag:yaml.org,2002:float\n    #  tag:yaml.org,2002:timestamp\n    #\n    # The domain must be owned by you on the +date+ declared.  If you don't own any domains on the\n    # date you declare the type, you can simply use an e-mail address.\n    #\n    #  tag:why@ruby-lang.org,2004:notes/personal\n    #\n    def YAML.tag_class( tag, cls )\n        if @@tagged_classes.has_key? tag\n            warn \"class #{ @@tagged_classes[tag] } held ownership of the #{ tag } tag\"\n        end\n        @@tagged_classes[tag] = cls\n    end\n\n    # Returns the complete dictionary of taguris, paired with classes.  The key for\n    # the dictionary is the full taguri.  The value for each key is the class constant\n    # associated to that taguri.\n    #\n    #  YAML.tagged_classes[\"tag:yaml.org,2002:int\"] => Integer\n    #\n    def YAML.tagged_classes\n        @@tagged_classes\n    end\nend\n\nclass Module\n    # :stopdoc:\n\n    # Adds a taguri _tag_ to a class, used when dumping or loading the class\n    # in YAML.  See YAML::tag_class for detailed information on typing and\n    # taguris.\n    def yaml_as( tag, sc = true )\n        verbose, $VERBOSE = $VERBOSE, nil\n        class_eval <<-\"end;\", __FILE__, __LINE__+1\n            attr_writer :taguri\n            def taguri\n                if respond_to? :to_yaml_type\n                    YAML::tagurize( to_yaml_type[1..-1] )\n                else\n                    return @taguri if defined?(@taguri) and @taguri\n                    tag = #{ tag.dump }\n                    if self.class.yaml_tag_subclasses? and self.class != YAML::tagged_classes[tag]\n                        tag = \"\\#{ tag }:\\#{ self.class.yaml_tag_class_name }\"\n                    end\n                    tag\n                end\n            end\n            def self.yaml_tag_subclasses?; #{ sc ? 'true' : 'false' }; end\n        end;\n        YAML::tag_class tag, self\n    ensure\n        $VERBOSE = verbose\n    end\n    # Transforms the subclass name into a name suitable for display\n    # in a subclassed tag.\n    def yaml_tag_class_name\n        self.name\n    end\n    # Transforms the subclass name found in the tag into a Ruby\n    # constant name.\n    def yaml_tag_read_class( name )\n        name\n    end\nend\n", 4096) = 3151
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml/stream.rb", 0xbfe525c0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/yaml/stream.so", 0xbfe525c0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/stream.rb", 0xbfe525c0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/stream.so", 0xbfe525c0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/stream.rb", 0xbfe525c0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/stream.so", 0xbfe525c0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/stream.rb", 0xbfe525c0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/stream.so", 0xbfe525c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/stream.rb", 0xbfe525c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/stream.so", 0xbfe525c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/stream.rb", 0xbfe525c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/stream.so", 0xbfe525c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/stream.rb", 0xbfe525c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/stream.so", 0xbfe525c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml/stream.rb", {st_mode=S_IFREG|0644, st_size=700, ...}) = 0
open("/usr/lib/ruby/1.8/yaml/stream.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=700, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml/stream.rb", 0xbfe525d0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/stream.rb", 0xbfe525d0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/stream.rb", 0xbfe525d0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/stream.rb", 0xbfe525d0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/stream.rb", 0xbfe525d0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/stream.rb", 0xbfe525d0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/stream.rb", 0xbfe525d0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml/stream.rb", {st_mode=S_IFREG|0644, st_size=700, ...}) = 0
open("/usr/lib/ruby/1.8/yaml/stream.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=700, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml/stream.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=700, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/yaml/stream.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml/stream.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=700, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "module YAML\n\n\t#\n\t# YAML::Stream -- for emitting many documents\n\t#\n\tclass Stream\n\n\t\tattr_accessor :documents, :options\n\n\t\tdef initialize( opts = {} )\n\t\t\t@options = opts\n\t\t\t@documents = []\n\t\tend\n\t\t\n        def []( i )\n            @documents[ i ]\n        end\n\n\t\tdef add( doc )\n\t\t\t@documents << doc\n\t\tend\n\n\t\tdef edit( doc_num, doc )\n\t\t\t@documents[ doc_num ] = doc\n\t\tend\n\n\t\tdef emit( io = nil )\n            # opts = @options.dup\n\t\t\t# opts[:UseHeader] = true if @documents.length > 1\n            out = YAML.emitter\n            out.reset( io || io2 = StringIO.new )\n            @documents.each { |v|\n                v.to_yaml( out )\n            }\n            io || ( io2.rewind; io2.read )\n\t\tend\n\n\tend\n\nend\n", 4096) = 700
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml/constants.rb", 0xbfe525a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/yaml/constants.so", 0xbfe525a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/constants.rb", 0xbfe525a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/constants.so", 0xbfe525a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/constants.rb", 0xbfe525a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/constants.so", 0xbfe525a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/constants.rb", 0xbfe525a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/constants.so", 0xbfe525a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/constants.rb", 0xbfe525a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/constants.so", 0xbfe525a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/constants.rb", 0xbfe525a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/constants.so", 0xbfe525a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/constants.rb", 0xbfe525a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/constants.so", 0xbfe525a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml/constants.rb", {st_mode=S_IFREG|0644, st_size=1186, ...}) = 0
open("/usr/lib/ruby/1.8/yaml/constants.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1186, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml/constants.rb", 0xbfe525b0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/constants.rb", 0xbfe525b0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/constants.rb", 0xbfe525b0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/constants.rb", 0xbfe525b0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/constants.rb", 0xbfe525b0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/constants.rb", 0xbfe525b0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/constants.rb", 0xbfe525b0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml/constants.rb", {st_mode=S_IFREG|0644, st_size=1186, ...}) = 0
open("/usr/lib/ruby/1.8/yaml/constants.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1186, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml/constants.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1186, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/yaml/constants.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml/constants.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1186, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "#\n# Constants used throughout the library\n#\nmodule YAML\n\n\t#\n\t# Constants\n\t#\n\tVERSION = '0.60'\n\tSUPPORTED_YAML_VERSIONS = ['1.0']\n\n\t#\n\t# Parser tokens\n\t#\n\tWORD_CHAR = 'A-Za-z0-9'\n\tPRINTABLE_CHAR = '-_A-Za-z0-9!?/()$\\'\". ' \n\tNOT_PLAIN_CHAR = '\\x7f\\x0-\\x1f\\x80-\\x9f'\n\tESCAPE_CHAR = '[\\\\x00-\\\\x09\\\\x0b-\\\\x1f]'\n\tINDICATOR_CHAR = '*&!|\\\\\\\\^@%{}[]='\n\tSPACE_INDICATORS = '-#:,?'\n\tRESTRICTED_INDICATORS = '#:,}]'\n\tDNS_COMP_RE = \"\\\\w(?:[-\\\\w]*\\\\w)?\"\n\tDNS_NAME_RE = \"(?:(?:#{DNS_COMP_RE}\\\\.)+#{DNS_COMP_RE}|#{DNS_COMP_RE})\"\n\tESCAPES = %w{\\x00   \\x01\t\\x02\t\\x03\t\\x04\t\\x05\t\\x06\t\\a\n\t\t\t     \\x08\t\\t\t\t\\n\t\t\\v\t\t\\f\t\t\\r\t\t\\x0e\t\\x0f\n\t\t\t\t \\x10\t\\x11\t\\x12\t\\x13\t\\x14\t\\x15\t\\x16\t\\x17\n\t\t\t\t \\x18\t\\x19\t\\x1a\t\\e\t\t\\x1c\t\\x1d\t\\x1e\t\\x1f\n\t\t\t    }\n\tUNESCAPES = {\n\t\t\t\t'a' => \"\\x07\", 'b' => \"\\x08\", 't' => \"\\x09\", \n\t\t\t\t'n' => \"\\x0a\", 'v' => \"\\x0b\", 'f' => \"\\x0c\",\n\t\t\t\t'r' => \"\\x0d\", 'e' => \"\\x1b\", '\\\\' => '\\\\',\n\t\t\t    }\n\n\t#\n\t# Default settings\n\t#\n\tDEFAULTS = {\n\t\t:Indent => 2, :UseHeader => false, :UseVersion => false, :Version => '1.0',\n\t\t:SortKeys => false, :AnchorFormat => 'id%03d', :ExplicitTypes => false,\n\t\t:WidthType => 'absolute', :BestWidth => 80,\n\t\t:UseBlock => false, :UseFold => false, :Encoding => :None\n\t}\n\nend\n", 4096) = 1186
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml/rubytypes.rb", 0xbfe52580) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/yaml/rubytypes.so", 0xbfe52580) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/rubytypes.rb", 0xbfe52580) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/rubytypes.so", 0xbfe52580) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/rubytypes.rb", 0xbfe52580) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/rubytypes.so", 0xbfe52580) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/rubytypes.rb", 0xbfe52580) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/rubytypes.so", 0xbfe52580) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/rubytypes.rb", 0xbfe52580) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/rubytypes.so", 0xbfe52580) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/rubytypes.rb", 0xbfe52580) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/rubytypes.so", 0xbfe52580) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/rubytypes.rb", 0xbfe52580) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/rubytypes.so", 0xbfe52580) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml/rubytypes.rb", {st_mode=S_IFREG|0644, st_size=13035, ...}) = 0
open("/usr/lib/ruby/1.8/yaml/rubytypes.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=13035, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml/rubytypes.rb", 0xbfe52590) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/rubytypes.rb", 0xbfe52590) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/rubytypes.rb", 0xbfe52590) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/rubytypes.rb", 0xbfe52590) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/rubytypes.rb", 0xbfe52590) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/rubytypes.rb", 0xbfe52590) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/rubytypes.rb", 0xbfe52590) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml/rubytypes.rb", {st_mode=S_IFREG|0644, st_size=13035, ...}) = 0
open("/usr/lib/ruby/1.8/yaml/rubytypes.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=13035, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml/rubytypes.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=13035, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/yaml/rubytypes.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml/rubytypes.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=13035, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "# -*- mode: ruby; ruby-indent-level: 4; tab-width: 4 -*- vim: sw=4 ts=4\nrequire 'date'\n\nclass Class\n\tdef to_yaml( opts = {} )\n\t\traise TypeError, \"can't dump anonymous class %s\" % self.class\n\tend\nend\n\nclass Object\n    yaml_as \"tag:ruby.yaml.org,2002:object\"\n    def to_yaml_style; end\n    def to_yaml_properties; instance_variables.sort; end\n\tdef to_yaml( opts = {} )\n\t\tYAML::quick_emit( self, opts ) do |out|\n            out.map( taguri, to_yaml_style ) do |map|\n\t\t\t\tto_yaml_properties.each do |m|\n                    map.add( m[1..-1], instance_variable_get( m ) )\n                end\n            end\n        end\n\tend\nend\n\nclass Hash\n    yaml_as \"tag:ruby.yaml.org,2002:hash\"\n    yaml_as \"tag:yaml.org,2002:map\"\n    def yaml_initialize( tag, val )\n        if Array === val\n            update Hash.[]( *val )\t\t# Convert the map to a sequence\n        elsif Hash === val\n            update val\n        else\n            raise YAML::TypeError, \"Invalid map explicitly tagged #{ tag }: \" + val.inspect\n        end\n    end\n\tdef to_yaml( opts = {} )\n\t\tYAML::quick_emit( self, opts ) do |out|\n            out.map( taguri, to_yaml_style ) do |map|\n                each do |k, v|\n                    map.add( k, v )\n                end\n            end\n        end\n\tend\nend\n\nclass Struct\n    yaml_as \"tag:ruby.yaml.org,2002:struct\"\n    def self.yaml_tag_class_name; self.name.gsub( \"Struct::\", \"\" ); end\n    def self.yaml_tag_read_class( name ); \"Struct::#{ name }\"; end\n    def self.yaml_new( klass, tag, val )\n        if Hash === val\n            struct_type = nil\n\n            #\n            # Use existing Struct if it exists\n            #\n            props = {}\n            val.delete_if { |k,v| props[k] = v if k =~ /^@/ }\n            begin\n                struct_name, struct_type = YAML.read_type_class( tag, Struct )\n            rescue NameError\n            end\n            if not struct_type\n                struct_def = [ tag.split( ':', 4 ).last ]\n                struct_type = Struct.new( *struct_def.concat( val.keys.collect { |k| k.intern } ) ) \n            end\n\n            #\n            # Set the Struct properties\n            #\n            st = YAML::object_maker( struct_type, {} )\n            st.members.each do |m|\n                st.send( \"#{m}=\", val[m] )\n            end\n            props.each do |k,v|\n                st.instance_variable_set(k, v)\n            end\n            st\n        else\n            raise YAML::TypeError, \"Invalid Ruby Struct: \" + val.inspect\n        end\n    end\n\tdef to_yaml( opts = {} )\n\t\tYAML::quick_emit( self, opts ) do |out|\n\t\t\t#\n\t\t\t# Basic struct is passed as a YAML map\n\t\t\t#\n            out.map( taguri, to_yaml_style ) do |map|\n\t\t\t\tself.members.each do |m|\n                    map.add( m, self[m] )\n                end\n\t\t\t\tself.to_yaml_properties.each do |m|\n                    map.add( m, instance_variable_get( m ) )\n                end\n            end\n        end\n\tend\nend\n\nclass Array\n    yaml_as \"tag:ruby.yaml.org,2002:array\"\n    yaml_as \"tag:yaml.org,2002:seq\"\n    def yaml_initialize( tag, val ); concat( val.to_a ); end\n\tdef to_yaml( opts = {} )\n\t\tYAML::quick_emit( self, opts ) do |out|\n            out.seq( taguri, to_yaml_style ) do |seq|\n                each do |x|\n                    seq.add( x )\n                end\n            end\n        end\n\tend\nend\n\nclass Exception\n    yaml_as \"tag:ruby.yaml.org,2002:exception\"\n    def Exception.yaml_new( klass, tag, val )\n        o = YAML.object_maker( klass, { 'mesg' => val.delete( 'message' ) } )\n        val.each_pair do |k,v|\n            o.instance_variable_set(\"@#{k}\", v)\n        end\n        o\n    end\n\tdef to_yaml( opts = {} )\n\t\tYAML::quick_emit( self, opts ) do |out|\n            out.map( taguri, to_yaml_style ) do |map|\n                map.add( 'message', message )\n\t\t\t\tto_yaml_properties.each do |m|\n                    map.add( m[1..-1], instance_variable_get( m ) )\n                end\n            end\n        end\n\tend\nend\n\nclass String\n    yaml_as \"tag:ruby.yaml.org,2002:string\"\n   "..., 4096) = 4096
read(3, "\n        to_yaml_style or not to_yaml_properties.empty? or self =~ /\\n.+/\n    end\n    def is_binary_data?\n        ( self.count( \"^ -~\", \"^\\r\\n\" ).fdiv(self.size) > 0.3 || self.index( \"\\x00\" ) ) unless empty?\n    end\n    def String.yaml_new( klass, tag, val )\n        val = val.unpack(\"m\")[0] if tag == \"tag:yaml.org,2002:binary\"\n        val = { 'str' => val } if String === val\n        if Hash === val\n            s = klass.allocate\n            # Thank you, NaHi\n            String.instance_method(:initialize).\n                  bind(s).\n                  call( val.delete( 'str' ) )\n            val.each { |k,v| s.instance_variable_set( k, v ) }\n            s\n        else\n            raise YAML::TypeError, \"Invalid String: \" + val.inspect\n        end\n    end\n\tdef to_yaml( opts = {} )\n\t\tYAML::quick_emit( is_complex_yaml? ? self : nil, opts ) do |out|\n            if is_binary_data?\n                out.scalar( \"tag:yaml.org,2002:binary\", [self].pack(\"m\"), :literal )\n            elsif to_yaml_properties.empty?\n                out.scalar( taguri, self, self =~ /^:/ ? :quote2 : to_yaml_style )\n            else\n                out.map( taguri, to_yaml_style ) do |map|\n                    map.add( 'str', \"#{self}\" )\n                    to_yaml_properties.each do |m|\n                        map.add( m, instance_variable_get( m ) )\n                    end\n                end\n            end\n        end\n\tend\nend\n\nclass Symbol\n    yaml_as \"tag:ruby.yaml.org,2002:symbol\"\n    yaml_as \"tag:ruby.yaml.org,2002:sym\"\n    def Symbol.yaml_new( klass, tag, val )\n        if String === val\n            val = YAML::load( val ) if val =~ /\\A([\"']).*\\1\\z/\n            val.intern\n        else\n            raise YAML::TypeError, \"Invalid Symbol: \" + val.inspect\n        end\n    end\n\tdef to_yaml( opts = {} )\n\t\tYAML::quick_emit( nil, opts ) do |out|\n            out.scalar( \"tag:yaml.org,2002:str\", self.inspect, :plain )\n        end\n\tend\nend\n\nclass Range\n    yaml_as \"tag:ruby.yaml.org,2002:range\"\n    def Range.yaml_new( klass, tag, val )\n        inr = %r'(\\w+|[+-]?\\d+(?:\\.\\d+)?(?:e[+-]\\d+)?|\"(?:[^\\\\\"]|\\\\.)*\")'\n        opts = {}\n        if String === val and val =~ /^#{inr}(\\.{2,3})#{inr}$/o\n            r1, rdots, r2 = $1, $2, $3\n            opts = {\n                'begin' => YAML.load( \"--- #{r1}\" ),\n                'end' => YAML.load( \"--- #{r2}\" ),\n                'excl' => rdots.length == 3\n            }\n            val = {}\n        elsif Hash === val\n            opts['begin'] = val.delete('begin')\n            opts['end'] = val.delete('end')\n            opts['excl'] = val.delete('excl')\n        end\n        if Hash === opts\n            r = YAML::object_maker( klass, {} )\n            # Thank you, NaHi\n            Range.instance_method(:initialize).\n                  bind(r).\n                  call( opts['begin'], opts['end'], opts['excl'] )\n            val.each { |k,v| r.instance_variable_set( k, v ) }\n            r\n        else\n            raise YAML::TypeError, \"Invalid Range: \" + val.inspect\n        end\n    end\n\tdef to_yaml( opts = {} )\n\t\tYAML::quick_emit( self, opts ) do |out|\n            # if self.begin.is_complex_yaml? or self.begin.respond_to? :to_str or\n            #   self.end.is_complex_yaml? or self.end.respond_to? :to_str or\n            #   not to_yaml_properties.empty?\n                out.map( taguri, to_yaml_style ) do |map|\n                    map.add( 'begin', self.begin )\n                    map.add( 'end', self.end )\n                    map.add( 'excl', self.exclude_end? )\n                    to_yaml_properties.each do |m|\n                        map.add( m, instance_variable_get( m ) )\n                    end\n                end\n            # else\n            #     out.scalar( taguri ) do |sc|\n            #         sc.embed( self.begin )\n            #         sc.concat( self.exclude_end? ? \"...\" : \"..\" )\n            #         sc.embed( self.end )\n            #     end\n            # end\n        end\n\tend\nend\n\nclass Regexp\n    yaml_as \"tag:ruby.yaml."..., 4096) = 4096
read(3, " /^\\/(.*)\\/([mix]*)$/\n            val = { 'regexp' => $1, 'mods' => $2 }\n        end\n        if Hash === val\n            mods = nil\n            unless val['mods'].to_s.empty?\n                mods = 0x00\n                mods |= Regexp::EXTENDED if val['mods'].include?( 'x' )\n                mods |= Regexp::IGNORECASE if val['mods'].include?( 'i' )\n                mods |= Regexp::MULTILINE if val['mods'].include?( 'm' )\n            end\n            val.delete( 'mods' )\n            r = YAML::object_maker( klass, {} )\n            Regexp.instance_method(:initialize).\n                  bind(r).\n                  call( val.delete( 'regexp' ), mods )\n            val.each { |k,v| r.instance_variable_set( k, v ) }\n            r\n        else\n            raise YAML::TypeError, \"Invalid Regular expression: \" + val.inspect\n        end\n    end\n\tdef to_yaml( opts = {} )\n\t\tYAML::quick_emit( nil, opts ) do |out|\n            if to_yaml_properties.empty?\n                out.scalar( taguri, self.inspect, :plain )\n            else\n                out.map( taguri, to_yaml_style ) do |map|\n                    src = self.inspect\n                    if src =~ /\\A\\/(.*)\\/([a-z]*)\\Z/\n                        map.add( 'regexp', $1 )\n                        map.add( 'mods', $2 )\n                    else\n\t\t                raise YAML::TypeError, \"Invalid Regular expression: \" + src\n                    end\n                    to_yaml_properties.each do |m|\n                        map.add( m, instance_variable_get( m ) )\n                    end\n                end\n            end\n        end\n\tend\nend\n\nclass Time\n    yaml_as \"tag:ruby.yaml.org,2002:time\"\n    yaml_as \"tag:yaml.org,2002:timestamp\"\n    def Time.yaml_new( klass, tag, val )\n        if Hash === val\n            t = val.delete( 'at' )\n            val.each { |k,v| t.instance_variable_set( k, v ) }\n            t\n        else\n            raise YAML::TypeError, \"Invalid Time: \" + val.inspect\n        end\n    end\n\tdef to_yaml( opts = {} )\n\t\tYAML::quick_emit( self, opts ) do |out|\n            tz = \"Z\"\n            # from the tidy Tobias Peters <t-peters@gmx.de> Thanks!\n            unless self.utc?\n                utc_same_instant = self.dup.utc\n                utc_same_writing = Time.utc(year,month,day,hour,min,sec,usec)\n                difference_to_utc = utc_same_writing - utc_same_instant\n                if (difference_to_utc < 0) \n                    difference_sign = '-'\n                    absolute_difference = -difference_to_utc\n                else\n                    difference_sign = '+'\n                    absolute_difference = difference_to_utc\n                end\n                difference_minutes = (absolute_difference/60).round\n                tz = \"%s%02d:%02d\" % [ difference_sign, difference_minutes / 60, difference_minutes % 60]\n            end\n            standard = self.strftime( \"%Y-%m-%d %H:%M:%S\" )\n            standard += \".%06d\" % [usec] if usec.nonzero?\n            standard += \" %s\" % [tz]\n            if to_yaml_properties.empty?\n                out.scalar( taguri, standard, :plain )\n            else\n                out.map( taguri, to_yaml_style ) do |map|\n                    map.add( 'at', standard )\n                    to_yaml_properties.each do |m|\n                        map.add( m, instance_variable_get( m ) )\n                    end\n                end\n            end\n        end\n\tend\nend\n\nclass Date\n    yaml_as \"tag:yaml.org,2002:timestamp#ymd\"\n\tdef to_yaml( opts = {} )\n\t\tYAML::quick_emit( self, opts ) do |out|\n            out.scalar( \"tag:yaml.org,2002:timestamp\", self.to_s, :plain )\n        end\n\tend\nend\n\nclass Integer\n    yaml_as \"tag:yaml.org,2002:int\"\n\tdef to_yaml( opts = {} )\n\t\tYAML::quick_emit( nil, opts ) do |out|\n            out.scalar( \"tag:yaml.org,2002:int\", self.to_s, :plain )\n        end\n\tend\nend\n\nclass Float\n    yaml_as \"tag:yaml.org,2002:float\"\n\tdef to_yaml( opts = {} )\n\t\tYAML::quick_emit( nil, opts ) do |out|\n            str = self.to_s\n            if str == \"Infi"..., 4096) = 4096
read(3, ".Inf\"\n            elsif str == \"NaN\"\n                str = \".NaN\"\n            end\n            out.scalar( \"tag:yaml.org,2002:float\", str, :plain )\n        end\n\tend\nend\n\nclass TrueClass\n    yaml_as \"tag:yaml.org,2002:bool#yes\"\n\tdef to_yaml( opts = {} )\n\t\tYAML::quick_emit( nil, opts ) do |out|\n            out.scalar( taguri, \"true\", :plain )\n        end\n\tend\nend\n\nclass FalseClass\n    yaml_as \"tag:yaml.org,2002:bool#no\"\n\tdef to_yaml( opts = {} )\n\t\tYAML::quick_emit( nil, opts ) do |out|\n            out.scalar( taguri, \"false\", :plain )\n        end\n\tend\nend\n\nclass NilClass \n    yaml_as \"tag:yaml.org,2002:null\"\n\tdef to_yaml( opts = {} )\n\t\tYAML::quick_emit( nil, opts ) do |out|\n            out.scalar( taguri, \"\", :plain )\n        end\n\tend\nend\n\n", 4096) = 747
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/date.rb", 0xbfe51a10) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/date.so", 0xbfe51a10) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/date.rb", 0xbfe51a10) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/date.so", 0xbfe51a10) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/date.rb", 0xbfe51a10) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/date.so", 0xbfe51a10) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/date.rb", 0xbfe51a10) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/date.so", 0xbfe51a10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/date.rb", 0xbfe51a10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/date.so", 0xbfe51a10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/date.rb", 0xbfe51a10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/date.so", 0xbfe51a10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/date.rb", 0xbfe51a10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/date.so", 0xbfe51a10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/date.rb", {st_mode=S_IFREG|0644, st_size=54228, ...}) = 0
open("/usr/lib/ruby/1.8/date.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=54228, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/date.rb", 0xbfe51a20) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/date.rb", 0xbfe51a20) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/date.rb", 0xbfe51a20) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/date.rb", 0xbfe51a20) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/date.rb", 0xbfe51a20) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/date.rb", 0xbfe51a20) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/date.rb", 0xbfe51a20) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/date.rb", {st_mode=S_IFREG|0644, st_size=54228, ...}) = 0
open("/usr/lib/ruby/1.8/date.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=54228, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/date.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=54228, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/date.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/date.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=54228, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "#\n# date.rb - date and time library\n#\n# Author: Tadayoshi Funaba 1998-2008\n#\n# Documentation: William Webber <william@williamwebber.com>\n#\n#--\n# $Id: date.rb,v 2.37 2008-01-17 20:16:31+09 tadf Exp $\n#++\n#\n# == Overview\n#\n# This file provides two classes for working with\n# dates and times.\n#\n# The first class, Date, represents dates.\n# It works with years, months, weeks, and days.\n# See the Date class documentation for more details.\n#\n# The second, DateTime, extends Date to include hours,\n# minutes, seconds, and fractions of a second.  It\n# provides basic support for time zones.  See the\n# DateTime class documentation for more details.\n#\n# === Ways of calculating the date.\n#\n# In common usage, the date is reckoned in years since or\n# before the Common Era (CE/BCE, also known as AD/BC), then\n# as a month and day-of-the-month within the current year.\n# This is known as the *Civil* *Date*, and abbreviated\n# as +civil+ in the Date class.\n#\n# Instead of year, month-of-the-year,  and day-of-the-month,\n# the date can also be reckoned in terms of year and\n# day-of-the-year.  This is known as the *Ordinal* *Date*,\n# and is abbreviated as +ordinal+ in the Date class.  (Note\n# that referring to this as the Julian date is incorrect.)\n#\n# The date can also be reckoned in terms of year, week-of-the-year,\n# and day-of-the-week.  This is known as the *Commercial*\n# *Date*, and is abbreviated as +commercial+ in the\n# Date class.  The commercial week runs Monday (day-of-the-week\n# 1) to Sunday (day-of-the-week 7), in contrast to the civil\n# week which runs Sunday (day-of-the-week 0) to Saturday\n# (day-of-the-week 6).  The first week of the commercial year\n# starts on the Monday on or before January 1, and the commercial\n# year itself starts on this Monday, not January 1.\n#\n# For scientific purposes, it is convenient to refer to a date\n# simply as a day count, counting from an arbitrary initial\n# day.  The date first chosen for this was January 1, 4713 BCE.\n# A count of days from this date is the *Julian* *Day* *Number*\n# or *Julian* *Date*, which is abbreviated as +jd+ in the\n# Date class.  This is in local time, and counts from midnight\n# on the initial day.  The stricter usage is in UTC, and counts\n# from midday on the initial day.  This is referred to in the\n# Date class as the *Astronomical* *Julian* *Day* *Number*, and\n# abbreviated as +ajd+.  In the Date class, the Astronomical\n# Julian Day Number includes fractional days.\n#\n# Another absolute day count is the *Modified* *Julian* *Day*\n# *Number*, which takes November 17, 1858 as its initial day.\n# This is abbreviated as +mjd+ in the Date class.  There\n# is also an *Astronomical* *Modified* *Julian* *Day* *Number*,\n# which is in UTC and includes fractional days.  This is\n# abbreviated as +amjd+ in the Date class.  Like the Modified\n# Julian Day Number (and unlike the Astronomical Julian\n# Day Number), it counts from midnight.\n#\n# Alternative calendars such as the Chinese Lunar Calendar,\n# the Islamic Calendar, or the French Revolutionary Calendar\n# are not supported by the Date class; nor are calendars that\n# are based on an Era different from the Common Era, such as\n# the Japanese Imperial Calendar or the Republic of China\n# Calendar.\n#\n# === Calendar Reform\n#\n# The standard civil year is 365 days long.  However, the\n# solar year is fractionally longer than this.  To account\n# for this, a *leap* *year* is occasionally inserted.  This\n# is a year with 366 days, the extra day falling on February 29.\n# In the early days of the civil calendar, every fourth\n# year without exception was a leap year.  This way of\n# reckoning leap years is the *Julian* *Calendar*.\n#\n# However, the solar year is marginally shorter than 365 1/4\n# days, and so the *Julian* *Calendar* gradually ran slow\n# over the centuries.  To correct this, every 100th year\n# (but not every 400th year) was excluded as a leap year.\n# This way of reckoning leap years, which we use today, is\n# the *Gregorian* *Calendar*.\n#\n# The Grego"..., 4096) = 4096
read(3, " introduced\n# for a particular region is the *Day* *of* *Calendar*\n# *Reform* for that region.  This is abbreviated as +sg+\n# (for Start of Gregorian calendar) in the Date class.\n#\n# Two such days are of particular\n# significance.  The first is October 15, 1582, which was\n# the Day of Calendar Reform for Italy and most Catholic\n# countries.  The second is September 14, 1752, which was\n# the Day of Calendar Reform for England and its colonies\n# (including what is now the United States).  These two\n# dates are available as the constants Date::ITALY and\n# Date::ENGLAND, respectively.  (By comparison, Germany and\n# Holland, less Catholic than Italy but less stubborn than\n# England, changed over in 1698; Sweden in 1753; Russia not\n# till 1918, after the Revolution; and Greece in 1923.  Many\n# Orthodox churches still use the Julian Calendar.  A complete\n# list of Days of Calendar Reform can be found at\n# http://www.polysyllabic.com/GregConv.html.)\n#\n# Switching from the Julian to the Gregorian calendar\n# involved skipping a number of days to make up for the\n# accumulated lag, and the later the switch was (or is)\n# done, the more days need to be skipped.  So in 1582 in Italy,\n# 4th October was followed by 15th October, skipping 10 days; in 1752\n# in England, 2nd September was followed by 14th September, skipping\n# 11 days; and if I decided to switch from Julian to Gregorian\n# Calendar this midnight, I would go from 27th July 2003 (Julian)\n# today to 10th August 2003 (Gregorian) tomorrow, skipping\n# 13 days.  The Date class is aware of this gap, and a supposed\n# date that would fall in the middle of it is regarded as invalid.\n#\n# The Day of Calendar Reform is relevant to all date representations\n# involving years.  It is not relevant to the Julian Day Numbers,\n# except for converting between them and year-based representations.\n#\n# In the Date and DateTime classes, the Day of Calendar Reform or\n# +sg+ can be specified a number of ways.  First, it can be as\n# the Julian Day Number of the Day of Calendar Reform.  Second,\n# it can be using the constants Date::ITALY or Date::ENGLAND; these\n# are in fact the Julian Day Numbers of the Day of Calendar Reform\n# of the respective regions.  Third, it can be as the constant\n# Date::JULIAN, which means to always use the Julian Calendar.\n# Finally, it can be as the constant Date::GREGORIAN, which means\n# to always use the Gregorian Calendar.\n#\n# Note: in the Julian Calendar, New Years Day was March 25.  The\n# Date class does not follow this convention.\n#\n# === Time Zones\n#\n# DateTime objects support a simple representation\n# of time zones.  Time zones are represented as an offset\n# from UTC, as a fraction of a day.  This offset is the\n# how much local time is later (or earlier) than UTC.\n# UTC offset 0 is centred on England (also known as GMT).\n# As you travel east, the offset increases until you\n# reach the dateline in the middle of the Pacific Ocean;\n# as you travel west, the offset decreases.  This offset\n# is abbreviated as +of+ in the Date class.\n#\n# This simple representation of time zones does not take\n# into account the common practice of Daylight Savings\n# Time or Summer Time.\n#\n# Most DateTime methods return the date and the\n# time in local time.  The two exceptions are\n# #ajd() and #amjd(), which return the date and time\n# in UTC time, including fractional days.\n#\n# The Date class does not support time zone offsets, in that\n# there is no way to create a Date object with a time zone.\n# However, methods of the Date class when used by a\n# DateTime instance will use the time zone offset of this\n# instance.\n#\n# == Examples of use\n#\n# === Print out the date of every Sunday between two dates.\n#\n#     def print_sundays(d1, d2)\n#         d1 +=1 while (d1.wday != 0)\n#         d1.step(d2, 7) do |date|\n#             puts \"#{Date::MONTHNAMES[date.mon]} #{date.day}\"\n#         end\n#     end\n#\n#     print_sundays(Date::civil(2003, 4, 8), Date::civil(2003, 5, 23))\n#\n# === Calculate how many seconds to g"..., 4096) = 4096
read(3, " new_year = DateTime.new(now.year + 1, 1, 1)\n#         dif = new_year - now\n#         hours, mins, secs, ignore_fractions = Date::day_fraction_to_time(dif)\n#         return hours * 60 * 60 + mins * 60 + secs\n#     end\n#\n#     puts secs_to_new_year()\n\nrequire 'rational'\nrequire 'date/format'\n\n# Class representing a date.\n#\n# See the documentation to the file date.rb for an overview.\n#\n# Internally, the date is represented as an Astronomical\n# Julian Day Number, +ajd+.  The Day of Calendar Reform, +sg+, is\n# also stored, for conversions to other date formats.  (There\n# is also an +of+ field for a time zone offset, but this\n# is only for the use of the DateTime subclass.)\n#\n# A new Date object is created using one of the object creation\n# class methods named after the corresponding date format, and the\n# arguments appropriate to that date format; for instance,\n# Date::civil() (aliased to Date::new()) with year, month,\n# and day-of-month, or Date::ordinal() with year and day-of-year.\n# All of these object creation class methods also take the\n# Day of Calendar Reform as an optional argument.\n#\n# Date objects are immutable once created.\n#\n# Once a Date has been created, date values\n# can be retrieved for the different date formats supported\n# using instance methods.  For instance, #mon() gives the\n# Civil month, #cwday() gives the Commercial day of the week,\n# and #yday() gives the Ordinal day of the year.  Date values\n# can be retrieved in any format, regardless of what format\n# was used to create the Date instance.\n#\n# The Date class includes the Comparable module, allowing\n# date objects to be compared and sorted, ranges of dates\n# to be created, and so forth.\nclass Date\n\n  include Comparable\n\n  # Full month names, in English.  Months count from 1 to 12; a\n  # month's numerical representation indexed into this array\n  # gives the name of that month (hence the first element is nil).\n  MONTHNAMES = [nil] + %w(January February March April May June July\n\t\t\t  August September October November December)\n\n  # Full names of days of the week, in English.  Days of the week\n  # count from 0 to 6 (except in the commercial week); a day's numerical\n  # representation indexed into this array gives the name of that day.\n  DAYNAMES = %w(Sunday Monday Tuesday Wednesday Thursday Friday Saturday)\n\n  # Abbreviated month names, in English.\n  ABBR_MONTHNAMES = [nil] + %w(Jan Feb Mar Apr May Jun\n\t\t\t       Jul Aug Sep Oct Nov Dec)\n\n  # Abbreviated day names, in English.\n  ABBR_DAYNAMES = %w(Sun Mon Tue Wed Thu Fri Sat)\n\n  [MONTHNAMES, DAYNAMES, ABBR_MONTHNAMES, ABBR_DAYNAMES].each do |xs|\n    xs.each{|x| x.freeze unless x.nil?}.freeze\n  end\n\n  class Infinity < Numeric # :nodoc:\n\n    include Comparable\n\n    def initialize(d=1) @d = d <=> 0 end\n\n    def d() @d end\n\n    protected :d\n\n    def zero? () false end\n    def finite? () false end\n    def infinite? () d.nonzero? end\n    def nan? () d.zero? end\n\n    def abs() self.class.new end\n\n    def -@ () self.class.new(-d) end\n    def +@ () self.class.new(+d) end\n\n    def <=> (other)\n      case other\n      when Infinity; return d <=> other.d\n      when Numeric; return d\n      else\n\tbegin\n\t  l, r = other.coerce(self)\n\t  return l <=> r\n\trescue NoMethodError\n\tend\n      end\n      nil\n    end\n\n    def coerce(other)\n      case other\n      when Numeric; return -d, d\n      else\n\tsuper\n      end\n    end\n\n  end\n\n  # The Julian Day Number of the Day of Calendar Reform for Italy\n  # and the Catholic countries.\n  ITALY     = 2299161 # 1582-10-15\n\n  # The Julian Day Number of the Day of Calendar Reform for England\n  # and her Colonies.\n  ENGLAND   = 2361222 # 1752-09-14\n\n  # A constant used to indicate that a Date should always use the\n  # Julian calendar.\n  JULIAN    =  Infinity.new\n\n  # A constant used to indicate that a Date should always use the\n  # Gregorian calendar.\n  GREGORIAN = -Infinity.new\n\n  HALF_DAYS_IN_DAY       = Rational(1, 2) # :nodoc:\n  HOURS_IN_DAY           = Rational(1, 24) # :nodoc:\n  MINUTES_IN_DAY     "..., 4096) = 4096
read(3, "ISECONDS_IN_DAY    = Rational(1, 86400*10**3) # :nodoc:\n  NANOSECONDS_IN_DAY     = Rational(1, 86400*10**9) # :nodoc:\n  MILLISECONDS_IN_SECOND = Rational(1, 10**3) # :nodoc:\n  NANOSECONDS_IN_SECOND  = Rational(1, 10**9) # :nodoc:\n\n  MJD_EPOCH_IN_AJD       = Rational(4800001, 2) # 1858-11-17 # :nodoc:\n  UNIX_EPOCH_IN_AJD      = Rational(4881175, 2) # 1970-01-01 # :nodoc:\n  MJD_EPOCH_IN_CJD       = 2400001 # :nodoc:\n  UNIX_EPOCH_IN_CJD      = 2440588 # :nodoc:\n  LD_EPOCH_IN_CJD        = 2299160 # :nodoc:\n\n  # Does a given Julian Day Number fall inside the old-style (Julian)\n  # calendar?\n  #\n  # +jd+ is the Julian Day Number in question. +sg+ may be Date::GREGORIAN,\n  # in which case the answer is false; it may be Date::JULIAN, in which case\n  # the answer is true; or it may a number representing the Day of\n  # Calendar Reform. Date::ENGLAND and Date::ITALY are two possible such\n  # days.\n\n  def self.julian? (jd, sg)\n    case sg\n    when Numeric\n      jd < sg\n    else\n      if $VERBOSE\n\twarn(\"#{caller.shift.sub(/:in .*/, '')}: \" \\\n\"warning: do not use non-numerical object as julian day number anymore\")\n      end\n      not sg\n    end\n  end\n\n  # Does a given Julian Day Number fall inside the new-style (Gregorian)\n  # calendar?\n  #\n  # The reverse of self.os?  See the documentation for that method for\n  # more details.\n  def self.gregorian? (jd, sg) !julian?(jd, sg) end\n\n  def self.fix_style(jd, sg) # :nodoc:\n    if julian?(jd, sg)\n    then JULIAN\n    else GREGORIAN end\n  end\n\n  private_class_method :fix_style\n\n  # Convert an Ordinal Date to a Julian Day Number.\n  #\n  # +y+ and +d+ are the year and day-of-year to convert.\n  # +sg+ specifies the Day of Calendar Reform.\n  #\n  # Returns the corresponding Julian Day Number.\n  def self.ordinal_to_jd(y, d, sg=GREGORIAN)\n    civil_to_jd(y, 1, d, sg)\n  end\n\n  # Convert a Julian Day Number to an Ordinal Date.\n  #\n  # +jd+ is the Julian Day Number to convert.\n  # +sg+ specifies the Day of Calendar Reform.\n  #\n  # Returns the corresponding Ordinal Date as\n  # [year, day_of_year]\n  def self.jd_to_ordinal(jd, sg=GREGORIAN)\n    y = jd_to_civil(jd, sg)[0]\n    doy = jd - civil_to_jd(y - 1, 12, 31, fix_style(jd, sg))\n    return y, doy\n  end\n\n  # Convert a Civil Date to a Julian Day Number.\n  # +y+, +m+, and +d+ are the year, month, and day of the\n  # month.  +sg+ specifies the Day of Calendar Reform.\n  #\n  # Returns the corresponding Julian Day Number.\n  def self.civil_to_jd(y, m, d, sg=GREGORIAN)\n    if m <= 2\n      y -= 1\n      m += 12\n    end\n    a = (y / 100.0).floor\n    b = 2 - a + (a / 4.0).floor\n    jd = (365.25 * (y + 4716)).floor +\n      (30.6001 * (m + 1)).floor +\n      d + b - 1524\n    if julian?(jd, sg)\n      jd -= b\n    end\n    jd\n  end\n\n  # Convert a Julian Day Number to a Civil Date.  +jd+ is\n  # the Julian Day Number. +sg+ specifies the Day of\n  # Calendar Reform.\n  #\n  # Returns the corresponding [year, month, day_of_month]\n  # as a three-element array.\n  def self.jd_to_civil(jd, sg=GREGORIAN)\n    if julian?(jd, sg)\n      a = jd\n    else\n      x = ((jd - 1867216.25) / 36524.25).floor\n      a = jd + 1 + x - (x / 4.0).floor\n    end\n    b = a + 1524\n    c = ((b - 122.1) / 365.25).floor\n    d = (365.25 * c).floor\n    e = ((b - d) / 30.6001).floor\n    dom = b - d - (30.6001 * e).floor\n    if e <= 13\n      m = e - 1\n      y = c - 4716\n    else\n      m = e - 13\n      y = c - 4715\n    end\n    return y, m, dom\n  end\n\n  # Convert a Commercial Date to a Julian Day Number.\n  #\n  # +y+, +w+, and +d+ are the (commercial) year, week of the year,\n  # and day of the week of the Commercial Date to convert.\n  # +sg+ specifies the Day of Calendar Reform.\n  def self.commercial_to_jd(y, w, d, ns=GREGORIAN)\n    jd = civil_to_jd(y, 1, 4, ns)\n    (jd - (((jd - 1) + 1) % 7)) +\n      7 * (w - 1) +\n      (d - 1)\n  end\n\n  # Convert a Julian Day Number to a Commercial Date\n  #\n  # +jd+ is the Julian Day Number to convert.\n  # +sg+ specifies the Day of Calendar Reform.\n  #\n  # Returns the corresponding Commercia"..., 4096) = 4096
read(3, "EGORIAN)\n    ns = fix_style(jd, sg)\n    a = jd_to_civil(jd - 3, ns)[0]\n    y = if jd >= commercial_to_jd(a + 1, 1, 1, ns) then a + 1 else a end\n    w = 1 + ((jd - commercial_to_jd(y, 1, 1, ns)) / 7).floor\n    d = (jd + 1) % 7\n    d = 7 if d == 0\n    return y, w, d\n  end\n\n  def self.weeknum_to_jd(y, w, d, f=0, ns=GREGORIAN) # :nodoc:\n    a = civil_to_jd(y, 1, 1, ns) + 6\n    (a - ((a - f) + 1) % 7 - 7) + 7 * w + d\n  end\n\n  def self.jd_to_weeknum(jd, f=0, sg=GREGORIAN) # :nodoc:\n    ns = fix_style(jd, sg)\n    y, m, d = jd_to_civil(jd, ns)\n    a = civil_to_jd(y, 1, 1, ns) + 6\n    w, d = (jd - (a - ((a - f) + 1) % 7) + 7).divmod(7)\n    return y, w, d\n  end\n\n  private_class_method :weeknum_to_jd, :jd_to_weeknum\n\n  # Convert an Astronomical Julian Day Number to a (civil) Julian\n  # Day Number.\n  #\n  # +ajd+ is the Astronomical Julian Day Number to convert.\n  # +of+ is the offset from UTC as a fraction of a day (defaults to 0).\n  #\n  # Returns the (civil) Julian Day Number as [day_number,\n  # fraction] where +fraction+ is always 1/2.\n  def self.ajd_to_jd(ajd, of=0) (ajd + of + HALF_DAYS_IN_DAY).divmod(1) end\n\n  # Convert a (civil) Julian Day Number to an Astronomical Julian\n  # Day Number.\n  #\n  # +jd+ is the Julian Day Number to convert, and +fr+ is a\n  # fractional day.\n  # +of+ is the offset from UTC as a fraction of a day (defaults to 0).\n  #\n  # Returns the Astronomical Julian Day Number as a single\n  # numeric value.\n  def self.jd_to_ajd(jd, fr, of=0) jd + fr - of - HALF_DAYS_IN_DAY end\n\n  # Convert a fractional day +fr+ to [hours, minutes, seconds,\n  # fraction_of_a_second]\n  def self.day_fraction_to_time(fr)\n    ss,  fr = fr.divmod(SECONDS_IN_DAY) # 4p\n    h,   ss = ss.divmod(3600)\n    min, s  = ss.divmod(60)\n    return h, min, s, fr\n  end\n\n  # Convert an +h+ hour, +min+ minutes, +s+ seconds period\n  # to a fractional day.\n  begin\n    Rational(Rational(1, 2), 2) # a challenge\n\n    def self.time_to_day_fraction(h, min, s)\n      Rational(h * 3600 + min * 60 + s, 86400) # 4p\n    end\n  rescue\n    def self.time_to_day_fraction(h, min, s)\n\tif Integer === h && Integer === min && Integer === s\n\t  Rational(h * 3600 + min * 60 + s, 86400) # 4p\n\telse\n\t  (h * 3600 + min * 60 + s).to_r/86400 # 4p\n\tend\n    end\n  end\n\n  # Convert an Astronomical Modified Julian Day Number to an\n  # Astronomical Julian Day Number.\n  def self.amjd_to_ajd(amjd) amjd + MJD_EPOCH_IN_AJD end\n\n  # Convert an Astronomical Julian Day Number to an\n  # Astronomical Modified Julian Day Number.\n  def self.ajd_to_amjd(ajd) ajd - MJD_EPOCH_IN_AJD end\n\n  # Convert a Modified Julian Day Number to a Julian\n  # Day Number.\n  def self.mjd_to_jd(mjd) mjd + MJD_EPOCH_IN_CJD end\n\n  # Convert a Julian Day Number to a Modified Julian Day\n  # Number.\n  def self.jd_to_mjd(jd) jd - MJD_EPOCH_IN_CJD end\n\n  # Convert a count of the number of days since the adoption\n  # of the Gregorian Calendar (in Italy) to a Julian Day Number.\n  def self.ld_to_jd(ld) ld + LD_EPOCH_IN_CJD end\n\n  # Convert a Julian Day Number to the number of days since\n  # the adoption of the Gregorian Calendar (in Italy).\n  def self.jd_to_ld(jd) jd - LD_EPOCH_IN_CJD end\n\n  # Convert a Julian Day Number to the day of the week.\n  #\n  # Sunday is day-of-week 0; Saturday is day-of-week 6.\n  def self.jd_to_wday(jd) (jd + 1) % 7 end\n\n  # Is a year a leap year in the Julian calendar?\n  #\n  # All years divisible by 4 are leap years in the Julian calendar.\n  def self.julian_leap? (y) y % 4 == 0 end\n\n  # Is a year a leap year in the Gregorian calendar?\n  #\n  # All years divisible by 4 are leap years in the Gregorian calendar,\n  # except for years divisible by 100 and not by 400.\n  def self.gregorian_leap? (y) y % 4 == 0 && y % 100 != 0 || y % 400 == 0 end\n\n  class << self; alias_method :leap?, :gregorian_leap? end\n  class << self; alias_method :new!, :new end\n\n  # Is +jd+ a valid Julian Day Number?\n  #\n  # If it is, returns it.  In fact, any value is treated as a valid\n  # Julian Day Number.\n  def self.valid_jd? (jd, sg=ITALY) j"..., 4096) = 4096
read(3, "ponding Julian Day Number if they do, or\n  # nil if they don't.\n  #\n  # +d+ can be a negative number, in which case it counts backwards\n  # from the end of the year (-1 being the last day of the year).\n  # No year wraparound is performed, however, so valid values of\n  # +d+ are -365 .. -1, 1 .. 365 on a non-leap-year,\n  # -366 .. -1, 1 .. 366 on a leap year.\n  # A date falling in the period skipped in the Day of Calendar Reform\n  # adjustment is not valid.\n  #\n  # +sg+ specifies the Day of Calendar Reform.\n  def self.valid_ordinal? (y, d, sg=ITALY)\n    if d < 0\n      ny, = (y + 1).divmod(1)\n      jd = ordinal_to_jd(ny, d + 1, sg)\n      ns = fix_style(jd, sg)\n      return unless [y] == jd_to_ordinal(jd, sg)[0..0]\n      return unless [ny, 1] == jd_to_ordinal(jd - d, ns)\n    else\n      jd = ordinal_to_jd(y, d, sg)\n      return unless [y, d] == jd_to_ordinal(jd, sg)\n    end\n    jd\n  end\n\n  # Do year +y+, month +m+, and day-of-month +d+ make a\n  # valid Civil Date?  Returns the corresponding Julian\n  # Day Number if they do, nil if they don't.\n  #\n  # +m+ and +d+ can be negative, in which case they count\n  # backwards from the end of the year and the end of the\n  # month respectively.  No wraparound is performed, however,\n  # and invalid values cause an ArgumentError to be raised.\n  # A date falling in the period skipped in the Day of Calendar\n  # Reform adjustment is not valid.\n  #\n  # +sg+ specifies the Day of Calendar Reform.\n  def self.valid_civil? (y, m, d, sg=ITALY)\n    if m < 0\n      m += 13\n    end\n    if d < 0\n      ny, nm = (y * 12 + m).divmod(12)\n      nm,    = (nm + 1).divmod(1)\n      jd = civil_to_jd(ny, nm, d + 1, sg)\n      ns = fix_style(jd, sg)\n      return unless [y, m] == jd_to_civil(jd, sg)[0..1]\n      return unless [ny, nm, 1] == jd_to_civil(jd - d, ns)\n    else\n      jd = civil_to_jd(y, m, d, sg)\n      return unless [y, m, d] == jd_to_civil(jd, sg)\n    end\n    jd\n  end\n\n  class << self; alias_method :valid_date?, :valid_civil? end\n\n  # Do year +y+, week-of-year +w+, and day-of-week +d+ make a\n  # valid Commercial Date?  Returns the corresponding Julian\n  # Day Number if they do, nil if they don't.\n  #\n  # Monday is day-of-week 1; Sunday is day-of-week 7.\n  #\n  # +w+ and +d+ can be negative, in which case they count\n  # backwards from the end of the year and the end of the\n  # week respectively.  No wraparound is performed, however,\n  # and invalid values cause an ArgumentError to be raised.\n  # A date falling in the period skipped in the Day of Calendar\n  # Reform adjustment is not valid.\n  #\n  # +sg+ specifies the Day of Calendar Reform.\n  def self.valid_commercial? (y, w, d, sg=ITALY)\n    if d < 0\n      d += 8\n    end\n    if w < 0\n      ny, nw, nd =\n\tjd_to_commercial(commercial_to_jd(y + 1, 1, 1) + w * 7)\n      return unless ny == y\n      w = nw\n    end\n    jd = commercial_to_jd(y, w, d)\n    return unless gregorian?(jd, sg)\n    return unless [y, w, d] == jd_to_commercial(jd)\n    jd\n  end\n\n  def self.valid_weeknum? (y, w, d, f, sg=ITALY) # :nodoc:\n    if d < 0\n      d += 7\n    end\n    if w < 0\n      ny, nw, nd, nf =\n\tjd_to_weeknum(weeknum_to_jd(y + 1, 1, f, f) + w * 7, f)\n      return unless ny == y\n      w = nw\n    end\n    jd = weeknum_to_jd(y, w, d, f)\n    return unless gregorian?(jd, sg)\n    return unless [y, w, d] == jd_to_weeknum(jd, f)\n    jd\n  end\n\n  private_class_method :valid_weeknum?\n\n  # Do hour +h+, minute +min+, and second +s+ constitute a valid time?\n  #\n  # If they do, returns their value as a fraction of a day.  If not,\n  # returns nil.\n  #\n  # The 24-hour clock is used.  Negative values of +h+, +min+, and\n  # +sec+ are treating as counting backwards from the end of the\n  # next larger unit (e.g. a +min+ of -2 is treated as 58).  No\n  # wraparound is performed.\n  def self.valid_time? (h, min, s)\n    h   += 24 if h   < 0\n    min += 60 if min < 0\n    s   += 60 if s   < 0\n    return unless ((0...24) === h &&\n\t\t   (0...60) === min &&\n\t\t   (0...60) === s) ||\n\t\t  (24 == h &&\n\t\t    0 == min &&\n\t\t    0"..., 4096) = 4096
mmap2(NULL, 651264, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7728000
read(3, " Number.\n  #\n  # +jd+ is the Julian Day Number; if not specified, it defaults to\n  # 0.\n  # +sg+ specifies the Day of Calendar Reform.\n  def self.jd(jd=0, sg=ITALY)\n    jd = valid_jd?(jd, sg)\n    new!(jd_to_ajd(jd, 0, 0), 0, sg)\n  end\n\n  # Create a new Date object from an Ordinal Date, specified\n  # by year +y+ and day-of-year +d+. +d+ can be negative,\n  # in which it counts backwards from the end of the year.\n  # No year wraparound is performed, however.  An invalid\n  # value for +d+ results in an ArgumentError being raised.\n  #\n  # +y+ defaults to -4712, and +d+ to 1; this is Julian Day\n  # Number day 0.\n  #\n  # +sg+ specifies the Day of Calendar Reform.\n  def self.ordinal(y=-4712, d=1, sg=ITALY)\n    unless jd = valid_ordinal?(y, d, sg)\n      raise ArgumentError, 'invalid date'\n    end\n    new!(jd_to_ajd(jd, 0, 0), 0, sg)\n  end\n\n  # Create a new Date object for the Civil Date specified by\n  # year +y+, month +m+, and day-of-month +d+.\n  #\n  # +m+ and +d+ can be negative, in which case they count\n  # backwards from the end of the year and the end of the\n  # month respectively.  No wraparound is performed, however,\n  # and invalid values cause an ArgumentError to be raised.\n  # can be negative\n  #\n  # +y+ defaults to -4712, +m+ to 1, and +d+ to 1; this is\n  # Julian Day Number day 0.\n  #\n  # +sg+ specifies the Day of Calendar Reform.\n  def self.civil(y=-4712, m=1, d=1, sg=ITALY)\n    unless jd = valid_civil?(y, m, d, sg)\n      raise ArgumentError, 'invalid date'\n    end\n    new!(jd_to_ajd(jd, 0, 0), 0, sg)\n  end\n\n  class << self; alias_method :new, :civil end\n\n  # Create a new Date object for the Commercial Date specified by\n  # year +y+, week-of-year +w+, and day-of-week +d+.\n  #\n  # Monday is day-of-week 1; Sunday is day-of-week 7.\n  #\n  # +w+ and +d+ can be negative, in which case they count\n  # backwards from the end of the year and the end of the\n  # week respectively.  No wraparound is performed, however,\n  # and invalid values cause an ArgumentError to be raised.\n  #\n  # +y+ defaults to 1582, +w+ to 41, and +d+ to 5, the Day of\n  # Calendar Reform for Italy and the Catholic countries.\n  #\n  # +sg+ specifies the Day of Calendar Reform.\n  def self.commercial(y=1582, w=41, d=5, sg=ITALY)\n    unless jd = valid_commercial?(y, w, d, sg)\n      raise ArgumentError, 'invalid date'\n    end\n    new!(jd_to_ajd(jd, 0, 0), 0, sg)\n  end\n\n  def self.weeknum(y=1582, w=41, d=5, f=0, sg=ITALY) # :nodoc:\n    unless jd = valid_weeknum?(y, w, d, f, sg)\n      raise ArgumentError, 'invalid date'\n    end\n    new!(jd_to_ajd(jd, 0, 0), 0, sg)\n  end\n\n  private_class_method :weeknum\n\n  def self.rewrite_frags(elem) # :nodoc:\n    elem ||= {}\n    if seconds = elem[:seconds]\n      d,   fr = seconds.divmod(86400)\n      h,   fr = fr.divmod(3600)\n      min, fr = fr.divmod(60)\n      s,   fr = fr.divmod(1)\n      elem[:jd] = UNIX_EPOCH_IN_CJD + d\n      elem[:hour] = h\n      elem[:min] = min\n      elem[:sec] = s\n      elem[:sec_fraction] = fr\n      elem.delete(:seconds)\n      elem.delete(:offset)\n    end\n    elem\n  end\n\n  private_class_method :rewrite_frags\n\n  def self.complete_frags(elem) # :nodoc:\n    i = 0\n    g = [[:time, [:hour, :min, :sec]],\n\t [nil, [:jd]],\n\t [:ordinal, [:year, :yday, :hour, :min, :sec]],\n\t [:civil, [:year, :mon, :mday, :hour, :min, :sec]],\n\t [:commercial, [:cwyear, :cweek, :cwday, :hour, :min, :sec]],\n\t [:wday, [:wday, :hour, :min, :sec]],\n\t [:wnum0, [:year, :wnum0, :wday, :hour, :min, :sec]],\n\t [:wnum1, [:year, :wnum1, :wday, :hour, :min, :sec]],\n\t [nil, [:cwyear, :cweek, :wday, :hour, :min, :sec]],\n\t [nil, [:year, :wnum0, :cwday, :hour, :min, :sec]],\n\t [nil, [:year, :wnum1, :cwday, :hour, :min, :sec]]].\n      collect{|k, a| e = elem.values_at(*a).compact; [k, a, e]}.\n      select{|k, a, e| e.size > 0}.\n      sort_by{|k, a, e| [e.size, i -= 1]}.last\n\n    d = nil\n\n    if g && g[0] && (g[1].size - g[2].size) != 0\n      d ||= Date.today\n\n      case g[0]\n      when :ordinal\n\telem[:year] ||= d.year\n\telem[:yday] ||= 1\n      when :civil\n\tg[1]"..., 4096) = 4096
read(3, " ||= 1\n      when :commercial\n\tg[1].each do |e|\n\t  break if elem[e]\n\t  elem[e] = d.__send__(e)\n\tend\n\telem[:cweek] ||= 1\n\telem[:cwday] ||= 1\n      when :wday\n\telem[:jd] ||= (d - d.wday + elem[:wday]).jd\n      when :wnum0\n\tg[1].each do |e|\n\t  break if elem[e]\n\t  elem[e] = d.__send__(e)\n\tend\n\telem[:wnum0] ||= 0\n\telem[:wday]  ||= 0\n      when :wnum1\n\tg[1].each do |e|\n\t  break if elem[e]\n\t  elem[e] = d.__send__(e)\n\tend\n\telem[:wnum1] ||= 0\n\telem[:wday]  ||= 0\n      end\n    end\n\n    if g && g[0] == :time\n      if self <= DateTime\n\td ||= Date.today\n\telem[:jd] ||= d.jd\n      end\n    end\n\n    elem[:hour] ||= 0\n    elem[:min]  ||= 0\n    elem[:sec]  ||= 0\n    elem[:sec] = [elem[:sec], 59].min\n\n    elem\n  end\n\n  private_class_method :complete_frags\n\n  def self.valid_date_frags?(elem, sg) # :nodoc:\n    catch :jd do\n      a = elem.values_at(:jd)\n      if a.all?\n\tif jd = valid_jd?(*(a << sg))\n\t  throw :jd, jd\n\tend\n      end\n\n      a = elem.values_at(:year, :yday)\n      if a.all?\n\tif jd = valid_ordinal?(*(a << sg))\n\t  throw :jd, jd\n\tend\n      end\n\n      a = elem.values_at(:year, :mon, :mday)\n      if a.all?\n\tif jd = valid_civil?(*(a << sg))\n\t  throw :jd, jd\n\tend\n      end\n\n      a = elem.values_at(:cwyear, :cweek, :cwday)\n      if a[2].nil? && elem[:wday]\n\ta[2] = elem[:wday].nonzero? || 7\n      end\n      if a.all?\n\tif jd = valid_commercial?(*(a << sg))\n\t  throw :jd, jd\n\tend\n      end\n\n      a = elem.values_at(:year, :wnum0, :wday)\n      if a[2].nil? && elem[:cwday]\n\ta[2] = elem[:cwday] % 7\n      end\n      if a.all?\n\tif jd = valid_weeknum?(*(a << 0 << sg))\n\t  throw :jd, jd\n\tend\n      end\n\n      a = elem.values_at(:year, :wnum1, :wday)\n      if a[2]\n\ta[2] = (a[2] - 1) % 7\n      end\n      if a[2].nil? && elem[:cwday]\n\ta[2] = (elem[:cwday] - 1) % 7\n      end\n      if a.all?\n\tif jd = valid_weeknum?(*(a << 1 << sg))\n\t  throw :jd, jd\n\tend\n      end\n    end\n  end\n\n  private_class_method :valid_date_frags?\n\n  def self.valid_time_frags? (elem) # :nodoc:\n    h, min, s = elem.values_at(:hour, :min, :sec)\n    valid_time?(h, min, s)\n  end\n\n  private_class_method :valid_time_frags?\n\n  def self.new_by_frags(elem, sg) # :nodoc:\n    elem = rewrite_frags(elem)\n    elem = complete_frags(elem)\n    unless jd = valid_date_frags?(elem, sg)\n      raise ArgumentError, 'invalid date'\n    end\n    new!(jd_to_ajd(jd, 0, 0), 0, sg)\n  end\n\n  private_class_method :new_by_frags\n\n  # Create a new Date object by parsing from a String\n  # according to a specified format.\n  #\n  # +str+ is a String holding a date representation.\n  # +fmt+ is the format that the date is in.  See\n  # date/format.rb for details on supported formats.\n  #\n  # The default +str+ is '-4712-01-01', and the default\n  # +fmt+ is '%F', which means Year-Month-Day_of_Month.\n  # This gives Julian Day Number day 0.\n  #\n  # +sg+ specifies the Day of Calendar Reform.\n  #\n  # An ArgumentError will be raised if +str+ cannot be\n  # parsed.\n  def self.strptime(str='-4712-01-01', fmt='%F', sg=ITALY)\n    elem = _strptime(str, fmt)\n    new_by_frags(elem, sg)\n  end\n\n  # Create a new Date object by parsing from a String,\n  # without specifying the format.\n  #\n  # +str+ is a String holding a date representation.\n  # +comp+ specifies whether to interpret 2-digit years\n  # as 19XX (>= 69) or 20XX (< 69); the default is not to.\n  # The method will attempt to parse a date from the String\n  # using various heuristics; see #_parse in date/format.rb\n  # for more details.  If parsing fails, an ArgumentError\n  # will be raised.\n  #\n  # The default +str+ is '-4712-01-01'; this is Julian\n  # Day Number day 0.\n  #\n  # +sg+ specifies the Day of Calendar Reform.\n  def self.parse(str='-4712-01-01', comp=false, sg=ITALY)\n    elem = _parse(str, comp)\n    new_by_frags(elem, sg)\n  end\n\n  class << self\n\n    def once(*ids) # :nodoc:\n      for id in ids\n\tmodule_eval <<-\"end;\"\n\t  alias_method :__#{id.to_i}__, :#{id.to_s}\n\t  private :__#{id.to_i}__\n\t  def #{id.to_s}(*args, &block)\n\t    (@__#{id.to_i}__ ||= [__#{id.to_i}__(*args, &block)])[0]\n\t  end\n"..., 4096) = 4096
read(3, "method new!().  If\n  # you are reading this as the documentation for new(), that is\n  # because rdoc doesn't fully support the aliasing of the\n  # initialize() method.\n  # new() is in\n  # fact an alias for #civil(): read the documentation for that\n  # method instead.\n  #\n  # Create a new Date object.\n  #\n  # +ajd+ is the Astronomical Julian Day Number.\n  # +of+ is the offset from UTC as a fraction of a day.\n  # Both default to 0.\n  #\n  # +sg+ specifies the Day of Calendar Reform to use for this\n  # Date object.\n  #\n  # Using one of the factory methods such as Date::civil is\n  # generally easier and safer.\n  def initialize(ajd=0, of=0, sg=ITALY) @ajd, @of, @sg = ajd, of, sg end\n\n  # Get the date as an Astronomical Julian Day Number.\n  def ajd() @ajd end\n\n  # Get the date as an Astronomical Modified Julian Day Number.\n  def amjd() self.class.ajd_to_amjd(@ajd) end\n\n  once :amjd\n\n  # Get the date as a Julian Day Number.\n  def jd() self.class.ajd_to_jd(@ajd, @of)[0] end\n\n  # Get any fractional day part of the date.\n  def day_fraction() self.class.ajd_to_jd(@ajd, @of)[1] end\n\n  # Get the date as a Modified Julian Day Number.\n  def mjd() self.class.jd_to_mjd(jd) end\n\n  # Get the date as the number of days since the Day of Calendar\n  # Reform (in Italy and the Catholic countries).\n  def ld() self.class.jd_to_ld(jd) end\n\n  once :jd, :day_fraction, :mjd, :ld\n\n  # Get the date as a Civil Date, [year, month, day_of_month]\n  def civil() self.class.jd_to_civil(jd, @sg) end # :nodoc:\n\n  # Get the date as an Ordinal Date, [year, day_of_year]\n  def ordinal() self.class.jd_to_ordinal(jd, @sg) end # :nodoc:\n\n  # Get the date as a Commercial Date, [year, week_of_year, day_of_week]\n  def commercial() self.class.jd_to_commercial(jd, @sg) end # :nodoc:\n\n  def weeknum0() self.class.__send__(:jd_to_weeknum, jd, 0, @sg) end # :nodoc:\n  def weeknum1() self.class.__send__(:jd_to_weeknum, jd, 1, @sg) end # :nodoc:\n\n  once :civil, :ordinal, :commercial, :weeknum0, :weeknum1\n  private :civil, :ordinal, :commercial, :weeknum0, :weeknum1\n\n  # Get the year of this date.\n  def year() civil[0] end\n\n  # Get the day-of-the-year of this date.\n  #\n  # January 1 is day-of-the-year 1\n  def yday() ordinal[1] end\n\n  # Get the month of this date.\n  #\n  # January is month 1.\n  def mon() civil[1] end\n\n  # Get the day-of-the-month of this date.\n  def mday() civil[2] end\n\n  alias_method :month, :mon\n  alias_method :day, :mday\n\n  def wnum0() weeknum0[1] end # :nodoc:\n  def wnum1() weeknum1[1] end # :nodoc:\n\n  private :wnum0, :wnum1\n\n  # Get the time of this date as [hours, minutes, seconds,\n  # fraction_of_a_second]\n  def time() self.class.day_fraction_to_time(day_fraction) end # :nodoc:\n\n  once :time\n  private :time\n\n  # Get the hour of this date.\n  def hour() time[0] end\n\n  # Get the minute of this date.\n  def min() time[1] end\n\n  # Get the second of this date.\n  def sec() time[2] end\n\n  # Get the fraction-of-a-second of this date.  The unit is in days.\n  # I do NOT recommend you to use this method.\n  def sec_fraction() time[3] end\n\n=begin\n  alias_method :minute, :min\n  alias_method :second, :sec\n  alias_method :second_fraction, :sec_fraction\n=end\n\n  private :hour, :min, :sec, :sec_fraction\n#\t  :minute, :second, :second_fraction\n\n  def zone() strftime('%:z') end\n\n  private :zone\n\n  # Get the commercial year of this date.  See *Commercial* *Date*\n  # in the introduction for how this differs from the normal year.\n  def cwyear() commercial[0] end\n\n  # Get the commercial week of the year of this date.\n  def cweek() commercial[1] end\n\n  # Get the commercial day of the week of this date.  Monday is\n  # commercial day-of-week 1; Sunday is commercial day-of-week 7.\n  def cwday() commercial[2] end\n\n  # Get the week day of this date.  Sunday is day-of-week 0;\n  # Saturday is day-of-week 6.\n  def wday() self.class.jd_to_wday(jd) end\n\n  once :wday\n\n=begin\n  MONTHNAMES.each_with_index do |n, i|\n    if n\n      define_method(n.downcase + '?'){mon == i}\n    end\n  end\n\n  DAYNAMES.each_with_"..., 4096) = 4096
read(3, "te old-style (Julian Calendar)?\n  def julian? () self.class.julian?(jd, @sg) end\n\n  # Is the current date new-style (Gregorian Calendar)?\n  def gregorian? () self.class.gregorian?(jd, @sg) end\n\n  once :julian?, :gregorian?\n\n  def fix_style # :nodoc:\n    if julian?\n    then self.class::JULIAN\n    else self.class::GREGORIAN end\n  end\n\n  private :fix_style\n\n  # Is this a leap year?\n  def leap?\n    self.class.jd_to_civil(self.class.civil_to_jd(year, 3, 1, fix_style) - 1,\n\t\t     fix_style)[-1] == 29\n  end\n\n  once :leap?\n\n  # When is the Day of Calendar Reform for this Date object?\n  def start() @sg end\n\n  # Create a copy of this Date object using a new Day of Calendar Reform.\n  def new_start(sg=self.class::ITALY) self.class.new!(@ajd, @of, sg) end\n\n  # Create a copy of this Date object that uses the Italian/Catholic\n  # Day of Calendar Reform.\n  def italy() new_start(self.class::ITALY) end\n\n  # Create a copy of this Date object that uses the English/Colonial\n  # Day of Calendar Reform.\n  def england() new_start(self.class::ENGLAND) end\n\n  # Create a copy of this Date object that always uses the Julian\n  # Calendar.\n  def julian() new_start(self.class::JULIAN) end\n\n  # Create a copy of this Date object that always uses the Gregorian\n  # Calendar.\n  def gregorian() new_start(self.class::GREGORIAN) end\n\n  def offset() @of end\n\n  def new_offset(of=0)\n    if String === of\n      of = Rational(zone_to_diff(of) || 0, 86400)\n    end\n    self.class.new!(@ajd, of, @sg)\n  end\n\n  private :offset, :new_offset\n\n  # Return a new Date object that is +n+ days later than the\n  # current one.\n  #\n  # +n+ may be a negative value, in which case the new Date\n  # is earlier than the current one; however, #-() might be\n  # more intuitive.\n  #\n  # If +n+ is not a Numeric, a TypeError will be thrown.  In\n  # particular, two Dates cannot be added to each other.\n  def + (n)\n    case n\n    when Numeric; return self.class.new!(@ajd + n, @of, @sg)\n    end\n    raise TypeError, 'expected numeric'\n  end\n\n  # If +x+ is a Numeric value, create a new Date object that is\n  # +x+ days earlier than the current one.\n  #\n  # If +x+ is a Date, return the number of days between the\n  # two dates; or, more precisely, how many days later the current\n  # date is than +x+.\n  #\n  # If +x+ is neither Numeric nor a Date, a TypeError is raised.\n  def - (x)\n    case x\n    when Numeric; return self.class.new!(@ajd - x, @of, @sg)\n    when Date;    return @ajd - x.ajd\n    end\n    raise TypeError, 'expected numeric or date'\n  end\n\n  # Compare this date with another date.\n  #\n  # +other+ can also be a Numeric value, in which case it is\n  # interpreted as an Astronomical Julian Day Number.\n  #\n  # Comparison is by Astronomical Julian Day Number, including\n  # fractional days.  This means that both the time and the\n  # timezone offset are taken into account when comparing\n  # two DateTime instances.  When comparing a DateTime instance\n  # with a Date instance, the time of the latter will be\n  # considered as falling on midnight UTC.\n  def <=> (other)\n    case other\n    when Numeric; return @ajd <=> other\n    when Date;    return @ajd <=> other.ajd\n    end\n    nil\n  end\n\n  # The relationship operator for Date.\n  #\n  # Compares dates by Julian Day Number.  When comparing\n  # two DateTime instances, or a DateTime with a Date,\n  # the instances will be regarded as equivalent if they\n  # fall on the same date in local time.\n  def === (other)\n    case other\n    when Numeric; return jd == other\n    when Date;    return jd == other.jd\n    end\n    false\n  end\n\n  def next_day(n=1) self + n end\n# def prev_day(n=1) self - n end\n\n  private :next_day\n\n  # Return a new Date one day after this one.\n  def next() next_day end\n\n  alias_method :succ, :next\n\n  # Return a new Date object that is +n+ months later than\n  # the current one.\n  #\n  # If the day-of-the-month of the current Date is greater\n  # than the last day of the target month, the day-of-the-month\n  # of the returned Date will be the last day of th"..., 4096) = 4096
read(3, ")                    .divmod(1)\n    d = mday\n    d -= 1 until jd2 = self.class.valid_civil?(y, m, d, fix_style)\n    self + (jd2 - jd)\n  end\n\n  # Return a new Date object that is +n+ months earlier than\n  # the current one.\n  #\n  # If the day-of-the-month of the current Date is greater\n  # than the last day of the target month, the day-of-the-month\n  # of the returned Date will be the last day of the target month.\n  def << (n) self >> -n end\n\n=begin\n  def next_month(n=1) self >> n end\n  def prev_month(n=1) self << n end\n\n  def next_year(n=1) self >> n * 12 end\n  def prev_year(n=1) self << n * 12 end\n=end\n\n#  require 'enumerator'\n\n  # Step the current date forward +step+ days at a\n  # time (or backward, if +step+ is negative) until\n  # we reach +limit+ (inclusive), yielding the resultant\n  # date at each step.\n  def step(limit, step=1) # :yield: date\n=begin\n    if step.zero?\n      raise ArgumentError, \"step can't be 0\"\n    end\n=end\n=begin\n    unless block_given?\n      return to_enum(:step, limit, step)\n    end\n=end\n    da = self\n    op = %w(- <= >=)[step <=> 0]\n    while da.__send__(op, limit)\n      yield da\n      da += step\n    end\n    self\n  end\n\n  # Step forward one day at a time until we reach +max+\n  # (inclusive), yielding each date as we go.\n  def upto(max, &block) # :yield: date\n    step(max, +1, &block)\n  end\n\n  # Step backward one day at a time until we reach +min+\n  # (inclusive), yielding each date as we go.\n  def downto(min, &block) # :yield: date\n    step(min, -1, &block)\n  end\n\n  # Is this Date equal to +other+?\n  #\n  # +other+ must both be a Date object, and represent the same date.\n  def eql? (other) Date === other && self == other end\n\n  # Calculate a hash value for this date.\n  def hash() @ajd.hash end\n\n  # Return internal object state as a programmer-readable string.\n  def inspect() format('#<%s: %s,%s,%s>', self.class, @ajd, @of, @sg) end\n\n  # Return the date as a human-readable string.\n  #\n  # The format used is YYYY-MM-DD.\n  def to_s() format('%.4d-%02d-%02d', year, mon, mday) end # 4p\n\n  # Dump to Marshal format.\n  def _dump(limit) Marshal.dump([@ajd, @of, @sg], -1) end\n\n# def self._load(str) new!(*Marshal.load(str)) end\n\n  # Load from Marshal format.\n  def self._load(str)\n    a = Marshal.load(str)\n    if a.size == 2\n      ajd,     sg = a\n           of = 0\n      ajd -= 1.to_r/2\n    else\n      ajd, of, sg = a\n    end\n    new!(ajd, of, sg)\n  end\n\nend\n\n# Class representing a date and time.\n#\n# See the documentation to the file date.rb for an overview.\n#\n# DateTime objects are immutable once created.\n#\n# == Other methods.\n#\n# The following methods are defined in Date, but declared private\n# there.  They are made public in DateTime.  They are documented\n# here.\n#\n# === hour()\n#\n# Get the hour-of-the-day of the time.  This is given\n# using the 24-hour clock, counting from midnight.  The first\n# hour after midnight is hour 0; the last hour of the day is\n# hour 23.\n#\n# === min()\n#\n# Get the minute-of-the-hour of the time.\n#\n# === sec()\n#\n# Get the second-of-the-minute of the time.\n#\n# === sec_fraction()\n#\n# Get the fraction of a second of the time.  This is returned as\n# a +Rational+.  The unit is in days.\n# I do NOT recommend you to use this method.\n#\n# === zone()\n#\n# Get the time zone as a String.  This is representation of the\n# time offset such as \"+1000\", not the true time-zone name.\n#\n# === offset()\n#\n# Get the time zone offset as a fraction of a day.  This is returned\n# as a +Rational+.\n#\n# === new_offset(of=0)\n#\n# Create a new DateTime object, identical to the current one, except\n# with a new time zone offset of +of+.  +of+ is the new offset from\n# UTC as a fraction of a day.\n#\nclass DateTime < Date\n\n  # Create a new DateTime object corresponding to the specified\n  # Julian Day Number +jd+ and hour +h+, minute +min+, second +s+.\n  #\n  # The 24-hour clock is used.  Negative values of +h+, +min+, and\n  # +sec+ are treating as counting backwards from the end of the\n  # next larger unit (e.g. a +min+ of -2 is"..., 4096) = 4096
read(3, "an ArgumentError is raised.\n  #\n  # +of+ is the offset from UTC as a fraction of a day (defaults to 0).\n  # +sg+ specifies the Day of Calendar Reform.\n  #\n  # All day/time values default to 0.\n  def self.jd(jd=0, h=0, min=0, s=0, of=0, sg=ITALY)\n    unless (jd = valid_jd?(jd, sg)) &&\n\t   (fr = valid_time?(h, min, s))\n      raise ArgumentError, 'invalid date'\n    end\n    if String === of\n      of = Rational(zone_to_diff(of) || 0, 86400)\n    end\n    new!(jd_to_ajd(jd, fr, of), of, sg)\n  end\n\n  # Create a new DateTime object corresponding to the specified\n  # Ordinal Date and hour +h+, minute +min+, second +s+.\n  #\n  # The 24-hour clock is used.  Negative values of +h+, +min+, and\n  # +sec+ are treating as counting backwards from the end of the\n  # next larger unit (e.g. a +min+ of -2 is treated as 58).  No\n  # wraparound is performed.  If an invalid time portion is specified,\n  # an ArgumentError is raised.\n  #\n  # +of+ is the offset from UTC as a fraction of a day (defaults to 0).\n  # +sg+ specifies the Day of Calendar Reform.\n  #\n  # +y+ defaults to -4712, and +d+ to 1; this is Julian Day Number\n  # day 0.  The time values default to 0.\n  def self.ordinal(y=-4712, d=1, h=0, min=0, s=0, of=0, sg=ITALY)\n    unless (jd = valid_ordinal?(y, d, sg)) &&\n\t   (fr = valid_time?(h, min, s))\n      raise ArgumentError, 'invalid date'\n    end\n    if String === of\n      of = Rational(zone_to_diff(of) || 0, 86400)\n    end\n    new!(jd_to_ajd(jd, fr, of), of, sg)\n  end\n\n  # Create a new DateTime object corresponding to the specified\n  # Civil Date and hour +h+, minute +min+, second +s+.\n  #\n  # The 24-hour clock is used.  Negative values of +h+, +min+, and\n  # +sec+ are treating as counting backwards from the end of the\n  # next larger unit (e.g. a +min+ of -2 is treated as 58).  No\n  # wraparound is performed.  If an invalid time portion is specified,\n  # an ArgumentError is raised.\n  #\n  # +of+ is the offset from UTC as a fraction of a day (defaults to 0).\n  # +sg+ specifies the Day of Calendar Reform.\n  #\n  # +y+ defaults to -4712, +m+ to 1, and +d+ to 1; this is Julian Day\n  # Number day 0.  The time values default to 0.\n  def self.civil(y=-4712, m=1, d=1, h=0, min=0, s=0, of=0, sg=ITALY)\n    unless (jd = valid_civil?(y, m, d, sg)) &&\n\t   (fr = valid_time?(h, min, s))\n      raise ArgumentError, 'invalid date'\n    end\n    if String === of\n      of = Rational(zone_to_diff(of) || 0, 86400)\n    end\n    new!(jd_to_ajd(jd, fr, of), of, sg)\n  end\n\n  class << self; alias_method :new, :civil end\n\n  # Create a new DateTime object corresponding to the specified\n  # Commercial Date and hour +h+, minute +min+, second +s+.\n  #\n  # The 24-hour clock is used.  Negative values of +h+, +min+, and\n  # +sec+ are treating as counting backwards from the end of the\n  # next larger unit (e.g. a +min+ of -2 is treated as 58).  No\n  # wraparound is performed.  If an invalid time portion is specified,\n  # an ArgumentError is raised.\n  #\n  # +of+ is the offset from UTC as a fraction of a day (defaults to 0).\n  # +sg+ specifies the Day of Calendar Reform.\n  #\n  # +y+ defaults to 1582, +w+ to 41, and +d+ to 5; this is the Day of\n  # Calendar Reform for Italy and the Catholic countries.\n  # The time values default to 0.\n  def self.commercial(y=1582, w=41, d=5, h=0, min=0, s=0, of=0, sg=ITALY)\n    unless (jd = valid_commercial?(y, w, d, sg)) &&\n\t   (fr = valid_time?(h, min, s))\n      raise ArgumentError, 'invalid date'\n    end\n    if String === of\n      of = Rational(zone_to_diff(of) || 0, 86400)\n    end\n    new!(jd_to_ajd(jd, fr, of), of, sg)\n  end\n\n  def self.weeknum(y=1582, w=41, d=5, f=0, h=0, min=0, s=0, of=0, sg=ITALY) # :nodoc:\n    unless (jd = valid_weeknum?(y, w, d, f, sg)) &&\n\t   (fr = valid_time?(h, min, s))\n      raise ArgumentError, 'invalid date'\n    end\n    if String === of\n      of = Rational(zone_to_diff(of) || 0, 86400)\n    end\n    new!(jd_to_ajd(jd, fr, of), of, sg)\n  end\n\n  private_class_method :weeknum\n\n  def self.new_by_frags(elem, sg) # :nodoc:\n    "..., 4096) = 4096
read(3, "em, sg)) &&\n\t   (fr = valid_time_frags?(elem))\n      raise ArgumentError, 'invalid date'\n    end\n    fr += (elem[:sec_fraction] || 0) / 86400\n    of = Rational(elem[:offset] || 0, 86400)\n    new!(jd_to_ajd(jd, fr, of), of, sg)\n  end\n\n  private_class_method :new_by_frags\n\n  # Create a new DateTime object by parsing from a String\n  # according to a specified format.\n  #\n  # +str+ is a String holding a date-time representation.\n  # +fmt+ is the format that the date-time is in.  See\n  # date/format.rb for details on supported formats.\n  #\n  # The default +str+ is '-4712-01-01T00:00:00+00:00', and the default\n  # +fmt+ is '%FT%T%z'.  This gives midnight on Julian Day Number day 0.\n  #\n  # +sg+ specifies the Day of Calendar Reform.\n  #\n  # An ArgumentError will be raised if +str+ cannot be\n  # parsed.\n  def self.strptime(str='-4712-01-01T00:00:00+00:00', fmt='%FT%T%z', sg=ITALY)\n    elem = _strptime(str, fmt)\n    new_by_frags(elem, sg)\n  end\n\n  # Create a new DateTime object by parsing from a String,\n  # without specifying the format.\n  #\n  # +str+ is a String holding a date-time representation.\n  # +comp+ specifies whether to interpret 2-digit years\n  # as 19XX (>= 69) or 20XX (< 69); the default is not to.\n  # The method will attempt to parse a date-time from the String\n  # using various heuristics; see #_parse in date/format.rb\n  # for more details.  If parsing fails, an ArgumentError\n  # will be raised.\n  #\n  # The default +str+ is '-4712-01-01T00:00:00+00:00'; this is Julian\n  # Day Number day 0.\n  #\n  # +sg+ specifies the Day of Calendar Reform.\n  def self.parse(str='-4712-01-01T00:00:00+00:00', comp=false, sg=ITALY)\n    elem = _parse(str, comp)\n    new_by_frags(elem, sg)\n  end\n\n  public :hour, :min, :sec, :sec_fraction, :zone, :offset, :new_offset\n#\t :minute, :second, :second_fraction\n\n  def to_s # 4p\n    format('%.4d-%02d-%02dT%02d:%02d:%02d%s',\n\t   year, mon, mday, hour, min, sec, zone)\n  end\n\nend\n\nclass Time\n\n#  def to_time() getlocal end\n\n  def to_date\n    jd = Date.civil_to_jd(year, mon, mday, Date::ITALY)\n    Date.new!(Date.jd_to_ajd(jd, 0, 0), 0, Date::ITALY)\n  end\n\n  def to_datetime\n    jd = DateTime.civil_to_jd(year, mon, mday, DateTime::ITALY)\n    fr = DateTime.time_to_day_fraction(hour, min, [sec, 59].min) +\n      Rational(usec, 86400_000_000)\n    of = Rational(utc_offset, 86400)\n    DateTime.new!(DateTime.jd_to_ajd(jd, fr, of), of, DateTime::ITALY)\n  end\n\n  private :to_date, :to_datetime\n\nend\n\nclass Date\n\n=begin\n  def to_time() Time.local(year, mon, mday) end\n  def to_date() self end\n  def to_datetime() DateTime.new!(self.class.jd_to_ajd(jd, 0, 0), @of, @sg) end\n=end\n\n  # Create a new Date object representing today.\n  #\n  # +sg+ specifies the Day of Calendar Reform.\n  def self.today(sg=ITALY)\n    t = Time.now\n    jd = civil_to_jd(t.year, t.mon, t.mday, sg)\n    new!(jd_to_ajd(jd, 0, 0), 0, sg)\n  end\n\n  # Create a new DateTime object representing the current time.\n  #\n  # +sg+ specifies the Day of Calendar Reform.\n  def self.now(sg=ITALY)\n    t = Time.now\n    jd = civil_to_jd(t.year, t.mon, t.mday, sg)\n    fr = time_to_day_fraction(t.hour, t.min, [t.sec, 59].min) +\n      Rational(t.usec, 86400_000_000)\n    of = Rational(t.utc_offset, 86400)\n    new!(jd_to_ajd(jd, fr, of), of, sg)\n  end\n\n  private_class_method :now\n\nend\n\nclass DateTime < Date\n\n=begin\n  def to_time\n    d = new_offset(0)\n    d.instance_eval do\n      Time.utc(year, mon, mday, hour, min, sec,\n\t       (sec_fraction * 86400000000).to_i)\n    end.\n\tgetlocal\n  end\n\n  def to_date() Date.new!(self.class.jd_to_ajd(jd, 0, 0), 0, @sg) end\n  def to_datetime() self end\n=end\n\n  private_class_method :today\n  public_class_method  :now\n\nend\n\nclass Date\n\n  class << self\n\n    def deprecated_class_method_alias(old, new) # :nodoc:\n      module_eval <<-\"end;\"\n\tclass << self\n\t  def #{old}(*args, &block)\n\t    if $VERBOSE\n\t      warn(\"\\#{caller.shift.sub(/:in .*/, '')}: \" \\\n\t\t   \"warning: \\#{self}::#{old} is deprecated; \" \\\n\t\t   \"use \\#{self}::#{new}\")\n\t    end\n\t    #{new}(*arg"..., 4096) = 4096
read(3, "eprecated_alias(old, new) # :nodoc:\n      module_eval <<-\"end;\"\n\tdef #{old}(*args, &block)\n\t  if $VERBOSE\n\t    warn(\"\\#{caller.shift.sub(/:in .*/, '')}: \" \\\n\t\t \"warning: \\#{self.class}\\##{old} is deprecated; \" \\\n\t\t \"use \\#{self.class}\\##{new}\")\n\t  end\n\t  #{new}(*args, &block)\n\tend\n      end;\n    end\n\n    private :deprecated_alias\n\n  end\n\n  [ %w(os?\tjulian?),\n    %w(ns?\tgregorian?),\n    %w(exist1?\tvalid_jd?),\n    %w(exist2?\tvalid_ordinal?),\n    %w(exist3?\tvalid_date?),\n    %w(exist?\tvalid_date?),\n    %w(existw?\tvalid_commercial?),\n    %w(new0\tnew!),\n    %w(new1\tjd),\n    %w(new2\tordinal),\n    %w(new3\tnew),\n    %w(neww\tcommercial)\n  ].each do |old, new|\n    deprecated_class_method_alias(old, new)\n  end\n\n  [ %w(os?\tjulian?),\n    %w(ns?\tgregorian?),\n    %w(sg\tstart),\n    %w(newsg\tnew_start),\n    %w(of\toffset),\n    %w(newof\tnew_offset)\n  ].each do |old, new|\n    deprecated_alias(old, new)\n  end\n\n  private :of, :newof\n\nend\n\nclass DateTime < Date\n\n  public :of, :newof\n\nend\n", 4096) = 980
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rational.rb", 0xbfe50ea0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rational.so", 0xbfe50ea0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/rational.rb", 0xbfe50ea0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/rational.so", 0xbfe50ea0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/rational.rb", 0xbfe50ea0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/rational.so", 0xbfe50ea0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/rational.rb", 0xbfe50ea0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/rational.so", 0xbfe50ea0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/rational.rb", 0xbfe50ea0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/rational.so", 0xbfe50ea0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/rational.rb", 0xbfe50ea0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/rational.so", 0xbfe50ea0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/rational.rb", 0xbfe50ea0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/rational.so", 0xbfe50ea0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/rational.rb", {st_mode=S_IFREG|0644, st_size=12343, ...}) = 0
open("/usr/lib/ruby/1.8/rational.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=12343, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/rational.rb", 0xbfe50eb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/rational.rb", 0xbfe50eb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/rational.rb", 0xbfe50eb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/rational.rb", 0xbfe50eb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/rational.rb", 0xbfe50eb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/rational.rb", 0xbfe50eb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/rational.rb", 0xbfe50eb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/rational.rb", {st_mode=S_IFREG|0644, st_size=12343, ...}) = 0
open("/usr/lib/ruby/1.8/rational.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=12343, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/rational.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=12343, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/rational.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/rational.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=12343, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "#\n#   rational.rb -\n#       $Release Version: 0.5 $\n#       $Revision: 1.7 $\n#       $Date: 1999/08/24 12:49:28 $\n#       by Keiju ISHITSUKA(SHL Japan Inc.)\n#\n# Documentation by Kevin Jackson and Gavin Sinclair.\n# \n# When you <tt>require 'rational'</tt>, all interactions between numbers\n# potentially return a rational result.  For example:\n#\n#   1.quo(2)              # -> 0.5\n#   require 'rational'\n#   1.quo(2)              # -> Rational(1,2)\n# \n# See Rational for full documentation.\n#\n\n\n#\n# Creates a Rational number (i.e. a fraction).  +a+ and +b+ should be Integers:\n# \n#   Rational(1,3)           # -> 1/3\n#\n# Note: trying to construct a Rational with floating point or real values\n# produces errors:\n#\n#   Rational(1.1, 2.3)      # -> NoMethodError\n#\ndef Rational(a, b = 1)\n  if a.kind_of?(Rational) && b == 1\n    a\n  else\n    Rational.reduce(a, b)\n  end\nend\n\n#\n# Rational implements a rational class for numbers.\n#\n# <em>A rational number is a number that can be expressed as a fraction p/q\n# where p and q are integers and q != 0.  A rational number p/q is said to have\n# numerator p and denominator q.  Numbers that are not rational are called\n# irrational numbers.</em> (http://mathworld.wolfram.com/RationalNumber.html)\n#\n# To create a Rational Number:\n#   Rational(a,b)             # -> a/b\n#   Rational.new!(a,b)        # -> a/b\n#\n# Examples:\n#   Rational(5,6)             # -> 5/6\n#   Rational(5)               # -> 5/1\n# \n# Rational numbers are reduced to their lowest terms:\n#   Rational(6,10)            # -> 3/5\n#\n# But not if you use the unusual method \"new!\":\n#   Rational.new!(6,10)       # -> 6/10\n#\n# Division by zero is obviously not allowed:\n#   Rational(3,0)             # -> ZeroDivisionError\n#\nclass Rational < Numeric\n  @RCS_ID='-$Id: rational.rb,v 1.7 1999/08/24 12:49:28 keiju Exp keiju $-'\n\n  #\n  # Reduces the given numerator and denominator to their lowest terms.  Use\n  # Rational() instead.\n  #\n  def Rational.reduce(num, den = 1)\n    raise ZeroDivisionError, \"denominator is zero\" if den == 0\n\n    if den < 0\n      num = -num\n      den = -den\n    end\n    gcd = num.gcd(den)\n    num = num.div(gcd)\n    den = den.div(gcd)\n    if den == 1 && defined?(Unify)\n      num\n    else\n      new!(num, den)\n    end\n  end\n\n  #\n  # Implements the constructor.  This method does not reduce to lowest terms or\n  # check for division by zero.  Therefore #Rational() should be preferred in\n  # normal use.\n  #\n  def Rational.new!(num, den = 1)\n    new(num, den)\n  end\n\n  private_class_method :new\n\n  #\n  # This method is actually private.\n  #\n  def initialize(num, den)\n    if den < 0\n      num = -num\n      den = -den\n    end\n    if num.kind_of?(Integer) and den.kind_of?(Integer)\n      @numerator = num\n      @denominator = den\n    else\n      @numerator = num.to_i\n      @denominator = den.to_i\n    end\n  end\n\n  #\n  # Returns the addition of this value and +a+.\n  #\n  # Examples:\n  #   r = Rational(3,4)      # -> Rational(3,4)\n  #   r + 1                  # -> Rational(7,4)\n  #   r + 0.5                # -> 1.25\n  #\n  def + (a)\n    if a.kind_of?(Rational)\n      num = @numerator * a.denominator\n      num_a = a.numerator * @denominator\n      Rational(num + num_a, @denominator * a.denominator)\n    elsif a.kind_of?(Integer)\n      self + Rational.new!(a, 1)\n    elsif a.kind_of?(Float)\n      Float(self) + a\n    else\n      x, y = a.coerce(self)\n      x + y\n    end\n  end\n\n  #\n  # Returns the difference of this value and +a+.\n  # subtracted.\n  #\n  # Examples:\n  #   r = Rational(3,4)    # -> Rational(3,4)\n  #   r - 1                # -> Rational(-1,4)\n  #   r - 0.5              # -> 0.25\n  #\n  def - (a)\n    if a.kind_of?(Rational)\n      num = @numerator * a.denominator\n      num_a = a.numerator * @denominator\n      Rational(num - num_a, @denominator*a.denominator)\n    elsif a.kind_of?(Integer)\n      self - Rational.new!(a, 1)\n    elsif a.kind_of?(Float)\n      Float(self) - a\n    else\n      x, y = a.coerce(self)\n      x - y\n    end\n  end\n\n  #\n  # Returns the produc"..., 4096) = 4096
read(3, " * 2                # -> Rational(3,2)\n  #   r * 4                # -> Rational(3,1)\n  #   r * 0.5              # -> 0.375\n  #   r * Rational(1,2)    # -> Rational(3,8)\n  #\n  def * (a)\n    if a.kind_of?(Rational)\n      num = @numerator * a.numerator\n      den = @denominator * a.denominator\n      Rational(num, den)\n    elsif a.kind_of?(Integer)\n      self * Rational.new!(a, 1)\n    elsif a.kind_of?(Float)\n      Float(self) * a\n    else\n      x, y = a.coerce(self)\n      x * y\n    end\n  end\n\n  #\n  # Returns the quotient of this value and +a+.\n  #   r = Rational(3,4)    # -> Rational(3,4)\n  #   r / 2                # -> Rational(3,8)\n  #   r / 2.0              # -> 0.375\n  #   r / Rational(1,2)    # -> Rational(3,2)\n  #\n  def / (a)\n    if a.kind_of?(Rational)\n      num = @numerator * a.denominator\n      den = @denominator * a.numerator\n      Rational(num, den)\n    elsif a.kind_of?(Integer)\n      raise ZeroDivisionError, \"division by zero\" if a == 0\n      self / Rational.new!(a, 1)\n    elsif a.kind_of?(Float)\n      Float(self) / a\n    else\n      x, y = a.coerce(self)\n      x / y\n    end\n  end\n\n  #\n  # Returns this value raised to the given power.\n  #\n  # Examples:\n  #   r = Rational(3,4)    # -> Rational(3,4)\n  #   r ** 2               # -> Rational(9,16)\n  #   r ** 2.0             # -> 0.5625\n  #   r ** Rational(1,2)   # -> 0.866025403784439\n  #\n  def ** (other)\n    if other.kind_of?(Rational)\n      Float(self) ** other\n    elsif other.kind_of?(Integer)\n      if other > 0\n\tnum = @numerator ** other\n\tden = @denominator ** other\n      elsif other < 0\n\tnum = @denominator ** -other\n\tden = @numerator ** -other\n      elsif other == 0\n\tnum = 1\n\tden = 1\n      end\n      Rational.new!(num, den)\n    elsif other.kind_of?(Float)\n      Float(self) ** other\n    else\n      x, y = other.coerce(self)\n      x ** y\n    end\n  end\n\n  def div(other)\n    (self / other).floor\n  end\n\n  #\n  # Returns the remainder when this value is divided by +other+.\n  #\n  # Examples:\n  #   r = Rational(7,4)    # -> Rational(7,4)\n  #   r % Rational(1,2)    # -> Rational(1,4)\n  #   r % 1                # -> Rational(3,4)\n  #   r % Rational(1,7)    # -> Rational(1,28)\n  #   r % 0.26             # -> 0.19\n  #\n  def % (other)\n    value = (self / other).floor\n    return self - other * value\n  end\n\n  #\n  # Returns the quotient _and_ remainder.\n  #\n  # Examples:\n  #   r = Rational(7,4)        # -> Rational(7,4)\n  #   r.divmod Rational(1,2)   # -> [3, Rational(1,4)]\n  #\n  def divmod(other)\n    value = (self / other).floor\n    return value, self - other * value\n  end\n\n  #\n  # Returns the absolute value.\n  #\n  def abs\n    if @numerator > 0\n      self\n    else\n      Rational.new!(-@numerator, @denominator)\n    end\n  end\n\n  #\n  # Returns +true+ iff this value is numerically equal to +other+.\n  #\n  # But beware:\n  #   Rational(1,2) == Rational(4,8)          # -> true\n  #   Rational(1,2) == Rational.new!(4,8)     # -> false\n  #\n  # Don't use Rational.new!\n  #\n  def == (other)\n    if other.kind_of?(Rational)\n      @numerator == other.numerator and @denominator == other.denominator\n    elsif other.kind_of?(Integer)\n      self == Rational.new!(other, 1)\n    elsif other.kind_of?(Float)\n      Float(self) == other\n    else\n      other == self\n    end\n  end\n\n  #\n  # Standard comparison operator.\n  #\n  def <=> (other)\n    if other.kind_of?(Rational)\n      num = @numerator * other.denominator\n      num_a = other.numerator * @denominator\n      v = num - num_a\n      if v > 0\n\treturn 1\n      elsif v < 0\n\treturn  -1\n      else\n\treturn 0\n      end\n    elsif other.kind_of?(Integer)\n      return self <=> Rational.new!(other, 1)\n    elsif other.kind_of?(Float)\n      return Float(self) <=> other\n    elsif defined? other.coerce\n      x, y = other.coerce(self)\n      return x <=> y\n    else\n      return nil\n    end\n  end\n\n  def coerce(other)\n    if other.kind_of?(Float)\n      return other, self.to_f\n    elsif other.kind_of?(Integer)\n      return Rational.new!(other, 1), self\n    else\n      super\n    end\n  e"..., 4096) = 4096
read(3, "nteger.  Study the following example carefully:\n  #   Rational(+7,4).to_i             # -> 1\n  #   Rational(-7,4).to_i             # -> -1\n  #   (-1.75).to_i                    # -> -1\n  #\n  # In other words:\n  #   Rational(-7,4) == -1.75                 # -> true\n  #   Rational(-7,4).to_i == (-1.75).to_i     # -> true\n  #\n\n\n  def floor()\n    @numerator.div(@denominator)\n  end\n\n  def ceil()\n    -((-@numerator).div(@denominator))\n  end\n\n  def truncate()\n    if @numerator < 0\n      return -((-@numerator).div(@denominator))\n    end\n    @numerator.div(@denominator)\n  end\n\n  alias_method :to_i, :truncate\n\n  def round()\n    if @numerator < 0\n      num = -@numerator\n      num = num * 2 + @denominator\n      den = @denominator * 2\n      -(num.div(den))\n    else\n      num = @numerator * 2 + @denominator\n      den = @denominator * 2\n      num.div(den)\n    end\n  end\n\n  #\n  # Converts the rational to a Float.\n  #\n  def to_f\n    @numerator.to_f/@denominator.to_f\n  end\n\n  #\n  # Returns a string representation of the rational number.\n  #\n  # Example:\n  #   Rational(3,4).to_s          #  \"3/4\"\n  #   Rational(8).to_s            #  \"8\"\n  #\n  def to_s\n    if @denominator == 1\n      @numerator.to_s\n    else\n      @numerator.to_s+\"/\"+@denominator.to_s\n    end\n  end\n\n  #\n  # Returns +self+.\n  #\n  def to_r\n    self\n  end\n\n  #\n  # Returns a reconstructable string representation:\n  #\n  #   Rational(5,8).inspect     # -> \"Rational(5, 8)\"\n  #\n  def inspect\n    sprintf(\"Rational(%s, %s)\", @numerator.inspect, @denominator.inspect)\n  end\n\n  #\n  # Returns a hash code for the object.\n  #\n  def hash\n    @numerator.hash ^ @denominator.hash\n  end\n\n  attr :numerator\n  attr :denominator\n\n  private :initialize\nend\n\nclass Integer\n  #\n  # In an integer, the value _is_ the numerator of its rational equivalent.\n  # Therefore, this method returns +self+.\n  #\n  def numerator\n    self\n  end\n\n  #\n  # In an integer, the denominator is 1.  Therefore, this method returns 1.\n  #\n  def denominator\n    1\n  end\n\n  #\n  # Returns a Rational representation of this integer.\n  #\n  def to_r\n    Rational(self, 1)\n  end\n\n  #\n  # Returns the <em>greatest common denominator</em> of the two numbers (+self+\n  # and +n+).\n  #\n  # Examples:\n  #   72.gcd 168           # -> 24\n  #   19.gcd 36            # -> 1\n  #\n  # The result is positive, no matter the sign of the arguments.\n  #\n  def gcd(other)\n    min = self.abs\n    max = other.abs\n    while min > 0\n      tmp = min\n      min = max % min\n      max = tmp\n    end\n    max\n  end\n\n  #\n  # Returns the <em>lowest common multiple</em> (LCM) of the two arguments\n  # (+self+ and +other+).\n  #\n  # Examples:\n  #   6.lcm 7        # -> 42\n  #   6.lcm 9        # -> 18\n  #\n  def lcm(other)\n    if self.zero? or other.zero?\n      0\n    else\n      (self.div(self.gcd(other)) * other).abs\n    end\n  end\n\n  #\n  # Returns the GCD _and_ the LCM (see #gcd and #lcm) of the two arguments\n  # (+self+ and +other+).  This is more efficient than calculating them\n  # separately.\n  #\n  # Example:\n  #   6.gcdlcm 9     # -> [3, 18]\n  #\n  def gcdlcm(other)\n    gcd = self.gcd(other)\n    if self.zero? or other.zero?\n      [gcd, 0]\n    else\n      [gcd, (self.div(gcd) * other).abs]\n    end\n  end\nend\n\nclass Fixnum\n  remove_method :quo\n\n  # If Rational is defined, returns a Rational number instead of a Float.\n  def quo(other)\n    Rational.new!(self, 1) / other\n  end\n  alias rdiv quo\n\n  # Returns a Rational number if the result is in fact rational (i.e. +other+ < 0).\n  def rpower (other)\n    if other >= 0\n      self.power!(other)\n    else\n      Rational.new!(self, 1)**other\n    end\n  end\n\nend\n\nclass Bignum\n  remove_method :quo\n\n  # If Rational is defined, returns a Rational number instead of a Float.\n  def quo(other)\n    Rational.new!(self, 1) / other\n  end\n  alias rdiv quo\n\n  # Returns a Rational number if the result is in fact rational (i.e. +other+ < 0).\n  def rpower (other)\n    if other >= 0\n      self.power!(other)\n    else\n      Rational.new!(self, 1)**other\n    end\n  end\n\nend\n\n"..., 4096) = 4096
read(3, "gnum\n    alias power! **\n    alias ** rpower\n  end\nend\n", 4096) = 55
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/date/format.rb", 0xbfe50e80) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/date/format.so", 0xbfe50e80) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/date/format.rb", 0xbfe50e80) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/date/format.so", 0xbfe50e80) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/date/format.rb", 0xbfe50e80) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/date/format.so", 0xbfe50e80) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/date/format.rb", 0xbfe50e80) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/date/format.so", 0xbfe50e80) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/date/format.rb", 0xbfe50e80) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/date/format.so", 0xbfe50e80) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/date/format.rb", 0xbfe50e80) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/date/format.so", 0xbfe50e80) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/date/format.rb", 0xbfe50e80) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/date/format.so", 0xbfe50e80) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/date/format.rb", {st_mode=S_IFREG|0644, st_size=29191, ...}) = 0
open("/usr/lib/ruby/1.8/date/format.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=29191, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/date/format.rb", 0xbfe50e90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/date/format.rb", 0xbfe50e90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/date/format.rb", 0xbfe50e90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/date/format.rb", 0xbfe50e90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/date/format.rb", 0xbfe50e90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/date/format.rb", 0xbfe50e90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/date/format.rb", 0xbfe50e90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/date/format.rb", {st_mode=S_IFREG|0644, st_size=29191, ...}) = 0
open("/usr/lib/ruby/1.8/date/format.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=29191, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/date/format.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=29191, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/date/format.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/date/format.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=29191, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "# format.rb: Written by Tadayoshi Funaba 1999-2008\n# $Id: format.rb,v 2.43 2008-01-17 20:16:31+09 tadf Exp $\n\nrequire 'rational'\n\nclass Date\n\n  module Format # :nodoc:\n\n    MONTHS = {\n      'january'  => 1, 'february' => 2, 'march'    => 3, 'april'    => 4,\n      'may'      => 5, 'june'     => 6, 'july'     => 7, 'august'   => 8,\n      'september'=> 9, 'october'  =>10, 'november' =>11, 'december' =>12\n    }\n\n    DAYS = {\n      'sunday'   => 0, 'monday'   => 1, 'tuesday'  => 2, 'wednesday'=> 3,\n      'thursday' => 4, 'friday'   => 5, 'saturday' => 6\n    }\n\n    ABBR_MONTHS = {\n      'jan'      => 1, 'feb'      => 2, 'mar'      => 3, 'apr'      => 4,\n      'may'      => 5, 'jun'      => 6, 'jul'      => 7, 'aug'      => 8,\n      'sep'      => 9, 'oct'      =>10, 'nov'      =>11, 'dec'      =>12\n    }\n\n    ABBR_DAYS = {\n      'sun'      => 0, 'mon'      => 1, 'tue'      => 2, 'wed'      => 3,\n      'thu'      => 4, 'fri'      => 5, 'sat'      => 6\n    }\n\n    ZONES = {\n      'ut'  =>  0*3600, 'gmt' =>  0*3600, 'est' => -5*3600, 'edt' => -4*3600,\n      'cst' => -6*3600, 'cdt' => -5*3600, 'mst' => -7*3600, 'mdt' => -6*3600,\n      'pst' => -8*3600, 'pdt' => -7*3600,\n      'a'   =>  1*3600, 'b'   =>  2*3600, 'c'   =>  3*3600, 'd'   =>  4*3600,\n      'e'   =>  5*3600, 'f'   =>  6*3600, 'g'   =>  7*3600, 'h'   =>  8*3600,\n      'i'   =>  9*3600, 'k'   => 10*3600, 'l'   => 11*3600, 'm'   => 12*3600,\n      'n'   => -1*3600, 'o'   => -2*3600, 'p'   => -3*3600, 'q'   => -4*3600,\n      'r'   => -5*3600, 's'   => -6*3600, 't'   => -7*3600, 'u'   => -8*3600,\n      'v'   => -9*3600, 'w'   =>-10*3600, 'x'   =>-11*3600, 'y'   =>-12*3600,\n      'z'   =>  0*3600,\n\n      'utc' =>  0*3600, 'wet' =>  0*3600,\n      'at'  => -2*3600, 'brst'=> -2*3600, 'ndt' => -(2*3600+1800),\n      'art' => -3*3600, 'adt' => -3*3600, 'brt' => -3*3600, 'clst'=> -3*3600,\n      'nst' => -(3*3600+1800),\n      'ast' => -4*3600, 'clt' => -4*3600,\n      'akdt'=> -8*3600, 'ydt' => -8*3600,\n      'akst'=> -9*3600, 'hadt'=> -9*3600, 'hdt' => -9*3600, 'yst' => -9*3600,\n      'ahst'=>-10*3600, 'cat' =>-10*3600, 'hast'=>-10*3600, 'hst' =>-10*3600,\n      'nt'  =>-11*3600,\n      'idlw'=>-12*3600,\n      'bst' =>  1*3600, 'cet' =>  1*3600, 'fwt' =>  1*3600, 'met' =>  1*3600,\n      'mewt'=>  1*3600, 'mez' =>  1*3600, 'swt' =>  1*3600, 'wat' =>  1*3600,\n      'west'=>  1*3600,\n      'cest'=>  2*3600, 'eet' =>  2*3600, 'fst' =>  2*3600, 'mest'=>  2*3600,\n      'mesz'=>  2*3600, 'sast'=>  2*3600, 'sst' =>  2*3600,\n      'bt'  =>  3*3600, 'eat' =>  3*3600, 'eest'=>  3*3600, 'msk' =>  3*3600,\n      'msd' =>  4*3600, 'zp4' =>  4*3600,\n      'zp5' =>  5*3600, 'ist' =>  (5*3600+1800),\n      'zp6' =>  6*3600,\n      'wast'=>  7*3600,\n      'cct' =>  8*3600, 'sgt' =>  8*3600, 'wadt'=>  8*3600,\n      'jst' =>  9*3600, 'kst' =>  9*3600,\n      'east'=> 10*3600, 'gst' => 10*3600,\n      'eadt'=> 11*3600,\n      'idle'=> 12*3600, 'nzst'=> 12*3600, 'nzt' => 12*3600,\n      'nzdt'=> 13*3600,\n\n      'afghanistan'           =>   16200, 'alaskan'               =>  -32400,\n      'arab'                  =>   10800, 'arabian'               =>   14400,\n      'arabic'                =>   10800, 'atlantic'              =>  -14400,\n      'aus central'           =>   34200, 'aus eastern'           =>   36000,\n      'azores'                =>   -3600, 'canada central'        =>  -21600,\n      'cape verde'            =>   -3600, 'caucasus'              =>   14400,\n      'cen. australia'        =>   34200, 'central america'       =>  -21600,\n      'central asia'          =>   21600, 'central europe'        =>    3600,\n      'central european'      =>    3600, 'central pacific'       =>   39600,\n      'central'               =>  -21600, 'china'                 =>   28800,\n      'dateline'              =>  -43200, 'e. africa'             =>   10800,\n      'e. australia'          =>   36000, 'e. europe'             =>    7200,\n      'e. south america'      =>  -10800, 'eastern'               =>  -18000,\n      'egypt'         "..., 4096) = 4096
read(3, ", 'fle'                   =>    7200,\n      'greenland'             =>  -10800, 'greenwich'             =>       0,\n      'gtb'                   =>    7200, 'hawaiian'              =>  -36000,\n      'india'                 =>   19800, 'iran'                  =>   12600,\n      'jerusalem'             =>    7200, 'korea'                 =>   32400,\n      'mexico'                =>  -21600, 'mid-atlantic'          =>   -7200,\n      'mountain'              =>  -25200, 'myanmar'               =>   23400,\n      'n. central asia'       =>   21600, 'nepal'                 =>   20700,\n      'new zealand'           =>   43200, 'newfoundland'          =>  -12600,\n      'north asia east'       =>   28800, 'north asia'            =>   25200,\n      'pacific sa'            =>  -14400, 'pacific'               =>  -28800,\n      'romance'               =>    3600, 'russian'               =>   10800,\n      'sa eastern'            =>  -10800, 'sa pacific'            =>  -18000,\n      'sa western'            =>  -14400, 'samoa'                 =>  -39600,\n      'se asia'               =>   25200, 'malay peninsula'       =>   28800,\n      'south africa'          =>    7200, 'sri lanka'             =>   21600,\n      'taipei'                =>   28800, 'tasmania'              =>   36000,\n      'tokyo'                 =>   32400, 'tonga'                 =>   46800,\n      'us eastern'            =>  -18000, 'us mountain'           =>  -25200,\n      'vladivostok'           =>   36000, 'w. australia'          =>   28800,\n      'w. central africa'     =>    3600, 'w. europe'             =>    3600,\n      'west asia'             =>   18000, 'west pacific'          =>   36000,\n      'yakutsk'               =>   32400\n    }\n\n    [MONTHS, DAYS, ABBR_MONTHS, ABBR_DAYS, ZONES].each do |x|\n      x.freeze\n    end\n\n    class Bag # :nodoc:\n\n      def initialize\n\t@elem = {}\n      end\n\n      def method_missing(t, *args, &block)\n\tt = t.to_s\n\tset = t.chomp!('=')\n\tt = t.intern\n\tif set\n\t  @elem[t] = args[0]\n\telse\n\t  @elem[t]\n\tend\n      end\n\n      def to_hash\n\t@elem.reject{|k, v| /\\A_/ =~ k.to_s || v.nil?}\n      end\n\n    end\n\n  end\n\n  def emit(e, f) # :nodoc:\n    case e\n    when Numeric\n      sign = %w(+ + -)[e <=> 0]\n      e = e.abs\n    end\n\n    s = e.to_s\n\n    if f[:s] && f[:p] == '0'\n      f[:w] -= 1\n    end\n\n    if f[:s] && f[:p] == \"\\s\"\n      s[0,0] = sign\n    end\n\n    if f[:p] != '-'\n      s = s.rjust(f[:w], f[:p])\n    end\n\n    if f[:s] && f[:p] != \"\\s\"\n      s[0,0] = sign\n    end\n\n    s = s.upcase if f[:u]\n    s = s.downcase if f[:d]\n    s\n  end\n\n  def emit_w(e, w, f) # :nodoc:\n    f[:w] = [f[:w], w].compact.max\n    emit(e, f)\n  end\n\n  def emit_n(e, w, f) # :nodoc:\n    f[:p] ||= '0'\n    emit_w(e, w, f)\n  end\n\n  def emit_sn(e, w, f) # :nodoc:\n    if e < 0\n      w += 1\n      f[:s] = true\n    end\n    emit_n(e, w, f)\n  end\n\n  def emit_z(e, w, f) # :nodoc:\n    w += 1\n    f[:s] = true\n    emit_n(e, w, f)\n  end\n\n  def emit_a(e, w, f) # :nodoc:\n    f[:p] ||= \"\\s\"\n    emit_w(e, w, f)\n  end\n\n  def emit_ad(e, w, f) # :nodoc:\n    if f[:x]\n      f[:u] = true\n      f[:d] = false\n    end\n    emit_a(e, w, f)\n  end\n\n  def emit_au(e, w, f) # :nodoc:\n    if f[:x]\n      f[:u] = false\n      f[:d] = true\n    end\n    emit_a(e, w, f)\n  end\n\n  private :emit, :emit_w, :emit_n, :emit_sn, :emit_z,\n\t  :emit_a, :emit_ad, :emit_au\n\n  def strftime(fmt='%F')\n    fmt.gsub(/%([-_0^#]+)?(\\d+)?([EO]?(?::{1,3}z|.))/m) do |m|\n      f = {}\n      a = $&\n      s, w, c = $1, $2, $3\n      if s\n\ts.scan(/./) do |k|\n\t  case k\n\t  when '-'; f[:p] = '-'\n\t  when '_'; f[:p] = \"\\s\"\n\t  when '0'; f[:p] = '0'\n\t  when '^'; f[:u] = true\n\t  when '#'; f[:x] = true\n\t  end\n\tend\n      end\n      if w\n\tf[:w] = w.to_i\n      end\n      case c\n      when 'A'; emit_ad(DAYNAMES[wday], 0, f)\n      when 'a'; emit_ad(ABBR_DAYNAMES[wday], 0, f)\n      when 'B'; emit_ad(MONTHNAMES[mon], 0, f)\n      when 'b'; emit_ad(ABBR_MONTHNAMES[mon], 0, f)\n      when 'C', 'EC'; emit_sn((year / 100).floor, 2, f)\n      when 'c', 'Ec'; emit_a(strftime('%a"..., 4096) = 4096
read(3, "Od'; emit_n(mday, 2, f)\n      when 'e', 'Oe'; emit_a(mday, 2, f)\n      when 'F'\n\tif m == '%F'\n\t  format('%.4d-%02d-%02d', year, mon, mday) # 4p\n\telse\n\t  emit_a(strftime('%Y-%m-%d'), 0, f)\n\tend\n      when 'G'; emit_sn(cwyear, 4, f)\n      when 'g'; emit_n(cwyear % 100, 2, f)\n      when 'H', 'OH'; emit_n(hour, 2, f)\n      when 'h'; emit_ad(strftime('%b'), 0, f)\n      when 'I', 'OI'; emit_n((hour % 12).nonzero? || 12, 2, f)\n      when 'j'; emit_n(yday, 3, f)\n      when 'k'; emit_a(hour, 2, f)\n      when 'L'\n\temit_n((sec_fraction / MILLISECONDS_IN_DAY).floor, 3, f)\n      when 'l'; emit_a((hour % 12).nonzero? || 12, 2, f)\n      when 'M', 'OM'; emit_n(min, 2, f)\n      when 'm', 'Om'; emit_n(mon, 2, f)\n      when 'N'\n\temit_n((sec_fraction / NANOSECONDS_IN_DAY).floor, 9, f)\n      when 'n'; \"\\n\"\n      when 'P'; emit_ad(strftime('%p').downcase, 0, f)\n      when 'p'; emit_au(if hour < 12 then 'AM' else 'PM' end, 0, f)\n      when 'Q'\n\ts = ((ajd - UNIX_EPOCH_IN_AJD) / MILLISECONDS_IN_DAY).round\n\temit_sn(s, 1, f)\n      when 'R'; emit_a(strftime('%H:%M'), 0, f)\n      when 'r'; emit_a(strftime('%I:%M:%S %p'), 0, f)\n      when 'S', 'OS'; emit_n(sec, 2, f)\n      when 's'\n\ts = ((ajd - UNIX_EPOCH_IN_AJD) / SECONDS_IN_DAY).round\n\temit_sn(s, 1, f)\n      when 'T'\n\tif m == '%T'\n\t  format('%02d:%02d:%02d', hour, min, sec) # 4p\n\telse\n\t  emit_a(strftime('%H:%M:%S'), 0, f)\n\tend\n      when 't'; \"\\t\"\n      when 'U', 'W', 'OU', 'OW'\n\temit_n(if c[-1,1] == 'U' then wnum0 else wnum1 end, 2, f)\n      when 'u', 'Ou'; emit_n(cwday, 1, f)\n      when 'V', 'OV'; emit_n(cweek, 2, f)\n      when 'v'; emit_a(strftime('%e-%b-%Y'), 0, f)\n      when 'w', 'Ow'; emit_n(wday, 1, f)\n      when 'X', 'EX'; emit_a(strftime('%H:%M:%S'), 0, f)\n      when 'x', 'Ex'; emit_a(strftime('%m/%d/%y'), 0, f)\n      when 'Y', 'EY'; emit_sn(year, 4, f)\n      when 'y', 'Ey', 'Oy'; emit_n(year % 100, 2, f)\n      when 'Z'; emit_au(strftime('%:z'), 0, f)\n      when /\\A(:{0,3})z/\n\tt = $1.size\n\tsign = if offset < 0 then -1 else +1 end\n\tfr = offset.abs\n\tss = fr.div(SECONDS_IN_DAY) # 4p\n\thh, ss = ss.divmod(3600)\n\tmm, ss = ss.divmod(60)\n\tif t == 3\n\t  if    ss.nonzero? then t =  2\n\t  elsif mm.nonzero? then t =  1\n\t  else                   t = -1\n\t  end\n\tend\n\tcase t\n\twhen -1\n\t  tail = []\n\t  sep = ''\n\twhen 0\n\t  f[:w] -= 2 if f[:w]\n\t  tail = ['%02d' % mm]\n\t  sep = ''\n\twhen 1\n\t  f[:w] -= 3 if f[:w]\n\t  tail = ['%02d' % mm]\n\t  sep = ':'\n\twhen 2\n\t  f[:w] -= 6 if f[:w]\n\t  tail = ['%02d' % mm, '%02d' % ss]\n\t  sep = ':'\n\tend\n\t([emit_z(sign * hh, 2, f)] + tail).join(sep)\n      when '%'; emit_a('%', 0, f)\n      when '+'; emit_a(strftime('%a %b %e %H:%M:%S %Z %Y'), 0, f)\n      when '1'\n\tif $VERBOSE\n\t  warn(\"warning: strftime: %1 is deprecated; forget this\")\n\tend\n\temit_n(jd, 1, f)\n      when '2'\n\tif $VERBOSE\n\t  warn(\"warning: strftime: %2 is deprecated; use '%Y-%j'\")\n\tend\n\temit_a(strftime('%Y-%j'), 0, f)\n      when '3'\n\tif $VERBOSE\n\t  warn(\"warning: strftime: %3 is deprecated; use '%F'\")\n\tend\n\temit_a(strftime('%F'), 0, f)\n      else\n\ta\n      end\n    end\n  end\n\n# alias_method :format, :strftime\n\n  def asctime() strftime('%c') end\n\n  alias_method :ctime, :asctime\n\n=begin\n  def iso8601() strftime('%F') end\n\n  def rfc3339() iso8601 end\n\n  def rfc2822() strftime('%a, %-d %b %Y %T %z') end\n\n  alias_method :rfc822, :rfc2822\n\n  def jisx0301\n    if jd < 2405160\n      iso8601\n    else\n      case jd\n      when 2405160...2419614\n\tg = 'M%02d' % (year - 1867)\n      when 2419614...2424875\n\tg = 'T%02d' % (year - 1911)\n      when 2424875...2447535\n\tg = 'S%02d' % (year - 1925)\n      else\n\tg = 'H%02d' % (year - 1988)\n      end\n      g + strftime('.%m.%d')\n    end\n  end\n\n  def beat(n=0)\n    i, f = (new_offset(HOURS_IN_DAY).day_fraction * 1000).divmod(1)\n    ('@%03d' % i) +\n      if n < 1\n\t''\n      else\n\t'.%0*d' % [n, (f / Rational(1, 10**n)).round]\n      end\n  end\n=end\n\n  def self.num_pattern? (s) # :nodoc:\n    /\\A%[EO]?[CDdeFGgHIjkLlMmNQRrSsTUuVvWwXxYy\\d]/ =~ s || /\\A\\d/ =~ s\n  end\n\n  private_class_method :num_pattern?\n\n  def self._strp"..., 4096) = 4096
read(3, "      if s\n\tcase s\n\twhen 'A', 'a'\n\t  return unless str.sub!(/\\A(#{Format::DAYS.keys.join('|')})/io, '') ||\n\t\t\tstr.sub!(/\\A(#{Format::ABBR_DAYS.keys.join('|')})/io, '')\n\t  val = Format::DAYS[$1.downcase] || Format::ABBR_DAYS[$1.downcase]\n\t  return unless val\n\t  e.wday = val\n\twhen 'B', 'b', 'h'\n\t  return unless str.sub!(/\\A(#{Format::MONTHS.keys.join('|')})/io, '') ||\n\t\t\tstr.sub!(/\\A(#{Format::ABBR_MONTHS.keys.join('|')})/io, '')\n\t  val = Format::MONTHS[$1.downcase] || Format::ABBR_MONTHS[$1.downcase]\n\t  return unless val\n\t  e.mon = val\n\twhen 'C', 'EC'\n\t  return unless str.sub!(if num_pattern?($')\n\t\t\t\t then /\\A([-+]?\\d{1,2})/\n\t\t\t\t else /\\A([-+]?\\d{1,})/\n\t\t\t\t end, '')\n\t  val = $1.to_i\n\t  e._cent = val\n\twhen 'c', 'Ec'\n\t  return unless _strptime_i(str, '%a %b %e %H:%M:%S %Y', e)\n\twhen 'D'\n\t  return unless _strptime_i(str, '%m/%d/%y', e)\n\twhen 'd', 'e', 'Od', 'Oe'\n\t  return unless str.sub!(/\\A( \\d|\\d{1,2})/, '')\n\t  val = $1.to_i\n\t  return unless (1..31) === val\n\t  e.mday = val\n\twhen 'F'\n\t  return unless _strptime_i(str, '%Y-%m-%d', e)\n\twhen 'G'\n\t  return unless str.sub!(if num_pattern?($')\n\t\t\t\t then /\\A([-+]?\\d{1,4})/\n\t\t\t\t else /\\A([-+]?\\d{1,})/\n\t\t\t\t end, '')\n\t  val = $1.to_i\n\t  e.cwyear = val\n\twhen 'g'\n\t  return unless str.sub!(/\\A(\\d{1,2})/, '')\n\t  val = $1.to_i\n\t  return unless (0..99) === val\n\t  e.cwyear = val\n\t  e._cent ||= if val >= 69 then 19 else 20 end\n\twhen 'H', 'k', 'OH'\n\t  return unless str.sub!(/\\A( \\d|\\d{1,2})/, '')\n\t  val = $1.to_i\n\t  return unless (0..24) === val\n\t  e.hour = val\n\twhen 'I', 'l', 'OI'\n\t  return unless str.sub!(/\\A( \\d|\\d{1,2})/, '')\n\t  val = $1.to_i\n\t  return unless (1..12) === val\n\t  e.hour = val\n\twhen 'j'\n\t  return unless str.sub!(/\\A(\\d{1,3})/, '')\n\t  val = $1.to_i\n\t  return unless (1..366) === val\n\t  e.yday = val\n\twhen 'L'\n\t  return unless str.sub!(if num_pattern?($')\n\t\t\t\t then /\\A([-+]?\\d{1,3})/\n\t\t\t\t else /\\A([-+]?\\d{1,})/\n\t\t\t\t end, '')\n#\t  val = Rational($1.to_i, 10**3)\n\t  val = Rational($1.to_i, 10**$1.size)\n\t  e.sec_fraction = val\n\twhen 'M', 'OM'\n\t  return unless str.sub!(/\\A(\\d{1,2})/, '')\n\t  val = $1.to_i\n\t  return unless (0..59) === val\n\t  e.min = val\n\twhen 'm', 'Om'\n\t  return unless str.sub!(/\\A(\\d{1,2})/, '')\n\t  val = $1.to_i\n\t  return unless (1..12) === val\n\t  e.mon = val\n\twhen 'N'\n\t  return unless str.sub!(if num_pattern?($')\n\t\t\t\t then /\\A([-+]?\\d{1,9})/\n\t\t\t\t else /\\A([-+]?\\d{1,})/\n\t\t\t\t end, '')\n#\t  val = Rational($1.to_i, 10**9)\n\t  val = Rational($1.to_i, 10**$1.size)\n\t  e.sec_fraction = val\n\twhen 'n', 't'\n\t  return unless _strptime_i(str, \"\\s\", e)\n\twhen 'P', 'p'\n\t  return unless str.sub!(/\\A([ap])(?:m\\b|\\.m\\.)/i, '')\n\t  e._merid = if $1.downcase == 'a' then 0 else 12 end\n\twhen 'Q'\n\t  return unless str.sub!(/\\A(-?\\d{1,})/, '')\n\t  val = Rational($1.to_i, 10**3)\n\t  e.seconds = val\n\twhen 'R'\n\t  return unless _strptime_i(str, '%H:%M', e)\n\twhen 'r'\n\t  return unless _strptime_i(str, '%I:%M:%S %p', e)\n\twhen 'S', 'OS'\n\t  return unless str.sub!(/\\A(\\d{1,2})/, '')\n\t  val = $1.to_i\n\t  return unless (0..60) === val\n\t  e.sec = val\n\twhen 's'\n\t  return unless str.sub!(/\\A(-?\\d{1,})/, '')\n\t  val = $1.to_i\n\t  e.seconds = val\n\twhen 'T'\n\t  return unless _strptime_i(str, '%H:%M:%S', e)\n\twhen 'U', 'W', 'OU', 'OW'\n\t  return unless str.sub!(/\\A(\\d{1,2})/, '')\n\t  val = $1.to_i\n\t  return unless (0..53) === val\n\t  e.__send__(if s[-1,1] == 'U' then :wnum0= else :wnum1= end, val)\n\twhen 'u', 'Ou'\n\t  return unless str.sub!(/\\A(\\d{1})/, '')\n\t  val = $1.to_i\n\t  return unless (1..7) === val\n\t  e.cwday = val\n\twhen 'V', 'OV'\n\t  return unless str.sub!(/\\A(\\d{1,2})/, '')\n\t  val = $1.to_i\n\t  return unless (1..53) === val\n\t  e.cweek = val\n\twhen 'v'\n\t  return unless _strptime_i(str, '%e-%b-%Y', e)\n\twhen 'w'\n\t  return unless str.sub!(/\\A(\\d{1})/, '')\n\t  val = $1.to_i\n\t  return unless (0..6) === val\n\t  e.wday = val\n\twhen 'X', 'EX'\n\t  return unless _strptime_i(str, '%H:%M:%S', e)\n\twhen 'x', 'Ex'\n\t  return unless _strptime_i(str, '%m/%d/%y', e)\n\twhen 'Y', 'EY'\n\t  return unless str.sub!(if num_pattern?($')\n\t\t\t\t then /\\A([-+]?\\d{1,"..., 4096) = 4096
read(3, " 'Oy'\n\t  return unless str.sub!(/\\A(\\d{1,2})/, '')\n\t  val = $1.to_i\n\t  return unless (0..99) === val\n\t  e.year = val\n\t  e._cent ||= if val >= 69 then 19 else 20 end\n\twhen 'Z', /\\A:{0,3}z/\n\t  return unless str.sub!(/\\A((?:gmt|utc?)?[-+]\\d+(?:[,.:]\\d+(?::\\d+)?)?\n\t\t\t\t    |[[:alpha:].\\s]+(?:standard|daylight)\\s+time\\b\n\t\t\t\t    |[[:alpha:]]+(?:\\s+dst)?\\b\n\t\t\t\t    )/ix, '')\n\t  val = $1\n\t  e.zone = val\n\t  offset = zone_to_diff(val)\n\t  e.offset = offset\n\twhen '%'\n\t  return unless str.sub!(/\\A%/, '')\n\twhen '+'\n\t  return unless _strptime_i(str, '%a %b %e %H:%M:%S %Z %Y', e)\n\twhen '1'\n\t  if $VERBOSE\n\t    warn(\"warning: strptime: %1 is deprecated; forget this\")\n\t  end\n\t  return unless str.sub!(/\\A(\\d+)/, '')\n\t  val = $1.to_i\n\t  e.jd = val\n\twhen '2'\n\t  if $VERBOSE\n\t    warn(\"warning: strptime: %2 is deprecated; use '%Y-%j'\")\n\t  end\n\t  return unless _strptime_i(str, '%Y-%j', e)\n\twhen '3'\n\t  if $VERBOSE\n\t    warn(\"warning: strptime: %3 is deprecated; use '%F'\")\n\t  end\n\t  return unless _strptime_i(str, '%F', e)\n\telse\n\t  return unless str.sub!(Regexp.new('\\\\A' + Regexp.quote(a)), '')\n\tend\n      else\n\tcase c\n\twhen /\\A[\\s\\v]/\n\t  str.sub!(/\\A[\\s\\v]+/, '')\n\telse\n\t  return unless str.sub!(Regexp.new('\\\\A' + Regexp.quote(a)), '')\n\tend\n      end\n    end\n  end\n\n  private_class_method :_strptime_i\n\n  def self._strptime(str, fmt='%F')\n    str = str.dup\n    e = Format::Bag.new\n    return unless _strptime_i(str, fmt, e)\n\n    if e._cent\n      if e.cwyear\n\te.cwyear += e._cent * 100\n      end\n      if e.year\n\te.  year += e._cent * 100\n      end\n    end\n\n    if e._merid\n      if e.hour\n\te.hour %= 12\n\te.hour += e._merid\n      end\n    end\n\n    unless str.empty?\n      e.leftover = str\n    end\n\n    e.to_hash\n  end\n\n  def self.s3e(e, y, m, d, bc=false)\n    unless String === m\n      m = m.to_s\n    end\n\n    if y && m && !d\n      y, m, d = d, y, m\n    end\n\n    if y == nil\n      if d && d.size > 2\n\ty = d\n\td = nil\n      end\n      if d && d[0,1] == \"'\"\n\ty = d\n\td = nil\n      end\n    end\n\n    if y\n      y.scan(/(\\d+)(.+)?/)\n      if $2\n\ty, d = d, $1\n      end\n    end\n\n    if m\n      if m[0,1] == \"'\" || m.size > 2\n\ty, m, d = m, d, y # us -> be\n      end\n    end\n\n    if d\n      if d[0,1] == \"'\" || d.size > 2\n\ty, d = d, y\n      end\n    end\n\n    if y\n      y =~ /([-+])?(\\d+)/\n      if $1 || $2.size > 2\n\tc = false\n      end\n      iy = $&.to_i\n      if bc\n\tiy = -iy + 1\n      end\n      e.year = iy\n    end\n\n    if m\n      m =~ /\\d+/\n      e.mon = $&.to_i\n    end\n\n    if d\n      d =~ /\\d+/\n      e.mday = $&.to_i\n    end\n\n    if c != nil\n      e._comp = c\n    end\n\n  end\n\n  private_class_method :s3e\n\n  def self._parse_day(str, e) # :nodoc:\n    if str.sub!(/\\b(#{Format::ABBR_DAYS.keys.join('|')})[^-\\d\\s]*/ino, ' ')\n      e.wday = Format::ABBR_DAYS[$1.downcase]\n      true\n=begin\n    elsif str.sub!(/\\b(?!\\dth)(su|mo|tu|we|th|fr|sa)\\b/in, ' ')\n      e.wday = %w(su mo tu we th fr sa).index($1.downcase)\n      true\n=end\n    end\n  end\n\n  def self._parse_time(str, e) # :nodoc:\n    if str.sub!(\n\t\t/(\n\t\t   (?:\n\t\t     \\d+\\s*:\\s*\\d+\n\t\t     (?:\n\t\t       \\s*:\\s*\\d+(?:[,.]\\d*)?\n\t\t     )?\n\t\t   |\n\t\t     \\d+\\s*h(?:\\s*\\d+m?(?:\\s*\\d+s?)?)?\n\t\t   )\n\t\t   (?:\n\t\t     \\s*\n\t\t     [ap](?:m\\b|\\.m\\.)\n\t\t   )?\n\t\t |\n\t\t   \\d+\\s*[ap](?:m\\b|\\.m\\.)\n\t\t )\n\t\t (?:\n\t\t   \\s*\n\t\t   (\n\t\t     (?:gmt|utc?)?[-+]\\d+(?:[,.:]\\d+(?::\\d+)?)?\n\t\t   |\n\t\t     [[:alpha:].\\s]+(?:standard|daylight)\\stime\\b\n\t\t   |\n\t\t     [[:alpha:]]+(?:\\sdst)?\\b\n\t\t   )\n\t\t )?\n\t\t/inx,\n\t\t' ')\n\n      t = $1\n      e.zone = $2 if $2\n\n      t =~ /\\A(\\d+)h?\n\t      (?:\\s*:?\\s*(\\d+)m?\n\t\t(?:\n\t\t  \\s*:?\\s*(\\d+)(?:[,.](\\d+))?s?\n\t\t)?\n\t      )?\n\t    (?:\\s*([ap])(?:m\\b|\\.m\\.))?/inx\n\n      e.hour = $1.to_i\n      e.min = $2.to_i if $2\n      e.sec = $3.to_i if $3\n      e.sec_fraction = Rational($4.to_i, 10**$4.size) if $4\n\n      if $5\n\te.hour %= 12\n\tif $5.downcase == 'p'\n\t  e.hour += 12\n\tend\n      end\n      true\n    end\n  end\n\n=begin\n  def self._parse_beat(str, e) # :nodoc:\n    if str.sub!(/@\\s*(\\d+)(?:[,.](\\d*))?/, ' ')\n      beat = Rational($1.to_i)\n      beat += Rational($2.to_i, "..., 4096) = 4096
read(3, "time(secs)\n      e.hour = h\n      e.min = min\n      e.sec = s\n      e.sec_fraction = fr * 86400\n      e.zone = '+01:00'\n      true\n    end\n  end\n=end\n\n  def self._parse_eu(str, e) # :nodoc:\n    if str.sub!(\n\t\t/'?(\\d+)[^-\\d\\s]*\n\t\t \\s*\n\t\t (#{Format::ABBR_MONTHS.keys.join('|')})[^-\\d\\s']*\n\t\t (?:\n\t\t   \\s*\n\t\t   (c(?:e|\\.e\\.)|b(?:ce|\\.c\\.e\\.)|a(?:d|\\.d\\.)|b(?:c|\\.c\\.))?\n\t\t   \\s*\n\t\t   ('?-?\\d+(?:(?:st|nd|rd|th)\\b)?)\n\t\t )?\n\t\t/inox,\n\t\t' ') # '\n      s3e(e, $4, Format::ABBR_MONTHS[$2.downcase], $1,\n\t  $3 && $3[0,1].downcase == 'b')\n      true\n    end\n  end\n\n  def self._parse_us(str, e) # :nodoc:\n    if str.sub!(\n\t\t/\\b(#{Format::ABBR_MONTHS.keys.join('|')})[^-\\d\\s']*\n\t\t \\s*\n\t\t ('?\\d+)[^-\\d\\s']*\n\t\t (?:\n\t\t   \\s*\n\t\t   (c(?:e|\\.e\\.)|b(?:ce|\\.c\\.e\\.)|a(?:d|\\.d\\.)|b(?:c|\\.c\\.))?\n\t\t   \\s*\n\t\t   ('?-?\\d+)\n\t\t )?\n\t\t/inox,\n\t\t' ') # '\n      s3e(e, $4, Format::ABBR_MONTHS[$1.downcase], $2,\n\t  $3 && $3[0,1].downcase == 'b')\n      true\n    end\n  end\n\n  def self._parse_iso(str, e) # :nodoc:\n    if str.sub!(/('?[-+]?\\d+)-(\\d+)-('?-?\\d+)/n, ' ')\n      s3e(e, $1, $2, $3)\n      true\n    end\n  end\n\n  def self._parse_iso2(str, e) # :nodoc:\n    if str.sub!(/\\b(\\d{2}|\\d{4})?-?w(\\d{2})(?:-?(\\d))?\\b/in, ' ')\n      e.cwyear = $1.to_i if $1\n      e.cweek = $2.to_i\n      e.cwday = $3.to_i if $3\n      true\n    elsif str.sub!(/-w-(\\d)\\b/in, ' ')\n      e.cwday = $1.to_i\n      true\n    elsif str.sub!(/--(\\d{2})?-(\\d{2})\\b/n, ' ')\n      e.mon = $1.to_i if $1\n      e.mday = $2.to_i\n      true\n    elsif str.sub!(/--(\\d{2})(\\d{2})?\\b/n, ' ')\n      e.mon = $1.to_i\n      e.mday = $2.to_i if $2\n      true\n    elsif /[,.](\\d{2}|\\d{4})-\\d{3}\\b/n !~ str &&\n\tstr.sub!(/\\b(\\d{2}|\\d{4})-(\\d{3})\\b/n, ' ')\n      e.year = $1.to_i\n      e.yday = $2.to_i\n      true\n    elsif /\\d-\\d{3}\\b/n !~ str &&\n\tstr.sub!(/\\b-(\\d{3})\\b/n, ' ')\n      e.yday = $1.to_i\n      true\n    end\n  end\n\n  def self._parse_jis(str, e) # :nodoc:\n    if str.sub!(/\\b([mtsh])(\\d+)\\.(\\d+)\\.(\\d+)/in, ' ')\n      era = { 'm'=>1867,\n\t      't'=>1911,\n\t      's'=>1925,\n\t      'h'=>1988\n\t  }[$1.downcase]\n      e.year = $2.to_i + era\n      e.mon = $3.to_i\n      e.mday = $4.to_i\n      true\n    end\n  end\n\n  def self._parse_vms(str, e) # :nodoc:\n    if str.sub!(/('?-?\\d+)-(#{Format::ABBR_MONTHS.keys.join('|')})[^-]*\n\t\t-('?-?\\d+)/inox, ' ')\n      s3e(e, $3, Format::ABBR_MONTHS[$2.downcase], $1)\n      true\n    elsif str.sub!(/\\b(#{Format::ABBR_MONTHS.keys.join('|')})[^-]*\n\t\t-('?-?\\d+)(?:-('?-?\\d+))?/inox, ' ')\n      s3e(e, $3, Format::ABBR_MONTHS[$1.downcase], $2)\n      true\n    end\n  end\n\n  def self._parse_sla(str, e) # :nodoc:\n    if str.sub!(%r|('?-?\\d+)/\\s*('?\\d+)(?:\\D\\s*('?-?\\d+))?|n, ' ') # '\n      s3e(e, $3, $1, $2)\n      true\n    end\n  end\n\n  def self._parse_dot(str, e) # :nodoc:\n    if str.sub!(%r|('?-?\\d+)\\.\\s*('?\\d+)\\.\\s*('?-?\\d+)|n, ' ') # '\n      s3e(e, $1, $2, $3)\n      true\n    end\n  end\n\n  def self._parse_year(str, e) # :nodoc:\n    if str.sub!(/'(\\d+)\\b/n, ' ')\n      e.year = $1.to_i\n      true\n    end\n  end\n\n  def self._parse_mon(str, e) # :nodoc:\n    if str.sub!(/\\b(#{Format::ABBR_MONTHS.keys.join('|')})\\S*/ino, ' ')\n      e.mon = Format::ABBR_MONTHS[$1.downcase]\n      true\n    end\n  end\n\n  def self._parse_mday(str, e) # :nodoc:\n    if str.sub!(/(\\d+)(st|nd|rd|th)\\b/in, ' ')\n      e.mday = $1.to_i\n      true\n    end\n  end\n\n  def self._parse_ddd(str, e) # :nodoc:\n    if str.sub!(\n\t\t/([-+]?)(\\d{2,14})\n\t\t  (?:\n\t\t    \\s*\n\t\t    t?\n\t\t    \\s*\n\t\t    (\\d{2,6})?(?:[,.](\\d*))?\n\t\t  )?\n\t\t  (?:\n\t\t    \\s*\n\t\t    (\n\t\t      z\\b\n\t\t    |\n\t\t      [-+]\\d{1,4}\\b\n\t\t    |\n\t\t      \\[[-+]?\\d[^\\]]*\\]\n\t\t    )\n\t\t  )?\n\t\t/inx,\n\t\t' ')\n      case $2.size\n      when 2\n\tif $3.nil? && $4\n\t  e.sec  = $2[-2, 2].to_i\n\telse\n\t  e.mday = $2[ 0, 2].to_i\n\tend\n      when 4\n\tif $3.nil? && $4\n\t  e.sec  = $2[-2, 2].to_i\n\t  e.min  = $2[-4, 2].to_i\n\telse\n\t  e.mon  = $2[ 0, 2].to_i\n\t  e.mday = $2[ 2, 2].to_i\n\tend\n      when 6\n\tif $3.nil? && $4\n\t  e.sec  = $2[-2, 2].to_i\n\t  e.min  = $2[-4, 2].to_i\n\t  e.hour = $2[-6, 2].to_i\n\telse\n\t  e.year = ($1 + $2[ 0, 2]).to_i\n\t  e"..., 4096) = 4096
read(3, "4\n\t  e.sec  = $2[-2, 2].to_i\n\t  e.min  = $2[-4, 2].to_i\n\t  e.hour = $2[-6, 2].to_i\n\t  e.mday = $2[-8, 2].to_i\n\t  if $2.size >= 10\n\t    e.mon  = $2[-10, 2].to_i\n\t  end\n\t  if $2.size == 12\n\t    e.year = ($1 + $2[-12, 2]).to_i\n\t  end\n\t  if $2.size == 14\n\t    e.year = ($1 + $2[-14, 4]).to_i\n\t    e._comp = false\n\t  end\n\telse\n\t  e.year = ($1 + $2[ 0, 4]).to_i\n\t  e.mon  = $2[ 4, 2].to_i\n\t  e.mday = $2[ 6, 2].to_i\n\t  e.hour = $2[ 8, 2].to_i if $2.size >= 10\n\t  e.min  = $2[10, 2].to_i if $2.size >= 12\n\t  e.sec  = $2[12, 2].to_i if $2.size >= 14\n\t  e._comp = false\n\tend\n      when 3\n\tif $3.nil? && $4\n\t  e.sec  = $2[-2, 2].to_i\n\t  e.min  = $2[-3, 1].to_i\n\telse\n\t  e.yday = $2[ 0, 3].to_i\n\tend\n      when 5\n\tif $3.nil? && $4\n\t  e.sec  = $2[-2, 2].to_i\n\t  e.min  = $2[-4, 2].to_i\n\t  e.hour = $2[-5, 1].to_i\n\telse\n\t  e.year = ($1 + $2[ 0, 2]).to_i\n\t  e.yday = $2[ 2, 3].to_i\n\tend\n      when 7\n\tif $3.nil? && $4\n\t  e.sec  = $2[-2, 2].to_i\n\t  e.min  = $2[-4, 2].to_i\n\t  e.hour = $2[-6, 2].to_i\n\t  e.mday = $2[-7, 1].to_i\n\telse\n\t  e.year = ($1 + $2[ 0, 4]).to_i\n\t  e.yday = $2[ 4, 3].to_i\n\tend\n      end\n      if $3\n\tif $4\n\t  case $3.size\n\t  when 2, 4, 6\n\t    e.sec  = $3[-2, 2].to_i\n\t    e.min  = $3[-4, 2].to_i if $3.size >= 4\n\t    e.hour = $3[-6, 2].to_i if $3.size >= 6\n\t  end\n\telse\n\t  case $3.size\n\t  when 2, 4, 6\n\t    e.hour = $3[ 0, 2].to_i\n\t    e.min  = $3[ 2, 2].to_i if $3.size >= 4\n\t    e.sec  = $3[ 4, 2].to_i if $3.size >= 6\n\t  end\n\tend\n      end\n      if $4\n\te.sec_fraction = Rational($4.to_i, 10**$4.size)\n      end\n      if $5\n\te.zone = $5\n\tif e.zone[0,1] == '['\n\t  o, n, = e.zone[1..-2].split(':')\n\t  e.zone = n || o\n\t  if /\\A\\d/ =~ o\n\t    o = format('+%s', o)\n\t  end\n\t  e.offset = zone_to_diff(o)\n\tend\n      end\n      true\n    end\n  end\n\n  private_class_method :_parse_day, :_parse_time, # :_parse_beat,\n\t:_parse_eu, :_parse_us, :_parse_iso, :_parse_iso2,\n\t:_parse_jis, :_parse_vms, :_parse_sla, :_parse_dot,\n\t:_parse_year, :_parse_mon, :_parse_mday, :_parse_ddd\n\n  def self._parse(str, comp=false)\n    str = str.dup\n\n    e = Format::Bag.new\n\n    e._comp = comp\n\n    str.gsub!(/[^-+',.\\/:@[:alnum:]\\[\\]\\x80-\\xff]+/n, ' ')\n\n    _parse_time(str, e) # || _parse_beat(str, e)\n    _parse_day(str, e)\n\n    _parse_eu(str, e)     ||\n    _parse_us(str, e)     ||\n    _parse_iso(str, e)    ||\n    _parse_jis(str, e)    ||\n    _parse_vms(str, e)    ||\n    _parse_sla(str, e)    ||\n    _parse_dot(str, e)    ||\n    _parse_iso2(str, e)   ||\n    _parse_year(str, e)   ||\n    _parse_mon(str, e)    ||\n    _parse_mday(str, e)   ||\n    _parse_ddd(str, e)\n\n    if str.sub!(/\\b(bc\\b|bce\\b|b\\.c\\.|b\\.c\\.e\\.)/in, ' ')\n      if e.year\n\te.year = -e.year + 1\n      end\n    end\n\n    if str.sub!(/\\A\\s*(\\d{1,2})\\s*\\z/n, ' ')\n      if e.hour && !e.mday\n\tv = $1.to_i\n\tif (1..31) === v\n\t  e.mday = v\n\tend\n      end\n      if e.mday && !e.hour\n\tv = $1.to_i\n\tif (0..24) === v\n\t  e.hour = v\n\tend\n      end\n    end\n\n    if e._comp\n      if e.cwyear\n\tif e.cwyear >= 0 && e.cwyear <= 99\n\t  e.cwyear += if e.cwyear >= 69\n\t\t      then 1900 else 2000 end\n\tend\n      end\n      if e.year\n\tif e.year >= 0 && e.year <= 99\n\t  e.year += if e.year >= 69\n\t\t    then 1900 else 2000 end\n\tend\n      end\n    end\n\n    e.offset ||= zone_to_diff(e.zone) if e.zone\n\n    e.to_hash\n  end\n\n  def self.zone_to_diff(zone) # :nodoc:\n    zone = zone.downcase\n    if zone.sub!(/\\s+(standard|daylight)\\s+time\\z/, '')\n      dst = $1 == 'daylight'\n    else\n      dst = zone.sub!(/\\s+dst\\z/, '')\n    end\n    if Format::ZONES.include?(zone)\n      offset = Format::ZONES[zone]\n      offset += 3600 if dst\n    elsif zone.sub!(/\\A(?:gmt|utc?)?([-+])/, '')\n      sign = $1\n      if zone.include?(':')\n\thour, min, sec, = zone.split(':')\n      elsif zone.include?(',') || zone.include?('.')\n\thour, fr, = zone.split(/[,.]/)\n\tmin = Rational(fr.to_i, 10**fr.size) * 60\n      else\n\tcase zone.size\n\twhen 3\n\t  hour = zone[0,1]\n\t  min = zone[1,2]\n\telse\n\t  hour = zone[0,2]\n\t  min = zone[2,2]\n\t  sec = zone[4,2]\n\tend\n      end\n      offset = hour.to_i * 3600 + min.to_i * 60"..., 4096) = 4096
read(3, "te\n\n  def strftime(fmt='%FT%T%:z')\n    super(fmt)\n  end\n\n  def self._strptime(str, fmt='%FT%T%z')\n    super(str, fmt)\n  end\n\n=begin\n  def iso8601_timediv(n) # :nodoc:\n    strftime('T%T' +\n\t     if n < 1\n\t       ''\n\t     else\n\t       '.%0*d' % [n, (sec_fraction / SECONDS_IN_DAY / (10**n)).round]\n\t     end +\n\t     '%:z')\n  end\n\n  private :iso8601_timediv\n\n  def iso8601(n=0)\n    super() + iso8601_timediv(n)\n  end\n\n  def rfc3339(n=0) iso8601(n) end\n\n  def jisx0301(n=0)\n    super() + iso8601_timediv(n)\n  end\n=end\n\nend\n", 4096) = 519
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rational.rb", 0xbfe50310) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rational.so", 0xbfe50310) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/rational.rb", 0xbfe50310) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/rational.so", 0xbfe50310) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/rational.rb", 0xbfe50310) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/rational.so", 0xbfe50310) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/rational.rb", 0xbfe50310) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/rational.so", 0xbfe50310) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/rational.rb", 0xbfe50310) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/rational.so", 0xbfe50310) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/rational.rb", 0xbfe50310) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/rational.so", 0xbfe50310) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/rational.rb", 0xbfe50310) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/rational.so", 0xbfe50310) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/rational.rb", {st_mode=S_IFREG|0644, st_size=12343, ...}) = 0
open("/usr/lib/ruby/1.8/rational.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=12343, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
brk(0x9ee1000)                          = 0x9ee1000
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml/types.rb", 0xbfe52560) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/yaml/types.so", 0xbfe52560) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/types.rb", 0xbfe52560) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/types.so", 0xbfe52560) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/types.rb", 0xbfe52560) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/types.so", 0xbfe52560) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/types.rb", 0xbfe52560) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/types.so", 0xbfe52560) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/types.rb", 0xbfe52560) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/types.so", 0xbfe52560) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/types.rb", 0xbfe52560) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/types.so", 0xbfe52560) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/types.rb", 0xbfe52560) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/types.so", 0xbfe52560) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml/types.rb", {st_mode=S_IFREG|0644, st_size=5002, ...}) = 0
open("/usr/lib/ruby/1.8/yaml/types.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5002, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/yaml/types.rb", 0xbfe52570) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/yaml/types.rb", 0xbfe52570) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/yaml/types.rb", 0xbfe52570) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/yaml/types.rb", 0xbfe52570) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/yaml/types.rb", 0xbfe52570) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/yaml/types.rb", 0xbfe52570) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/yaml/types.rb", 0xbfe52570) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/yaml/types.rb", {st_mode=S_IFREG|0644, st_size=5002, ...}) = 0
open("/usr/lib/ruby/1.8/yaml/types.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5002, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml/types.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5002, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/yaml/types.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/yaml/types.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5002, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "# -*- mode: ruby; ruby-indent-level: 4 -*- vim: sw=4\n#\n# Classes required by the full core typeset\n#\n\nmodule YAML\n\n    #\n    # Default private type\n    #\n    class PrivateType\n        def self.tag_subclasses?; false; end\n        verbose, $VERBOSE = $VERBOSE, nil\n        def initialize( type, val )\n            @type_id = type; @value = val\n            @value.taguri = \"x-private:#{ @type_id }\"\n        end\n        def to_yaml( opts = {} )\n            @value.to_yaml( opts )\n        end\n    ensure\n        $VERBOSE = verbose\n    end\n\n    #\n    # Default domain type\n    #\n    class DomainType\n        def self.tag_subclasses?; false; end\n        verbose, $VERBOSE = $VERBOSE, nil\n        def initialize( domain, type, val )\n            @domain = domain; @type_id = type; @value = val\n            @value.taguri = \"tag:#{ @domain }:#{ @type_id }\"\n        end\n        def to_yaml( opts = {} )\n            @value.to_yaml( opts )\n        end\n    ensure\n        $VERBOSE = verbose\n    end\n\n    #\n    # Unresolved objects\n    #\n    class Object\n        def self.tag_subclasses?; false; end\n        def to_yaml( opts = {} )\n            YAML::quick_emit( self, opts ) do |out|\n                out.map( \"tag:ruby.yaml.org,2002:object:#{ @class }\", to_yaml_style ) do |map|\n                    @ivars.each do |k,v|\n                        map.add( k, v )\n                    end\n                end\n            end\n        end\n    end\n\n    #\n    # YAML Hash class to support comments and defaults\n    #\n    class SpecialHash < ::Hash \n        attr_accessor :default\n        def inspect\n            self.default.to_s\n        end\n        def to_s\n            self.default.to_s\n        end\n        def update( h )\n            if YAML::SpecialHash === h\n                @default = h.default if h.default\n            end\n            super( h )\n        end\n        def to_yaml( opts = {} )\n            opts[:DefaultKey] = self.default\n            super( opts )\n        end\n    end\n\n    #\n    # Builtin collection: !omap\n    #\n    class Omap < ::Array\n        yaml_as \"tag:yaml.org,2002:omap\"\n        def yaml_initialize( tag, val )\n            if Array === val\n                val.each do |v|\n                    if Hash === v\n                        concat( v.to_a )\t\t# Convert the map to a sequence\n                    else\n                        raise YAML::Error, \"Invalid !omap entry: \" + val.inspect\n                    end\n                end\n            else\n                raise YAML::Error, \"Invalid !omap: \" + val.inspect\n            end\n            self\n        end\n        def self.[]( *vals )\n            o = Omap.new\n            0.step( vals.length - 1, 2 ) do |i|\n                o[vals[i]] = vals[i+1]\n            end\n            o\n        end\n        def []( k )\n            self.assoc( k ).to_a[1]\n        end\n        def []=( k, *rest )\n            val, set = rest.reverse\n            if ( tmp = self.assoc( k ) ) and not set\n                tmp[1] = val\n            else\n                self << [ k, val ] \n            end\n            val\n        end\n        def has_key?( k )\n            self.assoc( k ) ? true : false\n        end\n        def is_complex_yaml?\n            true\n        end\n        def to_yaml( opts = {} )\n            YAML::quick_emit( self, opts ) do |out|\n                out.seq( taguri, to_yaml_style ) do |seq|\n                    self.each do |v|\n                        seq.add( Hash[ *v ] )\n                    end\n                end\n            end\n        end\n    end\n\n    #\n    # Builtin collection: !pairs\n    #\n    class Pairs < ::Array\n        yaml_as \"tag:yaml.org,2002:pairs\"\n        def yaml_initialize( tag, val )\n            if Array === val\n                val.each do |v|\n                    if Hash === v\n                        concat( v.to_a )\t\t# Convert the map to a sequence\n                    else\n                        raise YAML::Error, \"Invalid !pairs entry: \" + val.inspect\n                    end\n                end\n            else\n       "..., 4096) = 4096
read(3, "      end\n        def self.[]( *vals )\n            p = Pairs.new\n            0.step( vals.length - 1, 2 ) { |i|\n                p[vals[i]] = vals[i+1]\n            }\n            p\n        end\n        def []( k )\n            self.assoc( k ).to_a\n        end\n        def []=( k, val )\n            self << [ k, val ] \n            val\n        end\n        def has_key?( k )\n            self.assoc( k ) ? true : false\n        end\n        def is_complex_yaml?\n            true\n        end\n        def to_yaml( opts = {} )\n            YAML::quick_emit( self, opts ) do |out|\n                out.seq( taguri, to_yaml_style ) do |seq|\n                    self.each do |v|\n                        seq.add( Hash[ *v ] )\n                    end\n                end\n            end\n        end\n    end\n\n    #\n    # Builtin collection: !set\n    #\n    class Set < ::Hash\n        yaml_as \"tag:yaml.org,2002:set\"\n    end\nend\n", 4096) = 906
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/Win32API.rb", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/Win32API.so", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/Win32API.rb", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/Win32API.so", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/Win32API.rb", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/Win32API.so", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/Win32API.rb", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/Win32API.so", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/Win32API.rb", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/Win32API.so", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/Win32API.rb", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/Win32API.so", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/Win32API.rb", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/Win32API.so", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/Win32API.rb", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/Win32API.so", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i486-linux/Win32API.rb", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i486-linux/Win32API.so", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i386-linux/Win32API.rb", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i386-linux/Win32API.so", 0xbfe523a0) = -1 ENOENT (No such file or directory)
stat64("./Win32API.rb", 0xbfe523a0)     = -1 ENOENT (No such file or directory)
stat64("./Win32API.so", 0xbfe523a0)     = -1 ENOENT (No such file or directory)
rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/custom_require.rb", {st_mode=S_IFREG|0644, st_size=1200, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/custom_require.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1200, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems/custom_require.rb", {st_mode=S_IFREG|0644, st_size=1200, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/custom_require.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1200, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/custom_require.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1200, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/custom_require.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/custom_require.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1200, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\nrequire 'rubygems'\n\nmodule Kernel\n\n  ##\n  # The Kernel#require from before RubyGems was loaded.\n\n  alias gem_original_require require\n\n  ##\n  # When RubyGems is required, Kernel#require is replaced with our own which\n  # is capable of loading gems on demand.\n  #\n  # When you call <tt>require 'x'</tt>, this is what happens:\n  # * If the file can be loaded from the existing Ruby loadpath, it\n  #   is.\n  # * Otherwise, installed gems are searched for a file that matches.\n  #   If it's found in gem 'y', that gem is activated (added to the\n  #   loadpath).\n  #\n  # The normal <tt>require</tt> functionality of returning false if\n  # that file has already been loaded is preserved.\n\n  def require(path) # :doc:\n    gem_original_require path\n  rescue LoadError => load_error\n    if load_error.message =~ /#{Regexp.escape path}\\z/ and\n       spec = Gem.searcher.find(path) then\n      Gem.activate(spec.name, \"= #{spec.version}\")\n      gem_original_require path\n    else\n      raise load_error\n    end\n  end\n\n  private :require\n  private :gem_original_require\n\nend\n\n", 4096) = 1200
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/rubygems.rb", {st_mode=S_IFREG|0644, st_size=29096, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=29096, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/local/lib/site_ruby/1.8/rubygems_plugin", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/rubygems_plugin.rb", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/rubygems_plugin.rbw", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/rubygems_plugin.so", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/rubygems_plugin.bundle", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/rubygems_plugin.dll", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/rubygems_plugin.sl", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/rubygems_plugin.jar", 0xbfe512d0) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/local/lib/site_ruby/1.8/i486-linux/rubygems_plugin", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/i486-linux/rubygems_plugin.rb", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/i486-linux/rubygems_plugin.rbw", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/i486-linux/rubygems_plugin.so", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/i486-linux/rubygems_plugin.bundle", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/i486-linux/rubygems_plugin.dll", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/i486-linux/rubygems_plugin.sl", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/i486-linux/rubygems_plugin.jar", 0xbfe511e0) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/local/lib/site_ruby/1.8/i386-linux/rubygems_plugin", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/i386-linux/rubygems_plugin.rb", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/i386-linux/rubygems_plugin.rbw", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/i386-linux/rubygems_plugin.so", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/i386-linux/rubygems_plugin.bundle", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/i386-linux/rubygems_plugin.dll", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/i386-linux/rubygems_plugin.sl", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/1.8/i386-linux/rubygems_plugin.jar", 0xbfe511e0) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/local/lib/site_ruby/rubygems_plugin", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/rubygems_plugin.rb", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/rubygems_plugin.rbw", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/rubygems_plugin.so", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/rubygems_plugin.bundle", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/rubygems_plugin.dll", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/rubygems_plugin.sl", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/local/lib/site_ruby/rubygems_plugin.jar", 0xbfe513c0) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/vendor_ruby/1.8/rubygems_plugin", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/1.8/rubygems_plugin.rb", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/1.8/rubygems_plugin.rbw", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/1.8/rubygems_plugin.so", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/1.8/rubygems_plugin.bundle", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/1.8/rubygems_plugin.dll", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/1.8/rubygems_plugin.sl", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/1.8/rubygems_plugin.jar", 0xbfe512d0) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/rubygems_plugin", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/rubygems_plugin.rb", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/rubygems_plugin.rbw", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/rubygems_plugin.so", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/rubygems_plugin.bundle", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/rubygems_plugin.dll", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/rubygems_plugin.sl", 0xbfe511e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/rubygems_plugin.jar", 0xbfe511e0) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/vendor_ruby/rubygems_plugin", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/rubygems_plugin.rb", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/rubygems_plugin.rbw", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/rubygems_plugin.so", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/rubygems_plugin.bundle", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/rubygems_plugin.dll", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/rubygems_plugin.sl", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/vendor_ruby/rubygems_plugin.jar", 0xbfe513c0) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/1.8/rubygems_plugin", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/rubygems_plugin.rb", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/rubygems_plugin.rbw", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/rubygems_plugin.so", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/rubygems_plugin.bundle", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/rubygems_plugin.dll", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/rubygems_plugin.sl", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/rubygems_plugin.jar", 0xbfe513c0) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/1.8/i486-linux/rubygems_plugin", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/i486-linux/rubygems_plugin.rb", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/i486-linux/rubygems_plugin.rbw", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/i486-linux/rubygems_plugin.so", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/i486-linux/rubygems_plugin.bundle", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/i486-linux/rubygems_plugin.dll", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/i486-linux/rubygems_plugin.sl", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/i486-linux/rubygems_plugin.jar", 0xbfe512d0) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/1.8/i386-linux/rubygems_plugin", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/i386-linux/rubygems_plugin.rb", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/i386-linux/rubygems_plugin.rbw", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/i386-linux/rubygems_plugin.so", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/i386-linux/rubygems_plugin.bundle", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/i386-linux/rubygems_plugin.dll", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/i386-linux/rubygems_plugin.sl", 0xbfe512d0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/1.8/i386-linux/rubygems_plugin.jar", 0xbfe512d0) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
getcwd("/home/davidw/workshop/yahoo-gem", 200) = 32
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/home/davidw/workshop/yahoo-gem/rubygems_plugin", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/home/davidw/workshop/yahoo-gem/rubygems_plugin.rb", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/home/davidw/workshop/yahoo-gem/rubygems_plugin.rbw", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/home/davidw/workshop/yahoo-gem/rubygems_plugin.so", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/home/davidw/workshop/yahoo-gem/rubygems_plugin.bundle", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/home/davidw/workshop/yahoo-gem/rubygems_plugin.dll", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/home/davidw/workshop/yahoo-gem/rubygems_plugin.sl", 0xbfe513c0) = -1 ENOENT (No such file or directory)
lstat64("/home/davidw/workshop/yahoo-gem/rubygems_plugin.jar", 0xbfe513c0) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/gemrc", 0xbfe48520)        = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/home/davidw/.gemrc", 0xbfe48520) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/home/davidw", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/fileutils.rb", 0xbfe48fb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/fileutils.so", 0xbfe48fb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/fileutils.rb", 0xbfe48fb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/fileutils.so", 0xbfe48fb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/fileutils.rb", 0xbfe48fb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/fileutils.so", 0xbfe48fb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/fileutils.rb", 0xbfe48fb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/fileutils.so", 0xbfe48fb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/fileutils.rb", 0xbfe48fb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/fileutils.so", 0xbfe48fb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/fileutils.rb", 0xbfe48fb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/fileutils.so", 0xbfe48fb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/fileutils.rb", 0xbfe48fb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/fileutils.so", 0xbfe48fb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/fileutils.rb", {st_mode=S_IFREG|0644, st_size=43014, ...}) = 0
open("/usr/lib/ruby/1.8/fileutils.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=43014, ...}) = 0
close(3)                                = 0
stat64("/usr/local/lib/site_ruby/1.8/fileutils.rb", 0xbfe48fc0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/fileutils.rb", 0xbfe48fc0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/fileutils.rb", 0xbfe48fc0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/fileutils.rb", 0xbfe48fc0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/fileutils.rb", 0xbfe48fc0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/fileutils.rb", 0xbfe48fc0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/fileutils.rb", 0xbfe48fc0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/fileutils.rb", {st_mode=S_IFREG|0644, st_size=43014, ...}) = 0
open("/usr/lib/ruby/1.8/fileutils.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=43014, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/fileutils.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=43014, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/fileutils.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/fileutils.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=43014, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "# \n# = fileutils.rb\n# \n# Copyright (c) 2000-2006 Minero Aoki\n# \n# This program is free software.\n# You can distribute/modify this program under the same terms of ruby.\n# \n# == module FileUtils\n# \n# Namespace for several file utility methods for copying, moving, removing, etc.\n# \n# === Module Functions\n# \n#   cd(dir, options)\n#   cd(dir, options) {|dir| .... }\n#   pwd()\n#   mkdir(dir, options)\n#   mkdir(list, options)\n#   mkdir_p(dir, options)\n#   mkdir_p(list, options)\n#   rmdir(dir, options)\n#   rmdir(list, options)\n#   ln(old, new, options)\n#   ln(list, destdir, options)\n#   ln_s(old, new, options)\n#   ln_s(list, destdir, options)\n#   ln_sf(src, dest, options)\n#   cp(src, dest, options)\n#   cp(list, dir, options)\n#   cp_r(src, dest, options)\n#   cp_r(list, dir, options)\n#   mv(src, dest, options)\n#   mv(list, dir, options)\n#   rm(list, options)\n#   rm_r(list, options)\n#   rm_rf(list, options)\n#   install(src, dest, mode = <src's>, options)\n#   chmod(mode, list, options)\n#   chmod_R(mode, list, options)\n#   chown(user, group, list, options)\n#   chown_R(user, group, list, options)\n#   touch(list, options)\n#\n# The <tt>options</tt> parameter is a hash of options, taken from the list\n# <tt>:force</tt>, <tt>:noop</tt>, <tt>:preserve</tt>, and <tt>:verbose</tt>.\n# <tt>:noop</tt> means that no changes are made.  The other two are obvious.\n# Each method documents the options that it honours.\n#\n# All methods that have the concept of a \"source\" file or directory can take\n# either one file or a list of files in that argument.  See the method\n# documentation for examples.\n#\n# There are some `low level' methods, which do not accept any option:\n#\n#   copy_entry(src, dest, preserve = false, dereference = false)\n#   copy_file(src, dest, preserve = false, dereference = true)\n#   copy_stream(srcstream, deststream)\n#   remove_entry(path, force = false)\n#   remove_entry_secure(path, force = false)\n#   remove_file(path, force = false)\n#   compare_file(path_a, path_b)\n#   compare_stream(stream_a, stream_b)\n#   uptodate?(file, cmp_list)\n#\n# == module FileUtils::Verbose\n# \n# This module has all methods of FileUtils module, but it outputs messages\n# before acting.  This equates to passing the <tt>:verbose</tt> flag to methods\n# in FileUtils.\n# \n# == module FileUtils::NoWrite\n# \n# This module has all methods of FileUtils module, but never changes\n# files/directories.  This equates to passing the <tt>:noop</tt> flag to methods\n# in FileUtils.\n# \n# == module FileUtils::DryRun\n# \n# This module has all methods of FileUtils module, but never changes\n# files/directories.  This equates to passing the <tt>:noop</tt> and\n# <tt>:verbose</tt> flags to methods in FileUtils.\n# \n\nmodule FileUtils\n\n  def self.private_module_function(name)   #:nodoc:\n    module_function name\n    private_class_method name\n  end\n\n  # This hash table holds command options.\n  OPT_TABLE = {}   #:nodoc: internal use only\n\n  #\n  # Options: (none)\n  #\n  # Returns the name of the current directory.\n  #\n  def pwd\n    Dir.pwd\n  end\n  module_function :pwd\n\n  alias getwd pwd\n  module_function :getwd\n\n  #\n  # Options: verbose\n  # \n  # Changes the current directory to the directory +dir+.\n  # \n  # If this method is called with block, resumes to the old\n  # working directory after the block execution finished.\n  # \n  #   FileUtils.cd('/', :verbose => true)   # chdir and report it\n  # \n  def cd(dir, options = {}, &block) # :yield: dir\n    fu_check_options options, OPT_TABLE['cd']\n    fu_output_message \"cd #{dir}\" if options[:verbose]\n    Dir.chdir(dir, &block)\n    fu_output_message 'cd -' if options[:verbose] and block\n  end\n  module_function :cd\n\n  alias chdir cd\n  module_function :chdir\n\n  OPT_TABLE['cd']    =\n  OPT_TABLE['chdir'] = [:verbose]\n\n  #\n  # Options: (none)\n  # \n  # Returns true if +newer+ is newer than all +old_list+.\n  # Non-existent files are older than any file.\n  # \n  #   FileUtils.uptodate?('hello.o', %w(hello.c hello.h)) or \\\n  #       system 'make hello.o'\n  # \n  def uptodate?(ne"..., 4096) = 4096
read(3, "ptions\n\n    return false unless File.exist?(new)\n    new_time = File.mtime(new)\n    old_list.each do |old|\n      if File.exist?(old)\n        return false unless new_time > File.mtime(old)\n      end\n    end\n    true\n  end\n  module_function :uptodate?\n\n  #\n  # Options: mode noop verbose\n  # \n  # Creates one or more directories.\n  # \n  #   FileUtils.mkdir 'test'\n  #   FileUtils.mkdir %w( tmp data )\n  #   FileUtils.mkdir 'notexist', :noop => true  # Does not really create.\n  #   FileUtils.mkdir 'tmp', :mode => 0700\n  # \n  def mkdir(list, options = {})\n    fu_check_options options, OPT_TABLE['mkdir']\n    list = fu_list(list)\n    fu_output_message \"mkdir #{options[:mode] ? ('-m %03o ' % options[:mode]) : ''}#{list.join ' '}\" if options[:verbose]\n    return if options[:noop]\n\n    list.each do |dir|\n      fu_mkdir dir, options[:mode]\n    end\n  end\n  module_function :mkdir\n\n  OPT_TABLE['mkdir'] = [:mode, :noop, :verbose]\n\n  #\n  # Options: mode noop verbose\n  # \n  # Creates a directory and all its parent directories.\n  # For example,\n  # \n  #   FileUtils.mkdir_p '/usr/local/lib/ruby'\n  # \n  # causes to make following directories, if it does not exist.\n  #     * /usr\n  #     * /usr/local\n  #     * /usr/local/lib\n  #     * /usr/local/lib/ruby\n  #\n  # You can pass several directories at a time in a list.\n  # \n  def mkdir_p(list, options = {})\n    fu_check_options options, OPT_TABLE['mkdir_p']\n    list = fu_list(list)\n    fu_output_message \"mkdir -p #{options[:mode] ? ('-m %03o ' % options[:mode]) : ''}#{list.join ' '}\" if options[:verbose]\n    return *list if options[:noop]\n\n    list.map {|path| path.sub(%r</\\z>, '') }.each do |path|\n      # optimize for the most common case\n      begin\n        fu_mkdir path, options[:mode]\n        next\n      rescue SystemCallError\n        next if File.directory?(path)\n      end\n\n      stack = []\n      until path == stack.last   # dirname(\"/\")==\"/\", dirname(\"C:/\")==\"C:/\"\n        stack.push path\n        path = File.dirname(path)\n      end\n      stack.reverse_each do |path|\n        begin\n          fu_mkdir path, options[:mode]\n        rescue SystemCallError => err\n          raise unless File.directory?(path)\n        end\n      end\n    end\n\n    return *list\n  end\n  module_function :mkdir_p\n\n  alias mkpath    mkdir_p\n  alias makedirs  mkdir_p\n  module_function :mkpath\n  module_function :makedirs\n\n  OPT_TABLE['mkdir_p']  =\n  OPT_TABLE['mkpath']   =\n  OPT_TABLE['makedirs'] = [:mode, :noop, :verbose]\n\n  def fu_mkdir(path, mode)   #:nodoc:\n    path = path.sub(%r</\\z>, '')\n    if mode\n      Dir.mkdir path, mode\n      File.chmod mode, path\n    else\n      Dir.mkdir path\n    end\n  end\n  private_module_function :fu_mkdir\n\n  #\n  # Options: noop, verbose\n  # \n  # Removes one or more directories.\n  # \n  #   FileUtils.rmdir 'somedir'\n  #   FileUtils.rmdir %w(somedir anydir otherdir)\n  #   # Does not really remove directory; outputs message.\n  #   FileUtils.rmdir 'somedir', :verbose => true, :noop => true\n  # \n  def rmdir(list, options = {})\n    fu_check_options options, OPT_TABLE['rmdir']\n    list = fu_list(list)\n    fu_output_message \"rmdir #{list.join ' '}\" if options[:verbose]\n    return if options[:noop]\n    list.each do |dir|\n      Dir.rmdir dir.sub(%r</\\z>, '')\n    end\n  end\n  module_function :rmdir\n\n  OPT_TABLE['rmdir'] = [:noop, :verbose]\n\n  #\n  # Options: force noop verbose\n  #\n  # <b><tt>ln(old, new, options = {})</tt></b>\n  #\n  # Creates a hard link +new+ which points to +old+.\n  # If +new+ already exists and it is a directory, creates a link +new/old+.\n  # If +new+ already exists and it is not a directory, raises Errno::EEXIST.\n  # But if :force option is set, overwrite +new+.\n  # \n  #   FileUtils.ln 'gcc', 'cc', :verbose => true\n  #   FileUtils.ln '/usr/bin/emacs21', '/usr/bin/emacs'\n  # \n  # <b><tt>ln(list, destdir, options = {})</tt></b>\n  # \n  # Creates several hard links in a directory, with each one pointing to the\n  # item in +list+.  If +destdir+ is not a directory, raises Errno::ENOTDIR.\n  # \n  #   incl"..., 4096) = 4096
brk(0x9f02000)                          = 0x9f02000
read(3, "bin/cp are linked.\n  # \n  def ln(src, dest, options = {})\n    fu_check_options options, OPT_TABLE['ln']\n    fu_output_message \"ln#{options[:force] ? ' -f' : ''} #{[src,dest].flatten.join ' '}\" if options[:verbose]\n    return if options[:noop]\n    fu_each_src_dest0(src, dest) do |s,d|\n      remove_file d, true if options[:force]\n      File.link s, d\n    end\n  end\n  module_function :ln\n\n  alias link ln\n  module_function :link\n\n  OPT_TABLE['ln']   =\n  OPT_TABLE['link'] = [:force, :noop, :verbose]\n\n  #\n  # Options: force noop verbose\n  #\n  # <b><tt>ln_s(old, new, options = {})</tt></b>\n  # \n  # Creates a symbolic link +new+ which points to +old+.  If +new+ already\n  # exists and it is a directory, creates a symbolic link +new/old+.  If +new+\n  # already exists and it is not a directory, raises Errno::EEXIST.  But if\n  # :force option is set, overwrite +new+.\n  # \n  #   FileUtils.ln_s '/usr/bin/ruby', '/usr/local/bin/ruby'\n  #   FileUtils.ln_s 'verylongsourcefilename.c', 'c', :force => true\n  # \n  # <b><tt>ln_s(list, destdir, options = {})</tt></b>\n  # \n  # Creates several symbolic links in a directory, with each one pointing to the\n  # item in +list+.  If +destdir+ is not a directory, raises Errno::ENOTDIR.\n  #\n  # If +destdir+ is not a directory, raises Errno::ENOTDIR.\n  # \n  #   FileUtils.ln_s Dir.glob('bin/*.rb'), '/home/aamine/bin'\n  # \n  def ln_s(src, dest, options = {})\n    fu_check_options options, OPT_TABLE['ln_s']\n    fu_output_message \"ln -s#{options[:force] ? 'f' : ''} #{[src,dest].flatten.join ' '}\" if options[:verbose]\n    return if options[:noop]\n    fu_each_src_dest0(src, dest) do |s,d|\n      remove_file d, true if options[:force]\n      File.symlink s, d\n    end\n  end\n  module_function :ln_s\n\n  alias symlink ln_s\n  module_function :symlink\n\n  OPT_TABLE['ln_s']    =\n  OPT_TABLE['symlink'] = [:force, :noop, :verbose]\n\n  #\n  # Options: noop verbose\n  # \n  # Same as\n  #   #ln_s(src, dest, :force)\n  # \n  def ln_sf(src, dest, options = {})\n    fu_check_options options, OPT_TABLE['ln_sf']\n    options = options.dup\n    options[:force] = true\n    ln_s src, dest, options\n  end\n  module_function :ln_sf\n\n  OPT_TABLE['ln_sf'] = [:noop, :verbose]\n\n  #\n  # Options: preserve noop verbose\n  #\n  # Copies a file content +src+ to +dest+.  If +dest+ is a directory,\n  # copies +src+ to +dest/src+.\n  #\n  # If +src+ is a list of files, then +dest+ must be a directory.\n  #\n  #   FileUtils.cp 'eval.c', 'eval.c.org'\n  #   FileUtils.cp %w(cgi.rb complex.rb date.rb), '/usr/lib/ruby/1.6'\n  #   FileUtils.cp %w(cgi.rb complex.rb date.rb), '/usr/lib/ruby/1.6', :verbose => true\n  #   FileUtils.cp 'symlink', 'dest'   # copy content, \"dest\" is not a symlink\n  # \n  def cp(src, dest, options = {})\n    fu_check_options options, OPT_TABLE['cp']\n    fu_output_message \"cp#{options[:preserve] ? ' -p' : ''} #{[src,dest].flatten.join ' '}\" if options[:verbose]\n    return if options[:noop]\n    fu_each_src_dest(src, dest) do |s, d|\n      copy_file s, d, options[:preserve]\n    end\n  end\n  module_function :cp\n\n  alias copy cp\n  module_function :copy\n\n  OPT_TABLE['cp']   =\n  OPT_TABLE['copy'] = [:preserve, :noop, :verbose]\n\n  #\n  # Options: preserve noop verbose dereference_root remove_destination\n  # \n  # Copies +src+ to +dest+. If +src+ is a directory, this method copies\n  # all its contents recursively. If +dest+ is a directory, copies\n  # +src+ to +dest/src+.\n  #\n  # +src+ can be a list of files.\n  # \n  #   # Installing ruby library \"mylib\" under the site_ruby\n  #   FileUtils.rm_r site_ruby + '/mylib', :force\n  #   FileUtils.cp_r 'lib/', site_ruby + '/mylib'\n  # \n  #   # Examples of copying several files to target directory.\n  #   FileUtils.cp_r %w(mail.rb field.rb debug/), site_ruby + '/tmail'\n  #   FileUtils.cp_r Dir.glob('*.rb'), '/home/aamine/lib/ruby', :noop => true, :verbose => true\n  #\n  #   # If you want to copy all contents of a directory instead of the\n  #   # directory itself, c.f. src/x -> dest/x, src/y -> dest/y,\n  #   # use following code.\n  #   F"..., 4096) = 4096
read(3, "                 # but this doesn't.\n  # \n  def cp_r(src, dest, options = {})\n    fu_check_options options, OPT_TABLE['cp_r']\n    fu_output_message \"cp -r#{options[:preserve] ? 'p' : ''}#{options[:remove_destination] ? ' --remove-destination' : ''} #{[src,dest].flatten.join ' '}\" if options[:verbose]\n    return if options[:noop]\n    options[:dereference_root] = true unless options.key?(:dereference_root)\n    fu_each_src_dest(src, dest) do |s, d|\n      copy_entry s, d, options[:preserve], options[:dereference_root], options[:remove_destination]\n    end\n  end\n  module_function :cp_r\n\n  OPT_TABLE['cp_r'] = [:preserve, :noop, :verbose,\n                       :dereference_root, :remove_destination]\n\n  #\n  # Copies a file system entry +src+ to +dest+.\n  # If +src+ is a directory, this method copies its contents recursively.\n  # This method preserves file types, c.f. symlink, directory...\n  # (FIFO, device files and etc. are not supported yet)\n  #\n  # Both of +src+ and +dest+ must be a path name.\n  # +src+ must exist, +dest+ must not exist.\n  #\n  # If +preserve+ is true, this method preserves owner, group, permissions\n  # and modified time.\n  #\n  # If +dereference_root+ is true, this method dereference tree root.\n  #\n  # If +remove_destination+ is true, this method removes each destination file before copy.\n  #\n  def copy_entry(src, dest, preserve = false, dereference_root = false, remove_destination = false)\n    Entry_.new(src, nil, dereference_root).traverse do |ent|\n      destent = Entry_.new(dest, ent.rel, false)\n      File.unlink destent.path if remove_destination && File.file?(destent.path)\n      ent.copy destent.path\n      ent.copy_metadata destent.path if preserve\n    end\n  end\n  module_function :copy_entry\n\n  #\n  # Copies file contents of +src+ to +dest+.\n  # Both of +src+ and +dest+ must be a path name.\n  #\n  def copy_file(src, dest, preserve = false, dereference = true)\n    ent = Entry_.new(src, nil, dereference)\n    ent.copy_file dest\n    ent.copy_metadata dest if preserve\n  end\n  module_function :copy_file\n\n  #\n  # Copies stream +src+ to +dest+.\n  # +src+ must respond to #read(n) and\n  # +dest+ must respond to #write(str).\n  #\n  def copy_stream(src, dest)\n    fu_copy_stream0 src, dest, fu_stream_blksize(src, dest)\n  end\n  module_function :copy_stream\n\n  #\n  # Options: force noop verbose\n  # \n  # Moves file(s) +src+ to +dest+.  If +file+ and +dest+ exist on the different\n  # disk partition, the file is copied instead.\n  # \n  #   FileUtils.mv 'badname.rb', 'goodname.rb'\n  #   FileUtils.mv 'stuff.rb', '/notexist/lib/ruby', :force => true  # no error\n  # \n  #   FileUtils.mv %w(junk.txt dust.txt), '/home/aamine/.trash/'\n  #   FileUtils.mv Dir.glob('test*.rb'), 'test', :noop => true, :verbose => true\n  # \n  def mv(src, dest, options = {})\n    fu_check_options options, OPT_TABLE['mv']\n    fu_output_message \"mv#{options[:force] ? ' -f' : ''} #{[src,dest].flatten.join ' '}\" if options[:verbose]\n    return if options[:noop]\n    fu_each_src_dest(src, dest) do |s, d|\n      destent = Entry_.new(d, nil, true)\n      begin\n        if destent.exist?\n          if destent.directory?\n            raise Errno::EEXIST, dest\n          else\n            destent.remove_file if rename_cannot_overwrite_file?\n          end\n        end\n        begin\n          File.rename s, d\n        rescue Errno::EXDEV\n          copy_entry s, d, true\n          if options[:secure]\n            remove_entry_secure s, options[:force]\n          else\n            remove_entry s, options[:force]\n          end\n        end\n      rescue SystemCallError\n        raise unless options[:force]\n      end\n    end\n  end\n  module_function :mv\n\n  alias move mv\n  module_function :move\n\n  OPT_TABLE['mv']   =\n  OPT_TABLE['move'] = [:force, :noop, :verbose, :secure]\n\n  def rename_cannot_overwrite_file?   #:nodoc:\n    /djgpp|cygwin|mswin|mingw|bccwin|wince|emx/ =~ RUBY_PLATFORM\n  end\n  private_module_function :rename_cannot_overwrite_file?\n\n  #\n  # Options: force noop verbose\n  # \n  # Remove "..., 4096) = 4096
read(3, "ignored when the :force option is set.\n  # \n  #   FileUtils.rm %w( junk.txt dust.txt )\n  #   FileUtils.rm Dir.glob('*.so')\n  #   FileUtils.rm 'NotExistFile', :force => true   # never raises exception\n  # \n  def rm(list, options = {})\n    fu_check_options options, OPT_TABLE['rm']\n    list = fu_list(list)\n    fu_output_message \"rm#{options[:force] ? ' -f' : ''} #{list.join ' '}\" if options[:verbose]\n    return if options[:noop]\n\n    list.each do |path|\n      remove_file path, options[:force]\n    end\n  end\n  module_function :rm\n\n  alias remove rm\n  module_function :remove\n\n  OPT_TABLE['rm']     =\n  OPT_TABLE['remove'] = [:force, :noop, :verbose]\n\n  #\n  # Options: noop verbose\n  # \n  # Equivalent to\n  #\n  #   #rm(list, :force => true)\n  #\n  def rm_f(list, options = {})\n    fu_check_options options, OPT_TABLE['rm_f']\n    options = options.dup\n    options[:force] = true\n    rm list, options\n  end\n  module_function :rm_f\n\n  alias safe_unlink rm_f\n  module_function :safe_unlink\n\n  OPT_TABLE['rm_f']        =\n  OPT_TABLE['safe_unlink'] = [:noop, :verbose]\n\n  #\n  # Options: force noop verbose secure\n  # \n  # remove files +list+[0] +list+[1]... If +list+[n] is a directory,\n  # removes its all contents recursively. This method ignores\n  # StandardError when :force option is set.\n  # \n  #   FileUtils.rm_r Dir.glob('/tmp/*')\n  #   FileUtils.rm_r '/', :force => true          #  :-)\n  #\n  # WARNING: This method causes local vulnerability\n  # if one of parent directories or removing directory tree are world\n  # writable (including /tmp, whose permission is 1777), and the current\n  # process has strong privilege such as Unix super user (root), and the\n  # system has symbolic link.  For secure removing, read the documentation\n  # of #remove_entry_secure carefully, and set :secure option to true.\n  # Default is :secure=>false.\n  #\n  # NOTE: This method calls #remove_entry_secure if :secure option is set.\n  # See also #remove_entry_secure.\n  # \n  def rm_r(list, options = {})\n    fu_check_options options, OPT_TABLE['rm_r']\n    # options[:secure] = true unless options.key?(:secure)\n    list = fu_list(list)\n    fu_output_message \"rm -r#{options[:force] ? 'f' : ''} #{list.join ' '}\" if options[:verbose]\n    return if options[:noop]\n    list.each do |path|\n      if options[:secure]\n        remove_entry_secure path, options[:force]\n      else\n        remove_entry path, options[:force]\n      end\n    end\n  end\n  module_function :rm_r\n\n  OPT_TABLE['rm_r'] = [:force, :noop, :verbose, :secure]\n\n  #\n  # Options: noop verbose secure\n  # \n  # Equivalent to\n  #\n  #   #rm_r(list, :force => true)\n  #\n  # WARNING: This method causes local vulnerability.\n  # Read the documentation of #rm_r first.\n  # \n  def rm_rf(list, options = {})\n    fu_check_options options, OPT_TABLE['rm_rf']\n    options = options.dup\n    options[:force] = true\n    rm_r list, options\n  end\n  module_function :rm_rf\n\n  alias rmtree rm_rf\n  module_function :rmtree\n\n  OPT_TABLE['rm_rf']  =\n  OPT_TABLE['rmtree'] = [:noop, :verbose, :secure]\n\n  #\n  # This method removes a file system entry +path+.  +path+ shall be a\n  # regular file, a directory, or something.  If +path+ is a directory,\n  # remove it recursively.  This method is required to avoid TOCTTOU\n  # (time-of-check-to-time-of-use) local security vulnerability of #rm_r.\n  # #rm_r causes security hole when:\n  #\n  #   * Parent directory is world writable (including /tmp).\n  #   * Removing directory tree includes world writable directory.\n  #   * The system has symbolic link.\n  #\n  # To avoid this security hole, this method applies special preprocess.\n  # If +path+ is a directory, this method chown(2) and chmod(2) all\n  # removing directories.  This requires the current process is the\n  # owner of the removing whole directory tree, or is the super user (root).\n  #\n  # WARNING: You must ensure that *ALL* parent directories are not\n  # world writable.  Otherwise this method does not work.\n  # Only exception is temporary directory like /tmp and /var/"..., 4096) = 4096
read(3, "e, or Unix super\n  # user (root) should invoke this method.  Otherwise this method does not\n  # work.\n  #\n  # For details of this security vulnerability, see Perl's case:\n  #\n  #   http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2005-0448\n  #   http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2004-0452\n  #\n  # For fileutils.rb, this vulnerability is reported in [ruby-dev:26100].\n  #\n  def remove_entry_secure(path, force = false)\n    unless fu_have_symlink?\n      remove_entry path, force\n      return\n    end\n    fullpath = File.expand_path(path)\n    st = File.lstat(fullpath)\n    unless st.directory?\n      File.unlink fullpath\n      return\n    end\n    # is a directory.\n    parent_st = File.stat(File.dirname(fullpath))\n    unless fu_world_writable?(parent_st)\n      remove_entry path, force\n      return\n    end\n    unless parent_st.sticky?\n      raise ArgumentError, \"parent directory is world writable, FileUtils#remove_entry_secure does not work; abort: #{path.inspect} (parent directory mode #{'%o' % parent_st.mode})\"\n    end\n    # freeze tree root\n    euid = Process.euid\n    File.open(fullpath + '/.') {|f|\n      unless fu_stat_identical_entry?(st, f.stat)\n        # symlink (TOC-to-TOU attack?)\n        File.unlink fullpath\n        return\n      end\n      f.chown euid, -1\n      f.chmod 0700\n    }\n    # ---- tree root is frozen ----\n    root = Entry_.new(path)\n    root.preorder_traverse do |ent|\n      if ent.directory?\n        ent.chown euid, -1\n        ent.chmod 0700\n      end\n    end\n    root.postorder_traverse do |ent|\n      begin\n        ent.remove\n      rescue\n        raise unless force\n      end\n    end\n  rescue\n    raise unless force\n  end\n  module_function :remove_entry_secure\n\n  def fu_world_writable?(st)\n    (st.mode & 0002) != 0\n  end\n  private_module_function :fu_world_writable?\n\n  def fu_have_symlink?   #:nodoc\n    File.symlink nil, nil\n  rescue NotImplementedError\n    return false\n  rescue\n    return true\n  end\n  private_module_function :fu_have_symlink?\n\n  def fu_stat_identical_entry?(a, b)   #:nodoc:\n    a.dev == b.dev and a.ino == b.ino\n  end\n  private_module_function :fu_stat_identical_entry?\n\n  #\n  # This method removes a file system entry +path+.\n  # +path+ might be a regular file, a directory, or something.\n  # If +path+ is a directory, remove it recursively.\n  #\n  # See also #remove_entry_secure.\n  #\n  def remove_entry(path, force = false)\n    Entry_.new(path).postorder_traverse do |ent|\n      begin\n        ent.remove\n      rescue\n        raise unless force\n      end\n    end\n  rescue\n    raise unless force\n  end\n  module_function :remove_entry\n\n  #\n  # Removes a file +path+.\n  # This method ignores StandardError if +force+ is true.\n  #\n  def remove_file(path, force = false)\n    Entry_.new(path).remove_file\n  rescue\n    raise unless force\n  end\n  module_function :remove_file\n\n  #\n  # Removes a directory +dir+ and its contents recursively.\n  # This method ignores StandardError if +force+ is true.\n  #\n  def remove_dir(path, force = false)\n    remove_entry path, force   # FIXME?? check if it is a directory\n  end\n  module_function :remove_dir\n\n  #\n  # Returns true if the contents of a file A and a file B are identical.\n  # \n  #   FileUtils.compare_file('somefile', 'somefile')  #=> true\n  #   FileUtils.compare_file('/bin/cp', '/bin/mv')    #=> maybe false\n  #\n  def compare_file(a, b)\n    return false unless File.size(a) == File.size(b)\n    File.open(a, 'rb') {|fa|\n      File.open(b, 'rb') {|fb|\n        return compare_stream(fa, fb)\n      }\n    }\n  end\n  module_function :compare_file\n\n  alias identical? compare_file\n  alias cmp compare_file\n  module_function :identical?\n  module_function :cmp\n\n  #\n  # Returns true if the contents of a stream +a+ and +b+ are identical.\n  #\n  def compare_stream(a, b)\n    bsize = fu_stream_blksize(a, b)\n    sa = sb = nil\n    while sa == sb\n      sa = a.read(bsize)\n      sb = b.read(bsize)\n      unless sa and sb\n        if sa.nil? and sb.nil?\n          return true\n        end\n  "..., 4096) = 4096
read(3, "e noop verbose\n  # \n  # If +src+ is not same as +dest+, copies it and changes the permission\n  # mode to +mode+.  If +dest+ is a directory, destination is +dest+/+src+.\n  # This method removes destination before copy.\n  # \n  #   FileUtils.install 'ruby', '/usr/local/bin/ruby', :mode => 0755, :verbose => true\n  #   FileUtils.install 'lib.rb', '/usr/local/lib/ruby/site_ruby', :verbose => true\n  # \n  def install(src, dest, options = {})\n    fu_check_options options, OPT_TABLE['install']\n    fu_output_message \"install -c#{options[:preserve] && ' -p'}#{options[:mode] ? (' -m 0%o' % options[:mode]) : ''} #{[src,dest].flatten.join ' '}\" if options[:verbose]\n    return if options[:noop]\n    fu_each_src_dest(src, dest) do |s, d|\n      unless File.exist?(d) and compare_file(s, d)\n        remove_file d, true\n        st = File.stat(s) if options[:preserve]\n        copy_file s, d\n        File.utime st.atime, st.mtime, d if options[:preserve]\n        File.chmod options[:mode], d if options[:mode]\n      end\n    end\n  end\n  module_function :install\n\n  OPT_TABLE['install'] = [:mode, :preserve, :noop, :verbose]\n\n  #\n  # Options: noop verbose\n  # \n  # Changes permission bits on the named files (in +list+) to the bit pattern\n  # represented by +mode+.\n  # \n  #   FileUtils.chmod 0755, 'somecommand'\n  #   FileUtils.chmod 0644, %w(my.rb your.rb his.rb her.rb)\n  #   FileUtils.chmod 0755, '/usr/bin/ruby', :verbose => true\n  # \n  def chmod(mode, list, options = {})\n    fu_check_options options, OPT_TABLE['chmod']\n    list = fu_list(list)\n    fu_output_message sprintf('chmod %o %s', mode, list.join(' ')) if options[:verbose]\n    return if options[:noop]\n    list.each do |path|\n      Entry_.new(path).chmod mode\n    end\n  end\n  module_function :chmod\n\n  OPT_TABLE['chmod'] = [:noop, :verbose]\n\n  #\n  # Options: noop verbose force\n  # \n  # Changes permission bits on the named files (in +list+)\n  # to the bit pattern represented by +mode+.\n  # \n  #   FileUtils.chmod_R 0700, \"/tmp/app.#{$$}\"\n  # \n  def chmod_R(mode, list, options = {})\n    fu_check_options options, OPT_TABLE['chmod_R']\n    list = fu_list(list)\n    fu_output_message sprintf('chmod -R%s %o %s',\n                              (options[:force] ? 'f' : ''),\n                              mode, list.join(' ')) if options[:verbose]\n    return if options[:noop]\n    list.each do |root|\n      Entry_.new(root).traverse do |ent|\n        begin\n          ent.chmod mode\n        rescue\n          raise unless options[:force]\n        end\n      end\n    end\n  end\n  module_function :chmod_R\n\n  OPT_TABLE['chmod_R'] = [:noop, :verbose, :force]\n\n  #\n  # Options: noop verbose\n  # \n  # Changes owner and group on the named files (in +list+)\n  # to the user +user+ and the group +group+.  +user+ and +group+\n  # may be an ID (Integer/String) or a name (String).\n  # If +user+ or +group+ is nil, this method does not change\n  # the attribute.\n  # \n  #   FileUtils.chown 'root', 'staff', '/usr/local/bin/ruby'\n  #   FileUtils.chown nil, 'bin', Dir.glob('/usr/bin/*'), :verbose => true\n  # \n  def chown(user, group, list, options = {})\n    fu_check_options options, OPT_TABLE['chown']\n    list = fu_list(list)\n    fu_output_message sprintf('chown %s%s',\n                              [user,group].compact.join(':') + ' ',\n                              list.join(' ')) if options[:verbose]\n    return if options[:noop]\n    uid = fu_get_uid(user)\n    gid = fu_get_gid(group)\n    list.each do |path|\n      Entry_.new(path).chown uid, gid\n    end\n  end\n  module_function :chown\n\n  OPT_TABLE['chown'] = [:noop, :verbose]\n\n  #\n  # Options: noop verbose force\n  # \n  # Changes owner and group on the named files (in +list+)\n  # to the user +user+ and the group +group+ recursively.\n  # +user+ and +group+ may be an ID (Integer/String) or\n  # a name (String).  If +user+ or +group+ is nil, this\n  # method does not change the attribute.\n  # \n  #   FileUtils.chown_R 'www', 'www', '/var/www/htdocs'\n  #   FileUtils.chown_R 'cvs', 'cvs', '/var/cvs', :verbose =>"..., 4096) = 4096
read(3, "E['chown_R']\n    list = fu_list(list)\n    fu_output_message sprintf('chown -R%s %s%s',\n                              (options[:force] ? 'f' : ''),\n                              [user,group].compact.join(':') + ' ',\n                              list.join(' ')) if options[:verbose]\n    return if options[:noop]\n    uid = fu_get_uid(user)\n    gid = fu_get_gid(group)\n    return unless uid or gid\n    list.each do |root|\n      Entry_.new(root).traverse do |ent|\n        begin\n          ent.chown uid, gid\n        rescue\n          raise unless options[:force]\n        end\n      end\n    end\n  end\n  module_function :chown_R\n\n  OPT_TABLE['chown_R'] = [:noop, :verbose, :force]\n\n  begin\n    require 'etc'\n\n    def fu_get_uid(user)   #:nodoc:\n      return nil unless user\n      user = user.to_s\n      if /\\A\\d+\\z/ =~ user\n      then user.to_i\n      else Etc.getpwnam(user).uid\n      end\n    end\n    private_module_function :fu_get_uid\n\n    def fu_get_gid(group)   #:nodoc:\n      return nil unless group\n      if /\\A\\d+\\z/ =~ group\n      then group.to_i\n      else Etc.getgrnam(group).gid\n      end\n    end\n    private_module_function :fu_get_gid\n\n  rescue LoadError\n    # need Win32 support???\n\n    def fu_get_uid(user)   #:nodoc:\n      user    # FIXME\n    end\n    private_module_function :fu_get_uid\n\n    def fu_get_gid(group)   #:nodoc:\n      group   # FIXME\n    end\n    private_module_function :fu_get_gid\n  end\n\n  #\n  # Options: noop verbose\n  # \n  # Updates modification time (mtime) and access time (atime) of file(s) in\n  # +list+.  Files are created if they don't exist.\n  # \n  #   FileUtils.touch 'timestamp'\n  #   FileUtils.touch Dir.glob('*.c');  system 'make'\n  # \n  def touch(list, options = {})\n    fu_check_options options, OPT_TABLE['touch']\n    list = fu_list(list)\n    created = nocreate = options[:nocreate]\n    t = options[:mtime]\n    if options[:verbose]\n      fu_output_message \"touch #{nocreate ? ' -c' : ''}#{t ? t.strftime(' -t %Y%m%d%H%M.%S') : ''}#{list.join ' '}\"\n    end\n    return if options[:noop]\n    list.each do |path|\n      created = nocreate\n      begin\n        File.utime(t, t, path)\n      rescue Errno::ENOENT\n        raise if created\n        File.open(path, 'a') {\n          ;\n        }\n        created = true\n        retry if t\n      end\n    end\n  end\n  module_function :touch\n\n  OPT_TABLE['touch'] = [:noop, :verbose, :mtime, :nocreate]\n\n  private\n\n  module StreamUtils_\n    private\n\n    def fu_windows?\n      /mswin|mingw|bccwin|wince|emx/ =~ RUBY_PLATFORM\n    end\n\n    def fu_copy_stream0(src, dest, blksize)   #:nodoc:\n      # FIXME: readpartial?\n      while s = src.read(blksize)\n        dest.write s\n      end\n    end\n\n    def fu_stream_blksize(*streams)\n      streams.each do |s|\n        next unless s.respond_to?(:stat)\n        size = fu_blksize(s.stat)\n        return size if size\n      end\n      fu_default_blksize()\n    end\n\n    def fu_blksize(st)\n      s = st.blksize\n      return nil unless s\n      return nil if s == 0\n      s\n    end\n\n    def fu_default_blksize\n      1024\n    end\n  end\n\n  include StreamUtils_\n  extend StreamUtils_\n\n  class Entry_   #:nodoc: internal use only\n    include StreamUtils_\n\n    def initialize(a, b = nil, deref = false)\n      @prefix = @rel = @path = nil\n      if b\n        @prefix = a\n        @rel = b\n      else\n        @path = a\n      end\n      @deref = deref\n      @stat = nil\n      @lstat = nil\n    end\n\n    def inspect\n      \"\\#<#{self.class} #{path()}>\"\n    end\n\n    def path\n      if @path\n        @path.to_str\n      else\n        join(@prefix, @rel)\n      end\n    end\n\n    def prefix\n      @prefix || @path\n    end\n\n    def rel\n      @rel\n    end\n\n    def dereference?\n      @deref\n    end\n\n    def exist?\n      lstat! ? true : false\n    end\n\n    def file?\n      s = lstat!\n      s and s.file?\n    end\n\n    def directory?\n      s = lstat!\n      s and s.directory?\n    end\n\n    def symlink?\n      s = lstat!\n      s and s.symlink?\n    end\n\n    def chardev?\n      s = lstat!\n      s and s.chardev?\n    end\n\n    def b"..., 4096) = 4096
read(3, "  s and s.socket?\n    end\n\n    def pipe?\n      s = lstat!\n      s and s.pipe?\n    end\n\n    S_IF_DOOR = 0xD000\n\n    def door?\n      s = lstat!\n      s and (s.mode & 0xF000 == S_IF_DOOR)\n    end\n\n    def entries\n      Dir.entries(path())\\\n          .reject {|n| n == '.' or n == '..' }\\\n          .map {|n| Entry_.new(prefix(), join(rel(), n.untaint)) }\n    end\n\n    def stat\n      return @stat if @stat\n      if lstat() and lstat().symlink?\n        @stat = File.stat(path())\n      else\n        @stat = lstat()\n      end\n      @stat\n    end\n\n    def stat!\n      return @stat if @stat\n      if lstat! and lstat!.symlink?\n        @stat = File.stat(path())\n      else\n        @stat = lstat!\n      end\n      @stat\n    rescue SystemCallError\n      nil\n    end\n\n    def lstat\n      if dereference?\n        @lstat ||= File.stat(path())\n      else\n        @lstat ||= File.lstat(path())\n      end\n    end\n\n    def lstat!\n      lstat()\n    rescue SystemCallError\n      nil\n    end\n\n    def chmod(mode)\n      if symlink?\n        File.lchmod mode, path() if have_lchmod?\n      else\n        File.chmod mode, path()\n      end\n    end\n\n    def chown(uid, gid)\n      if symlink?\n        File.lchown uid, gid, path() if have_lchown?\n      else\n        File.chown uid, gid, path()\n      end\n    end\n\n    def copy(dest)\n      case\n      when file?\n        copy_file dest\n      when directory?\n        begin\n          Dir.mkdir dest\n        rescue\n          raise unless File.directory?(dest)\n        end\n      when symlink?\n        File.symlink File.readlink(path()), dest\n      when chardev?\n        raise \"cannot handle device file\" unless File.respond_to?(:mknod)\n        mknod dest, ?c, 0666, lstat().rdev\n      when blockdev?\n        raise \"cannot handle device file\" unless File.respond_to?(:mknod)\n        mknod dest, ?b, 0666, lstat().rdev\n      when socket?\n        raise \"cannot handle socket\" unless File.respond_to?(:mknod)\n        mknod dest, nil, lstat().mode, 0\n      when pipe?\n        raise \"cannot handle FIFO\" unless File.respond_to?(:mkfifo)\n        mkfifo dest, 0666\n      when door?\n        raise \"cannot handle door: #{path()}\"\n      else\n        raise \"unknown file type: #{path()}\"\n      end\n    end\n\n    def copy_file(dest)\n      st = stat()\n      File.open(path(),  'rb') {|r|\n        File.open(dest, 'wb', st.mode) {|w|\n          fu_copy_stream0 r, w, (fu_blksize(st) || fu_default_blksize())\n        }\n      }\n    end\n\n    def copy_metadata(path)\n      st = lstat()\n      File.utime st.atime, st.mtime, path\n      begin\n        File.chown st.uid, st.gid, path\n      rescue Errno::EPERM\n        # clear setuid/setgid\n        File.chmod st.mode & 01777, path\n      else\n        File.chmod st.mode, path\n      end\n    end\n\n    def remove\n      if directory?\n        remove_dir1\n      else\n        remove_file\n      end\n    end\n\n    def remove_dir1\n      platform_support {\n        Dir.rmdir path().sub(%r</\\z>, '')\n      }\n    end\n\n    def remove_file\n      platform_support {\n        File.unlink path\n      }\n    end\n\n    def platform_support\n      return yield unless fu_windows?\n      first_time_p = true\n      begin\n        yield\n      rescue Errno::ENOENT\n        raise\n      rescue => err\n        if first_time_p\n          first_time_p = false\n          begin\n            File.chmod 0700, path()   # Windows does not have symlink\n            retry\n          rescue SystemCallError\n          end\n        end\n        raise err\n      end\n    end\n\n    def preorder_traverse\n      stack = [self]\n      while ent = stack.pop\n        yield ent\n        stack.concat ent.entries.reverse if ent.directory?\n      end\n    end\n\n    alias traverse preorder_traverse\n\n    def postorder_traverse\n      if directory?\n        entries().each do |ent|\n          ent.postorder_traverse do |e|\n            yield e\n          end\n        end\n      end\n      yield self\n    end\n\n    private\n\n    $fileutils_rb_have_lchmod = nil\n\n    def have_lchmod?\n      # This is not MT-safe, but it does not matter.\n      if $f"..., 4096) = 4096
brk(0x9f23000)                          = 0x9f23000
read(3, "      $fileutils_rb_have_lchmod\n    end\n\n    def check_have_lchmod?\n      return false unless File.respond_to?(:lchmod)\n      File.lchmod 0\n      return true\n    rescue NotImplementedError\n      return false\n    end\n\n    $fileutils_rb_have_lchown = nil\n\n    def have_lchown?\n      # This is not MT-safe, but it does not matter.\n      if $fileutils_rb_have_lchown == nil\n        $fileutils_rb_have_lchown = check_have_lchown?\n      end\n      $fileutils_rb_have_lchown\n    end\n\n    def check_have_lchown?\n      return false unless File.respond_to?(:lchown)\n      File.lchown nil, nil\n      return true\n    rescue NotImplementedError\n      return false\n    end\n\n    def join(dir, base)\n      return dir.to_str if not base or base == '.'\n      return base.to_str if not dir or dir == '.'\n      File.join(dir, base)\n    end\n  end   # class Entry_\n\n  def fu_list(arg)   #:nodoc:\n    [arg].flatten.map {|path| path.to_str }\n  end\n  private_module_function :fu_list\n\n  def fu_each_src_dest(src, dest)   #:nodoc:\n    fu_each_src_dest0(src, dest) do |s, d|\n      raise ArgumentError, \"same file: #{s} and #{d}\" if fu_same?(s, d)\n      yield s, d\n    end\n  end\n  private_module_function :fu_each_src_dest\n\n  def fu_each_src_dest0(src, dest)   #:nodoc:\n    if src.is_a?(Array)\n      src.each do |s|\n        s = s.to_str\n        yield s, File.join(dest, File.basename(s))\n      end\n    else\n      src = src.to_str\n      if File.directory?(dest)\n        yield src, File.join(dest, File.basename(src))\n      else\n        yield src, dest.to_str\n      end\n    end\n  end\n  private_module_function :fu_each_src_dest0\n\n  def fu_same?(a, b)   #:nodoc:\n    if fu_have_st_ino?\n      st1 = File.stat(a)\n      st2 = File.stat(b)\n      st1.dev == st2.dev and st1.ino == st2.ino\n    else\n      File.expand_path(a) == File.expand_path(b)\n    end\n  rescue Errno::ENOENT\n    return false\n  end\n  private_module_function :fu_same?\n\n  def fu_have_st_ino?   #:nodoc:\n    not fu_windows?\n  end\n  private_module_function :fu_have_st_ino?\n\n  def fu_check_options(options, optdecl)   #:nodoc:\n    h = options.dup\n    optdecl.each do |opt|\n      h.delete opt\n    end\n    raise ArgumentError, \"no such option: #{h.keys.join(' ')}\" unless h.empty?\n  end\n  private_module_function :fu_check_options\n\n  def fu_update_option(args, new)   #:nodoc:\n    if args.last.is_a?(Hash)\n      args[-1] = args.last.dup.update(new)\n    else\n      args.push new\n    end\n    args\n  end\n  private_module_function :fu_update_option\n\n  @fileutils_output = $stderr\n  @fileutils_label  = ''\n\n  def fu_output_message(msg)   #:nodoc:\n    @fileutils_output ||= $stderr\n    @fileutils_label  ||= ''\n    @fileutils_output.puts @fileutils_label + msg\n  end\n  private_module_function :fu_output_message\n\n  #\n  # Returns an Array of method names which have any options.\n  #\n  #   p FileUtils.commands  #=> [\"chmod\", \"cp\", \"cp_r\", \"install\", ...]\n  #\n  def FileUtils.commands\n    OPT_TABLE.keys\n  end\n\n  #\n  # Returns an Array of option names.\n  #\n  #   p FileUtils.options  #=> [\"noop\", \"force\", \"verbose\", \"preserve\", \"mode\"]\n  #\n  def FileUtils.options\n    OPT_TABLE.values.flatten.uniq.map {|sym| sym.to_s }\n  end\n\n  #\n  # Returns true if the method +mid+ have an option +opt+.\n  #\n  #   p FileUtils.have_option?(:cp, :noop)     #=> true\n  #   p FileUtils.have_option?(:rm, :force)    #=> true\n  #   p FileUtils.have_option?(:rm, :perserve) #=> false\n  #\n  def FileUtils.have_option?(mid, opt)\n    li = OPT_TABLE[mid.to_s] or raise ArgumentError, \"no such method: #{mid}\"\n    li.include?(opt)\n  end\n\n  #\n  # Returns an Array of option names of the method +mid+.\n  #\n  #   p FileUtils.options(:rm)  #=> [\"noop\", \"verbose\", \"force\"]\n  #\n  def FileUtils.options_of(mid)\n    OPT_TABLE[mid.to_s].map {|sym| sym.to_s }\n  end\n\n  #\n  # Returns an Array of method names which have the option +opt+.\n  #\n  #   p FileUtils.collect_method(:preserve) #=> [\"cp\", \"cp_r\", \"copy\", \"install\"]\n  #\n  def FileUtils.collect_method(opt)\n    OPT_TABLE.keys.select {|m| OPT_TABLE[m].include?"..., 4096) = 4096
read(3, "ons have_option? options_of collect_method )\n\n  # \n  # This module has all methods of FileUtils module, but it outputs messages\n  # before acting.  This equates to passing the <tt>:verbose</tt> flag to\n  # methods in FileUtils.\n  # \n  module Verbose\n    include FileUtils\n    @fileutils_output  = $stderr\n    @fileutils_label   = ''\n    ::FileUtils.collect_method(:verbose).each do |name|\n      module_eval(<<-EOS, __FILE__, __LINE__ + 1)\n        def #{name}(*args)\n          super(*fu_update_option(args, :verbose => true))\n        end\n        private :#{name}\n      EOS\n    end\n    extend self\n    class << self\n      ::FileUtils::METHODS.each do |m|\n        public m\n      end\n    end\n  end\n\n  # \n  # This module has all methods of FileUtils module, but never changes\n  # files/directories.  This equates to passing the <tt>:noop</tt> flag\n  # to methods in FileUtils.\n  # \n  module NoWrite\n    include FileUtils\n    @fileutils_output  = $stderr\n    @fileutils_label   = ''\n    ::FileUtils.collect_method(:noop).each do |name|\n      module_eval(<<-EOS, __FILE__, __LINE__ + 1)\n        def #{name}(*args)\n          super(*fu_update_option(args, :noop => true))\n        end\n        private :#{name}\n      EOS\n    end\n    extend self\n    class << self\n      ::FileUtils::METHODS.each do |m|\n        public m\n      end\n    end\n  end\n\n  # \n  # This module has all methods of FileUtils module, but never changes\n  # files/directories, with printing message before acting.\n  # This equates to passing the <tt>:noop</tt> and <tt>:verbose</tt> flag\n  # to methods in FileUtils.\n  # \n  module DryRun\n    include FileUtils\n    @fileutils_output  = $stderr\n    @fileutils_label   = ''\n    ::FileUtils.collect_method(:noop).each do |name|\n      module_eval(<<-EOS, __FILE__, __LINE__ + 1)\n        def #{name}(*args)\n          super(*fu_update_option(args, :noop => true, :verbose => true))\n        end\n        private :#{name}\n      EOS\n    end\n    extend self\n    class << self\n      ::FileUtils::METHODS.each do |m|\n        public m\n      end\n    end\n  end\n\nend\n", 4096) = 2054
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/etc.rb", 0xbfe46740) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/etc.so", 0xbfe46740) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/etc.rb", 0xbfe46740) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/etc.so", 0xbfe46740) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/etc.rb", 0xbfe46740) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/etc.so", 0xbfe46740) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/etc.rb", 0xbfe46740) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/etc.so", 0xbfe46740) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/etc.rb", 0xbfe46740) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/etc.so", 0xbfe46740) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/etc.rb", 0xbfe46740) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/etc.so", 0xbfe46740) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/etc.rb", 0xbfe46740) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/etc.so", 0xbfe46740) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/etc.rb", 0xbfe46740) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/etc.so", 0xbfe46740) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i486-linux/etc.rb", 0xbfe46740) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/i486-linux/etc.so", {st_mode=S_IFREG|0644, st_size=9592, ...}) = 0
open("/usr/lib/ruby/1.8/i486-linux/etc.so", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=9592, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/cache", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/doc", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/home/davidw", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
getuid32()                              = 1000
socket(PF_FILE, 0x80801 /* SOCK_??? */, 0) = 3
connect(3, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
close(3)                                = 0
socket(PF_FILE, 0x80801 /* SOCK_??? */, 0) = 3
connect(3, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
close(3)                                = 0
open("/etc/nsswitch.conf", O_RDONLY)    = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=513, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
read(3, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference' and `info' packages installed, try:\n# `info libc \"Name Service Switch\"' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files mdns4_minimal [NOTFOUND=return] dns mdns4\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 513
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
open("/etc/ld.so.cache", O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=60535, ...}) = 0
mmap2(NULL, 60535, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7853000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\16\0\0004\0\0\0\230b\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\325[\0\0\325[\0\0\325[\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\^\0\0\\^\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340^\0\0\340n\0\0\340n\0\0\250\2\0\0l\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364^\0\0\364n\0\0\364n\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0D\0\0\0D\0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340^\0\0\340n\0\0\340n\0\0 \1\0\0 \1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0l\324\333\252\320M\335m\257D=3\253\332\264\220\373\342\235\326\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\17\0\0\0\32\0\0\0%\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201%\0\0\0&\0\0\0'\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\0\0\0)\0\0\0*\0\0\0\0\0\0\0,\0\0\0\0\0\0\0\0\0\0\0.\0\0\0/\0\0\0000\0\0\0\0\0\0\0\0\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0", 512) = 512
fstat64(3, {st_mode=S_IFREG|0644, st_size=26400, ...}) = 0
mmap2(NULL, 29260, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7b1000
mmap2(0x7b7000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x5) = 0x7b7000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\2201\0\0004\0\0\0\2642\1\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\33\1\0\340\33\1\0\340\33\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$'\1\0$'\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300.\1\0\300>\1\0\300>\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324.\1\0\324>\1\0\324>\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0D\0\0\0D\0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300.\1\0\300>\1\0\300>\1\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\235\326\n\4\3\371\332b\273\3043\17\236\336gI\336kx\365\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\17\0\0\0\374\0\0\0r\0\0\0 \0\0\0\n\0\0\0\1\1$\232 'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212", 512) = 512
fstat64(3, {st_mode=S_IFREG|0644, st_size=79676, ...}) = 0
mmap2(NULL, 92136, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x5b6000
mmap2(0x5c9000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x12) = 0x5c9000
mmap2(0x5cb000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x5cb000
close(3)                                = 0
mprotect(0x5c9000, 4096, PROT_READ)     = 0
mprotect(0x7b7000, 4096, PROT_READ)     = 0
munmap(0xb7853000, 60535)               = 0
open("/etc/ld.so.cache", O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=60535, ...}) = 0
mmap2(NULL, 60535, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7853000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\31\0\0004\0\0\0\340\221\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\310{\0\0\310{\0\0\310{\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\250\200\0\0\250\200\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334\216\0\0\334\236\0\0\334\236\0\0\364\1\0\0\\\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360\216\0\0\360\236\0\0\360\236\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0D\0\0\0D\0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334\216\0\0\334\236\0\0\334\236\0\0$\1\0\0$\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\313W`j\326\215\344\275\274\1\203Q\254\372\266$\223-$\367\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\17\0\0\0g\0\0\0/\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 C@\310\224\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0/\0\0\0000\0\0\0\0\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
fstat64(3, {st_mode=S_IFREG|0644, st_size=38504, ...}) = 0
mmap2(NULL, 41528, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x130000
mmap2(0x139000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x8) = 0x139000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \32\0\0004\0\0\0\304\241\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\375\216\0\0\375\216\0\0\375\216\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0D\224\0\0D\224\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\236\0\0\350\256\0\0\350\256\0\0\314\1\0\0\344\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\236\0\0\374\256\0\0\374\256\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0D\0\0\0D\0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\236\0\0\350\256\0\0\350\256\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\5\276\177\34\32p@\306Uy\220\347Qb\361\220\16\367O\314\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\17\0\0\0k\0\0\0/\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\260\241\245\1\31\10\200\20\203\6\212\10\0\200\322@]\1(\nx\10 \"\220\200\20,\7\3\205\24)!\22<\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300/\0\0\0000\0\0\0\0\0\0\0001\0\0\0002\0\0\0003\0\0\0004\0\0\0005\0\0\0\0\0\0\0006\0\0\0\0\0\0\0007\0\0\0009\0\0\0:\0\0\0", 512) = 512
fstat64(3, {st_mode=S_IFREG|0644, st_size=42572, ...}) = 0
mmap2(NULL, 45772, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x13b000
mmap2(0x145000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x9) = 0x145000
close(3)                                = 0
mprotect(0x145000, 4096, PROT_READ)     = 0
mprotect(0x139000, 4096, PROT_READ)     = 0
munmap(0xb7853000, 60535)               = 0
open("/etc/passwd", O_RDONLY|O_CLOEXEC) = 3
fcntl64(3, F_GETFD)                     = 0x1 (flags FD_CLOEXEC)
_llseek(3, 0, [0], SEEK_CUR)            = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=1751, ...}) = 0
mmap2(NULL, 1751, PROT_READ, MAP_SHARED, 3, 0) = 0xb7861000
_llseek(3, 1751, [1751], SEEK_SET)      = 0
munmap(0xb7861000, 1751)                = 0
close(3)                                = 0
getuid32()                              = 1000
open("/etc/passwd", O_RDONLY|O_CLOEXEC) = 3
_llseek(3, 0, [0], SEEK_CUR)            = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=1751, ...}) = 0
mmap2(NULL, 1751, PROT_READ, MAP_SHARED, 3, 0) = 0xb7861000
_llseek(3, 1751, [1751], SEEK_SET)      = 0
munmap(0xb7861000, 1751)                = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/home/davidw", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/fileutils.rb", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/fileutils.so", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/fileutils.rb", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/fileutils.so", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/fileutils.rb", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/fileutils.so", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/fileutils.rb", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/fileutils.so", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/fileutils.rb", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/fileutils.so", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/fileutils.rb", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/fileutils.so", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/fileutils.rb", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/fileutils.so", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/fileutils.rb", {st_mode=S_IFREG|0644, st_size=43014, ...}) = 0
open("/usr/lib/ruby/1.8/fileutils.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=43014, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/home/davidw/.gem/ruby/1.8/cache", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/home/davidw/.gem/ruby/1.8/doc", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/home/davidw/.gem/ruby/1.8/gems", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/home/davidw/.gem/ruby/1.8/specifications", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/local/lib/site_ruby/1.8/fileutils.rb", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/fileutils.so", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/fileutils.rb", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/fileutils.so", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/fileutils.rb", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/fileutils.so", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/fileutils.rb", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/fileutils.so", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/fileutils.rb", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/fileutils.so", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/fileutils.rb", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/fileutils.so", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/fileutils.rb", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/fileutils.so", 0xbfe49620) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/fileutils.rb", {st_mode=S_IFREG|0644, st_size=43014, ...}) = 0
open("/usr/lib/ruby/1.8/fileutils.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=43014, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/cache", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/doc", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/gems/1.8/specifications", O_RDONLY|O_NONBLOCK|O_LARGEFILE|O_DIRECTORY|O_CLOEXEC) = 3
fcntl64(3, F_GETFD)                     = 0x1 (flags FD_CLOEXEC)
brk(0x9f4b000)                          = 0x9f4b000
getdents64(3, /* 34 entries */, 32768)  = 1536
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
getdents64(3, /* 0 entries */, 32768)   = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/actionpack-2.3.5.gemspec", {st_mode=S_IFREG|0644, st_size=20619, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/actionpack-2.3.5.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=20619, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=20619, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{actionpack}\n  s.version = \"2.3.5\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"David Heinemeier Hansson\"]\n  s.autorequire = %q{action_controller}\n  s.date = %q{2009-11-26}\n  s.description = %q{Eases web-request routing, handling, and response as a half-way front, half-way page controller. Implemented with specific emphasis on enabling easy unit/integration testing that doesn't require a browser.}\n  s.email = %q{david@loudthinking.com}\n  s.files = [\"Rakefile\", \"install.rb\", \"README\", \"RUNNING_UNIT_TESTS\", \"CHANGELOG\", \"MIT-LICENSE\", \"lib/action_controller/assertions/dom_assertions.rb\", \"lib/action_controller/assertions/model_assertions.rb\", \"lib/action_controller/assertions/response_assertions.rb\", \"lib/action_controller/assertions/routing_assertions.rb\", \"lib/action_controller/assertions/selector_assertions.rb\", \"lib/action_controller/assertions/tag_assertions.rb\", \"lib/action_controller/base.rb\", \"lib/action_controller/benchmarking.rb\", \"lib/action_controller/caching/actions.rb\", \"lib/action_controller/caching/fragments.rb\", \"lib/action_controller/caching/pages.rb\", \"lib/action_controller/caching/sweeper.rb\", \"lib/action_controller/caching/sweeping.rb\", \"lib/action_controller/caching.rb\", \"lib/action_controller/cgi_ext/cookie.rb\", \"lib/action_controller/cgi_ext/query_extension.rb\", \"lib/action_controller/cgi_ext/stdinput.rb\", \"lib/action_controller/cgi_ext.rb\", \"lib/action_controller/cgi_process.rb\", \"lib/action_controller/cookies.rb\", \"lib/action_controller/dispatcher.rb\", \"lib/action_controller/failsafe.rb\", \"lib/action_controller/filters.rb\", \"lib/action_controller/flash.rb\", \"lib/action_controller/headers.rb\", \"lib/action_controller/helpers.rb\", \"lib/action_controller/http_authentication.rb\", \"lib/action_controller/integration.rb\", \"lib/action_controller/layout.rb\", \"lib/action_controller/middleware_stack.rb\", \"lib/action_controller/middlewares.rb\", \"lib/action_controller/mime_responds.rb\", \"lib/action_controller/mime_type.rb\", \"lib/action_controller/mime_types.rb\", \"lib/action_controller/params_parser.rb\", \"lib/action_controller/performance_test.rb\", \"lib/action_controller/polymorphic_routes.rb\", \"lib/action_controller/rack_lint_patch.rb\", \"lib/action_controller/record_identifier.rb\", \"lib/action_controller/reloader.rb\", \"lib/action_controller/request.rb\", \"lib/action_controller/request_forgery_protection.rb\", \"lib/action_controller/rescue.rb\", \"lib/action_controller/resources.rb\", \"lib/action_controller/response.rb\", \"lib/action_controller/routing/builder.rb\", \"lib/action_controller/routing/optimisations.rb\", \"lib/action_controller/routing/recognition_optimisation.rb\", \"lib/action_controller/routing/route.rb\", \"lib/action_controller/routing/route_set.rb\", \"lib/action_controller/routing/routing_ext.rb\", \"lib/action_controller/routing/segments.rb\", \"lib/action_controller/routing.rb\", \"lib/action_controller/session/abstract_store.rb\", \"lib/action_controller/session/cookie_store.rb\", \"lib/action_controller/session/mem_cache_store.rb\", \"lib/action_controller/session_management.rb\", \"lib/action_controller/status_codes.rb\", \"lib/action_controller/streaming.rb\", \"lib/action_controller/string_coercion.rb\", \"lib/action_controller/templates/rescues/_request_and_response.erb\", \"lib/action_controller/templates/rescues/_trace.erb\", \"lib/action_controller/templates/rescues/diagnostics.erb\", \"lib/action_controller/templates/rescues/layout.erb\", \"lib/action_controller/templates/rescues/missing_template.erb\", \"lib/action_controller/templates/rescues/routing_error.erb\", \"lib/action_controller/templates/rescues/template_error.erb\", \"lib/action_controller/templates/rescues/unknown_action.erb\", \"lib/action_controller/test_case.rb\", \"lib/action_controller/test_process.rb\", \"lib/action_controller/translation.rb\", \"lib/action_controller/uploaded_file.rb\", \"lib/action_controller/url_rewriter.rb\", \"l"..., 4096) = 4096
read(3, "canner/html/node.rb\", \"lib/action_controller/vendor/html-scanner/html/sanitizer.rb\", \"lib/action_controller/vendor/html-scanner/html/selector.rb\", \"lib/action_controller/vendor/html-scanner/html/tokenizer.rb\", \"lib/action_controller/vendor/html-scanner/html/version.rb\", \"lib/action_controller/vendor/html-scanner.rb\", \"lib/action_controller/verification.rb\", \"lib/action_controller.rb\", \"lib/action_pack/version.rb\", \"lib/action_pack.rb\", \"lib/action_view/base.rb\", \"lib/action_view/erb/util.rb\", \"lib/action_view/helpers/active_record_helper.rb\", \"lib/action_view/helpers/asset_tag_helper.rb\", \"lib/action_view/helpers/atom_feed_helper.rb\", \"lib/action_view/helpers/benchmark_helper.rb\", \"lib/action_view/helpers/cache_helper.rb\", \"lib/action_view/helpers/capture_helper.rb\", \"lib/action_view/helpers/date_helper.rb\", \"lib/action_view/helpers/debug_helper.rb\", \"lib/action_view/helpers/form_helper.rb\", \"lib/action_view/helpers/form_options_helper.rb\", \"lib/action_view/helpers/form_tag_helper.rb\", \"lib/action_view/helpers/javascript_helper.rb\", \"lib/action_view/helpers/number_helper.rb\", \"lib/action_view/helpers/prototype_helper.rb\", \"lib/action_view/helpers/raw_output_helper.rb\", \"lib/action_view/helpers/record_identification_helper.rb\", \"lib/action_view/helpers/record_tag_helper.rb\", \"lib/action_view/helpers/sanitize_helper.rb\", \"lib/action_view/helpers/scriptaculous_helper.rb\", \"lib/action_view/helpers/tag_helper.rb\", \"lib/action_view/helpers/text_helper.rb\", \"lib/action_view/helpers/translation_helper.rb\", \"lib/action_view/helpers/url_helper.rb\", \"lib/action_view/helpers.rb\", \"lib/action_view/inline_template.rb\", \"lib/action_view/locale/en.yml\", \"lib/action_view/partials.rb\", \"lib/action_view/paths.rb\", \"lib/action_view/reloadable_template.rb\", \"lib/action_view/renderable.rb\", \"lib/action_view/renderable_partial.rb\", \"lib/action_view/safe_buffer.rb\", \"lib/action_view/template.rb\", \"lib/action_view/template_error.rb\", \"lib/action_view/template_handler.rb\", \"lib/action_view/template_handlers/builder.rb\", \"lib/action_view/template_handlers/erb.rb\", \"lib/action_view/template_handlers/rjs.rb\", \"lib/action_view/template_handlers.rb\", \"lib/action_view/test_case.rb\", \"lib/action_view.rb\", \"lib/actionpack.rb\", \"test/abstract_unit.rb\", \"test/active_record_unit.rb\", \"test/activerecord/active_record_store_test.rb\", \"test/activerecord/render_partial_with_record_identification_test.rb\", \"test/adv_attr_test.rb\", \"test/controller/action_pack_assertions_test.rb\", \"test/controller/addresses_render_test.rb\", \"test/controller/assert_select_test.rb\", \"test/controller/base_test.rb\", \"test/controller/benchmark_test.rb\", \"test/controller/caching_test.rb\", \"test/controller/capture_test.rb\", \"test/controller/content_type_test.rb\", \"test/controller/controller_fixtures/app/controllers/admin/user_controller.rb\", \"test/controller/controller_fixtures/app/controllers/user_controller.rb\", \"test/controller/controller_fixtures/vendor/plugins/bad_plugin/lib/plugin_controller.rb\", \"test/controller/cookie_test.rb\", \"test/controller/deprecation/deprecated_base_methods_test.rb\", \"test/controller/dispatcher_test.rb\", \"test/controller/dom_assertions_test.rb\", \"test/controller/failsafe_test.rb\", \"test/controller/fake_controllers.rb\", \"test/controller/fake_models.rb\", \"test/controller/filter_params_test.rb\", \"test/controller/filters_test.rb\", \"test/controller/flash_test.rb\", \"test/controller/header_test.rb\", \"test/controller/helper_test.rb\", \"test/controller/html-scanner/cdata_node_test.rb\", \"test/controller/html-scanner/document_test.rb\", \"test/controller/html-scanner/node_test.rb\", \"test/controller/html-scanner/sanitizer_test.rb\", \"test/controller/html-scanner/tag_node_test.rb\", \"test/controller/html-scanner/text_node_test.rb\", \"test/controller/html-scanner/tokenizer_test.rb\", \"test/controller/http_basic_authentication_test.rb\", \"test/controller/http_digest_authentication_test.rb\", \"test/controller/integration_test.rb\", \"test/controller/layout_test.rb\", \"test/controller/loggi"..., 4096) = 4096
read(3, ", \"test/controller/mime_type_test.rb\", \"test/controller/polymorphic_routes_test.rb\", \"test/controller/rack_test.rb\", \"test/controller/record_identifier_test.rb\", \"test/controller/redirect_test.rb\", \"test/controller/reloader_test.rb\", \"test/controller/render_test.rb\", \"test/controller/request/json_params_parsing_test.rb\", \"test/controller/request/multipart_params_parsing_test.rb\", \"test/controller/request/query_string_parsing_test.rb\", \"test/controller/request/test_request_test.rb\", \"test/controller/request/url_encoded_params_parsing_test.rb\", \"test/controller/request/xml_params_parsing_test.rb\", \"test/controller/request_forgery_protection_test.rb\", \"test/controller/request_test.rb\", \"test/controller/rescue_test.rb\", \"test/controller/resources_test.rb\", \"test/controller/routing_test.rb\", \"test/controller/selector_test.rb\", \"test/controller/send_file_test.rb\", \"test/controller/session/cookie_store_test.rb\", \"test/controller/session/mem_cache_store_test.rb\", \"test/controller/session/test_session_test.rb\", \"test/controller/test_test.rb\", \"test/controller/translation_test.rb\", \"test/controller/url_rewriter_test.rb\", \"test/controller/verification_test.rb\", \"test/controller/view_paths_test.rb\", \"test/controller/webservice_test.rb\", \"test/fixtures/_top_level_partial.html.erb\", \"test/fixtures/_top_level_partial_only.erb\", \"test/fixtures/addresses/list.erb\", \"test/fixtures/alternate_helpers/foo_helper.rb\", \"test/fixtures/bad_customers/_bad_customer.html.erb\", \"test/fixtures/companies.yml\", \"test/fixtures/company.rb\", \"test/fixtures/content_type/render_default_content_types_for_respond_to.rhtml\", \"test/fixtures/content_type/render_default_for_rhtml.rhtml\", \"test/fixtures/content_type/render_default_for_rjs.rjs\", \"test/fixtures/content_type/render_default_for_rxml.rxml\", \"test/fixtures/customers/_customer.html.erb\", \"test/fixtures/db_definitions/sqlite.sql\", \"test/fixtures/developer.rb\", \"test/fixtures/developers/_developer.erb\", \"test/fixtures/developers.yml\", \"test/fixtures/developers_projects.yml\", \"test/fixtures/failsafe/500.html\", \"test/fixtures/fun/games/_game.erb\", \"test/fixtures/fun/games/hello_world.erb\", \"test/fixtures/fun/serious/games/_game.erb\", \"test/fixtures/functional_caching/_partial.erb\", \"test/fixtures/functional_caching/formatted_fragment_cached.html.erb\", \"test/fixtures/functional_caching/formatted_fragment_cached.js.rjs\", \"test/fixtures/functional_caching/formatted_fragment_cached.xml.builder\", \"test/fixtures/functional_caching/fragment_cached.html.erb\", \"test/fixtures/functional_caching/html_fragment_cached_with_partial.html.erb\", \"test/fixtures/functional_caching/inline_fragment_cached.html.erb\", \"test/fixtures/functional_caching/js_fragment_cached_with_partial.js.rjs\", \"test/fixtures/good_customers/_good_customer.html.erb\", \"test/fixtures/helpers/abc_helper.rb\", \"test/fixtures/helpers/fun/games_helper.rb\", \"test/fixtures/helpers/fun/pdf_helper.rb\", \"test/fixtures/layout_tests/abs_path_layout.rhtml\", \"test/fixtures/layout_tests/alt/hello.rhtml\", \"test/fixtures/layout_tests/alt/layouts/alt.rhtml\", \"test/fixtures/layout_tests/layouts/controller_name_space/nested.rhtml\", \"test/fixtures/layout_tests/layouts/item.rhtml\", \"test/fixtures/layout_tests/layouts/layout_test.rhtml\", \"test/fixtures/layout_tests/layouts/multiple_extensions.html.erb\", \"test/fixtures/layout_tests/layouts/third_party_template_library.mab\", \"test/fixtures/layout_tests/views/hello.rhtml\", \"test/fixtures/layouts/_column.html.erb\", \"test/fixtures/layouts/block_with_layout.erb\", \"test/fixtures/layouts/builder.builder\", \"test/fixtures/layouts/default_html.html.erb\", \"test/fixtures/layouts/partial_with_layout.erb\", \"test/fixtures/layouts/standard.erb\", \"test/fixtures/layouts/talk_from_action.erb\", \"test/fixtures/layouts/xhr.html.erb\", \"test/fixtures/layouts/yield.erb\", \"test/fixtures/mascot.rb\", \"test/fixtures/mascots/_mascot.html.erb\", \"test/fixtures/mascots.yml\", \"test/fixtures/multipart/binary_file\", \"test/fixtures/multipart/boundary_problem_file\", \"te"..., 4096) = 4096
read(3, "t/hello.txt\", \"test/fixtures/multipart/large_text_file\", \"test/fixtures/multipart/mixed_files\", \"test/fixtures/multipart/mona_lisa.jpg\", \"test/fixtures/multipart/none\", \"test/fixtures/multipart/single_parameter\", \"test/fixtures/multipart/text_file\", \"test/fixtures/override/test/hello_world.erb\", \"test/fixtures/override2/layouts/test/sub.erb\", \"test/fixtures/post_test/layouts/post.html.erb\", \"test/fixtures/post_test/layouts/super_post.iphone.erb\", \"test/fixtures/post_test/post/index.html.erb\", \"test/fixtures/post_test/post/index.iphone.erb\", \"test/fixtures/post_test/super_post/index.html.erb\", \"test/fixtures/post_test/super_post/index.iphone.erb\", \"test/fixtures/project.rb\", \"test/fixtures/projects/_project.erb\", \"test/fixtures/projects.yml\", \"test/fixtures/public/404.html\", \"test/fixtures/public/500.da.html\", \"test/fixtures/public/500.html\", \"test/fixtures/public/absolute/test.css\", \"test/fixtures/public/absolute/test.js\", \"test/fixtures/public/images/rails.png\", \"test/fixtures/public/javascripts/application.js\", \"test/fixtures/public/javascripts/bank.js\", \"test/fixtures/public/javascripts/controls.js\", \"test/fixtures/public/javascripts/dragdrop.js\", \"test/fixtures/public/javascripts/effects.js\", \"test/fixtures/public/javascripts/prototype.js\", \"test/fixtures/public/javascripts/robber.js\", \"test/fixtures/public/javascripts/subdir/subdir.js\", \"test/fixtures/public/javascripts/version.1.0.js\", \"test/fixtures/public/stylesheets/bank.css\", \"test/fixtures/public/stylesheets/robber.css\", \"test/fixtures/public/stylesheets/subdir/subdir.css\", \"test/fixtures/public/stylesheets/version.1.0.css\", \"test/fixtures/quiz/questions/_question.html.erb\", \"test/fixtures/replies/_reply.erb\", \"test/fixtures/replies.yml\", \"test/fixtures/reply.rb\", \"test/fixtures/respond_to/all_types_with_layout.html.erb\", \"test/fixtures/respond_to/all_types_with_layout.js.rjs\", \"test/fixtures/respond_to/custom_constant_handling_without_block.mobile.erb\", \"test/fixtures/respond_to/iphone_with_html_response_type.html.erb\", \"test/fixtures/respond_to/iphone_with_html_response_type.iphone.erb\", \"test/fixtures/respond_to/layouts/missing.html.erb\", \"test/fixtures/respond_to/layouts/standard.html.erb\", \"test/fixtures/respond_to/layouts/standard.iphone.erb\", \"test/fixtures/respond_to/using_defaults.html.erb\", \"test/fixtures/respond_to/using_defaults.js.rjs\", \"test/fixtures/respond_to/using_defaults.xml.builder\", \"test/fixtures/respond_to/using_defaults_with_type_list.html.erb\", \"test/fixtures/respond_to/using_defaults_with_type_list.js.rjs\", \"test/fixtures/respond_to/using_defaults_with_type_list.xml.builder\", \"test/fixtures/scope/test/modgreet.erb\", \"test/fixtures/shared.html.erb\", \"test/fixtures/symlink_parent/symlinked_layout.erb\", \"test/fixtures/test/_counter.html.erb\", \"test/fixtures/test/_customer.erb\", \"test/fixtures/test/_customer_counter.erb\", \"test/fixtures/test/_customer_greeting.erb\", \"test/fixtures/test/_customer_with_var.erb\", \"test/fixtures/test/_form.erb\", \"test/fixtures/test/_from_helper.erb\", \"test/fixtures/test/_hash_greeting.erb\", \"test/fixtures/test/_hash_object.erb\", \"test/fixtures/test/_hello.builder\", \"test/fixtures/test/_labelling_form.erb\", \"test/fixtures/test/_layout_for_block_with_args.html.erb\", \"test/fixtures/test/_layout_for_partial.html.erb\", \"test/fixtures/test/_local_inspector.html.erb\", \"test/fixtures/test/_one.html.erb\", \"test/fixtures/test/_partial.erb\", \"test/fixtures/test/_partial.html.erb\", \"test/fixtures/test/_partial.js.erb\", \"test/fixtures/test/_partial_for_use_in_layout.html.erb\", \"test/fixtures/test/_partial_only.erb\", \"test/fixtures/test/_partial_with_only_html_version.html.erb\", \"test/fixtures/test/_person.erb\", \"test/fixtures/test/_raise.html.erb\", \"test/fixtures/test/_two.html.erb\", \"test/fixtures/test/action_talk_to_layout.erb\", \"test/fixtures/test/calling_partial_with_layout.html.erb\", \"test/fixtures/test/capturing.erb\", \"test/fixtures/test/content_for.erb\", \"test/fixtures/test/content_for_concatenated.erb\", \"test/fixtures/t"..., 4096) = 4096
read(3, "t/dont_pick_me\", \"test/fixtures/test/dot.directory/render_file_with_ivar.erb\", \"test/fixtures/test/enum_rjs_test.rjs\", \"test/fixtures/test/formatted_html_erb.html.erb\", \"test/fixtures/test/formatted_xml_erb.builder\", \"test/fixtures/test/formatted_xml_erb.html.erb\", \"test/fixtures/test/formatted_xml_erb.xml.erb\", \"test/fixtures/test/greeting.erb\", \"test/fixtures/test/greeting.js.rjs\", \"test/fixtures/test/hello.builder\", \"test/fixtures/test/hello_world.da.html.erb\", \"test/fixtures/test/hello_world.erb\", \"test/fixtures/test/hello_world.erb~\", \"test/fixtures/test/hello_world.pt-BR.html.erb\", \"test/fixtures/test/hello_world_container.builder\", \"test/fixtures/test/hello_world_from_rxml.builder\", \"test/fixtures/test/hello_world_with_layout_false.erb\", \"test/fixtures/test/hello_xml_world.builder\", \"test/fixtures/test/hyphen-ated.erb\", \"test/fixtures/test/implicit_content_type.atom.builder\", \"test/fixtures/test/list.erb\", \"test/fixtures/test/malformed/malformed.en.html.erb~\", \"test/fixtures/test/malformed/malformed.erb~\", \"test/fixtures/test/malformed/malformed.html.erb~\", \"test/fixtures/test/nested_layout.erb\", \"test/fixtures/test/non_erb_block_content_for.builder\", \"test/fixtures/test/potential_conflicts.erb\", \"test/fixtures/test/render_explicit_html_template.js.rjs\", \"test/fixtures/test/render_file_from_template.html.erb\", \"test/fixtures/test/render_file_with_ivar.erb\", \"test/fixtures/test/render_file_with_locals.erb\", \"test/fixtures/test/render_implicit_html_template.js.rjs\", \"test/fixtures/test/render_implicit_html_template_from_xhr_request.da.html.erb\", \"test/fixtures/test/render_implicit_html_template_from_xhr_request.html.erb\", \"test/fixtures/test/render_implicit_js_template_without_layout.js.erb\", \"test/fixtures/test/render_to_string_test.erb\", \"test/fixtures/test/sub_template_raise.html.erb\", \"test/fixtures/test/template.erb\", \"test/fixtures/test/update_element_with_capture.erb\", \"test/fixtures/test/using_layout_around_block.html.erb\", \"test/fixtures/test/using_layout_around_block_with_args.html.erb\", \"test/fixtures/test/utf8.html.erb\", \"test/fixtures/topic.rb\", \"test/fixtures/topics/_topic.html.erb\", \"test/fixtures/topics.yml\", \"test/template/active_record_helper_i18n_test.rb\", \"test/template/active_record_helper_test.rb\", \"test/template/asset_tag_helper_test.rb\", \"test/template/atom_feed_helper_test.rb\", \"test/template/benchmark_helper_test.rb\", \"test/template/compiled_templates_test.rb\", \"test/template/date_helper_i18n_test.rb\", \"test/template/date_helper_test.rb\", \"test/template/erb_util_test.rb\", \"test/template/form_helper_test.rb\", \"test/template/form_options_helper_i18n_test.rb\", \"test/template/form_options_helper_test.rb\", \"test/template/form_tag_helper_test.rb\", \"test/template/javascript_helper_test.rb\", \"test/template/number_helper_i18n_test.rb\", \"test/template/number_helper_test.rb\", \"test/template/prototype_helper_test.rb\", \"test/template/raw_output_helper_test.rb\", \"test/template/record_tag_helper_test.rb\", \"test/template/render_test.rb\", \"test/template/sanitize_helper_test.rb\", \"test/template/scriptaculous_helper_test.rb\", \"test/template/tag_helper_test.rb\", \"test/template/template_test.rb\", \"test/template/test_test.rb\", \"test/template/text_helper_test.rb\", \"test/template/translation_helper_test.rb\", \"test/template/url_helper_test.rb\", \"test/testing_sandbox.rb\", \"test/view/safe_buffer_test.rb\", \"test/view/test_case_test.rb\"]\n  s.homepage = %q{http://www.rubyonrails.org}\n  s.require_paths = [\"lib\"]\n  s.requirements = [\"none\"]\n  s.rubyforge_project = %q{actionpack}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Web-flow and rendering framework putting the VC in MVC.}\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 3\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<activesupport>, [\"= 2.3.5\"])\n      s.add_runtime_dependency(%q<rack>, [\"~> 1.0.0\"])"..., 4096) = 4096
read(3, ", [\"~> 1.0.0\"])\n    end\n  else\n    s.add_dependency(%q<activesupport>, [\"= 2.3.5\"])\n    s.add_dependency(%q<rack>, [\"~> 1.0.0\"])\n  end\nend\n", 4096) = 139
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/rubyforge-2.0.3.gemspec", {st_mode=S_IFREG|0644, st_size=1954, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/rubyforge-2.0.3.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=1954, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=1954, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{rubyforge}\n  s.version = \"2.0.3\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Ryan Davis\", \"Eric Hodel\", \"Ara T Howard\", \"Tom Copeland\"]\n  s.date = %q{2009-10-11}\n  s.default_executable = %q{rubyforge}\n  s.description = %q{A script which automates a limited set of rubyforge operations.\n\n* Run 'rubyforge help' for complete usage.\n* Setup: For first time users AND upgrades to 0.4.0:\n  * rubyforge setup (deletes your username and password, so run sparingly!)\n  * edit ~/.rubyforge/user-config.yml\n  * rubyforge config\n* For all rubyforge upgrades, run 'rubyforge config' to ensure you have latest.}\n  s.email = [\"ryand-ruby@zenspider.com\", \"drbrain@segment7.net\", \"ara.t.howard@gmail.com\", \"tom@infoether.com\"]\n  s.executables = [\"rubyforge\"]\n  s.extra_rdoc_files = [\"History.txt\", \"Manifest.txt\", \"README.txt\"]\n  s.files = [\"History.txt\", \"Manifest.txt\", \"README.txt\", \"Rakefile\", \"bin/rubyforge\", \"lib/rubyforge.rb\", \"lib/rubyforge/client.rb\", \"test/test_rubyforge.rb\", \"test/test_rubyforge_client.rb\"]\n  s.homepage = %q{http://codeforpeople.rubyforge.org/rubyforge/}\n  s.rdoc_options = [\"--main\", \"README.txt\"]\n  s.require_paths = [\"lib\"]\n  s.rubyforge_project = %q{codeforpeople}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{A script which automates a limited set of rubyforge operations}\n  s.test_files = [\"test/test_rubyforge.rb\", \"test/test_rubyforge_client.rb\"]\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 3\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<json_pure>, [\">= 1.1.7\"])\n    else\n      s.add_dependency(%q<json_pure>, [\">= 1.1.7\"])\n    end\n  else\n    s.add_dependency(%q<json_pure>, [\">= 1.1.7\"])\n  end\nend\n", 4096) = 1954
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/activerecord-2.3.5.gemspec", {st_mode=S_IFREG|0644, st_size=14070, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/activerecord-2.3.5.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=14070, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=14070, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{activerecord}\n  s.version = \"2.3.5\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"David Heinemeier Hansson\"]\n  s.autorequire = %q{active_record}\n  s.date = %q{2009-11-26}\n  s.description = %q{Implements the ActiveRecord pattern (Fowler, PoEAA) for ORM. It ties database tables and classes together for business objects, like Customer or Subscription, that can find, save, and destroy themselves without resorting to manual SQL.}\n  s.email = %q{david@loudthinking.com}\n  s.extra_rdoc_files = [\"README\"]\n  s.files = [\"Rakefile\", \"install.rb\", \"README\", \"RUNNING_UNIT_TESTS\", \"CHANGELOG\", \"lib/active_record/aggregations.rb\", \"lib/active_record/association_preload.rb\", \"lib/active_record/associations/association_collection.rb\", \"lib/active_record/associations/association_proxy.rb\", \"lib/active_record/associations/belongs_to_association.rb\", \"lib/active_record/associations/belongs_to_polymorphic_association.rb\", \"lib/active_record/associations/has_and_belongs_to_many_association.rb\", \"lib/active_record/associations/has_many_association.rb\", \"lib/active_record/associations/has_many_through_association.rb\", \"lib/active_record/associations/has_one_association.rb\", \"lib/active_record/associations/has_one_through_association.rb\", \"lib/active_record/associations.rb\", \"lib/active_record/attribute_methods.rb\", \"lib/active_record/autosave_association.rb\", \"lib/active_record/base.rb\", \"lib/active_record/batches.rb\", \"lib/active_record/calculations.rb\", \"lib/active_record/callbacks.rb\", \"lib/active_record/connection_adapters/abstract/connection_pool.rb\", \"lib/active_record/connection_adapters/abstract/connection_specification.rb\", \"lib/active_record/connection_adapters/abstract/database_statements.rb\", \"lib/active_record/connection_adapters/abstract/query_cache.rb\", \"lib/active_record/connection_adapters/abstract/quoting.rb\", \"lib/active_record/connection_adapters/abstract/schema_definitions.rb\", \"lib/active_record/connection_adapters/abstract/schema_statements.rb\", \"lib/active_record/connection_adapters/abstract_adapter.rb\", \"lib/active_record/connection_adapters/mysql_adapter.rb\", \"lib/active_record/connection_adapters/postgresql_adapter.rb\", \"lib/active_record/connection_adapters/sqlite3_adapter.rb\", \"lib/active_record/connection_adapters/sqlite_adapter.rb\", \"lib/active_record/dirty.rb\", \"lib/active_record/dynamic_finder_match.rb\", \"lib/active_record/dynamic_scope_match.rb\", \"lib/active_record/fixtures.rb\", \"lib/active_record/i18n_interpolation_deprecation.rb\", \"lib/active_record/locale/en.yml\", \"lib/active_record/locking/optimistic.rb\", \"lib/active_record/locking/pessimistic.rb\", \"lib/active_record/migration.rb\", \"lib/active_record/named_scope.rb\", \"lib/active_record/nested_attributes.rb\", \"lib/active_record/observer.rb\", \"lib/active_record/query_cache.rb\", \"lib/active_record/reflection.rb\", \"lib/active_record/schema.rb\", \"lib/active_record/schema_dumper.rb\", \"lib/active_record/serialization.rb\", \"lib/active_record/serializers/json_serializer.rb\", \"lib/active_record/serializers/xml_serializer.rb\", \"lib/active_record/session_store.rb\", \"lib/active_record/test_case.rb\", \"lib/active_record/timestamp.rb\", \"lib/active_record/transactions.rb\", \"lib/active_record/validations.rb\", \"lib/active_record/version.rb\", \"lib/active_record.rb\", \"lib/activerecord.rb\", \"test/assets/example.log\", \"test/assets/flowers.jpg\", \"test/cases/aaa_create_tables_test.rb\", \"test/cases/active_schema_test_mysql.rb\", \"test/cases/active_schema_test_postgresql.rb\", \"test/cases/adapter_test.rb\", \"test/cases/aggregations_test.rb\", \"test/cases/ar_schema_test.rb\", \"test/cases/associations/belongs_to_associations_test.rb\", \"test/cases/associations/callbacks_test.rb\", \"test/cases/associations/cascaded_eager_loading_test.rb\", \"test/cases/associations/eager_load_includes_full_sti_class_test.rb\", \"test/cases/associations/eager_load_nested_inclu"..., 4096) = 4096
read(3, "ager_test.rb\", \"test/cases/associations/extension_test.rb\", \"test/cases/associations/habtm_join_table_test.rb\", \"test/cases/associations/has_and_belongs_to_many_associations_test.rb\", \"test/cases/associations/has_many_associations_test.rb\", \"test/cases/associations/has_many_through_associations_test.rb\", \"test/cases/associations/has_one_associations_test.rb\", \"test/cases/associations/has_one_through_associations_test.rb\", \"test/cases/associations/inner_join_association_test.rb\", \"test/cases/associations/join_model_test.rb\", \"test/cases/associations_test.rb\", \"test/cases/attribute_methods_test.rb\", \"test/cases/autosave_association_test.rb\", \"test/cases/base_test.rb\", \"test/cases/batches_test.rb\", \"test/cases/binary_test.rb\", \"test/cases/calculations_test.rb\", \"test/cases/callbacks_observers_test.rb\", \"test/cases/callbacks_test.rb\", \"test/cases/class_inheritable_attributes_test.rb\", \"test/cases/column_alias_test.rb\", \"test/cases/column_definition_test.rb\", \"test/cases/connection_pool_test.rb\", \"test/cases/connection_test_firebird.rb\", \"test/cases/connection_test_mysql.rb\", \"test/cases/copy_table_test_sqlite.rb\", \"test/cases/database_statements_test.rb\", \"test/cases/datatype_test_postgresql.rb\", \"test/cases/date_time_test.rb\", \"test/cases/default_test_firebird.rb\", \"test/cases/defaults_test.rb\", \"test/cases/deprecated_finder_test.rb\", \"test/cases/dirty_test.rb\", \"test/cases/finder_respond_to_test.rb\", \"test/cases/finder_test.rb\", \"test/cases/fixtures_test.rb\", \"test/cases/helper.rb\", \"test/cases/i18n_test.rb\", \"test/cases/inheritance_test.rb\", \"test/cases/invalid_date_test.rb\", \"test/cases/json_serialization_test.rb\", \"test/cases/lifecycle_test.rb\", \"test/cases/locking_test.rb\", \"test/cases/method_scoping_test.rb\", \"test/cases/migration_test.rb\", \"test/cases/migration_test_firebird.rb\", \"test/cases/mixin_test.rb\", \"test/cases/modules_test.rb\", \"test/cases/multiple_db_test.rb\", \"test/cases/named_scope_test.rb\", \"test/cases/nested_attributes_test.rb\", \"test/cases/pk_test.rb\", \"test/cases/pooled_connections_test.rb\", \"test/cases/query_cache_test.rb\", \"test/cases/readonly_test.rb\", \"test/cases/reflection_test.rb\", \"test/cases/reload_models_test.rb\", \"test/cases/repair_helper.rb\", \"test/cases/reserved_word_test_mysql.rb\", \"test/cases/sanitize_test.rb\", \"test/cases/schema_authorization_test_postgresql.rb\", \"test/cases/schema_dumper_test.rb\", \"test/cases/schema_test_postgresql.rb\", \"test/cases/serialization_test.rb\", \"test/cases/synonym_test_oracle.rb\", \"test/cases/timestamp_test.rb\", \"test/cases/transactions_test.rb\", \"test/cases/unconnected_test.rb\", \"test/cases/validations_i18n_test.rb\", \"test/cases/validations_test.rb\", \"test/cases/xml_serialization_test.rb\", \"test/config.rb\", \"test/connections/jdbc_jdbcderby/connection.rb\", \"test/connections/jdbc_jdbch2/connection.rb\", \"test/connections/jdbc_jdbchsqldb/connection.rb\", \"test/connections/jdbc_jdbcmysql/connection.rb\", \"test/connections/jdbc_jdbcpostgresql/connection.rb\", \"test/connections/jdbc_jdbcsqlite3/connection.rb\", \"test/connections/native_db2/connection.rb\", \"test/connections/native_firebird/connection.rb\", \"test/connections/native_frontbase/connection.rb\", \"test/connections/native_mysql/connection.rb\", \"test/connections/native_openbase/connection.rb\", \"test/connections/native_oracle/connection.rb\", \"test/connections/native_postgresql/connection.rb\", \"test/connections/native_sqlite/connection.rb\", \"test/connections/native_sqlite3/connection.rb\", \"test/connections/native_sqlite3/in_memory_connection.rb\", \"test/connections/native_sybase/connection.rb\", \"test/fixtures/accounts.yml\", \"test/fixtures/all/developers.yml\", \"test/fixtures/all/people.csv\", \"test/fixtures/all/tasks.yml\", \"test/fixtures/author_addresses.yml\", \"test/fixtures/author_favorites.yml\", \"test/fixtures/authors.yml\", \"test/fixtures/binaries.yml\", \"test/fixtures/books.yml\", \"test/fixtures/categories/special_categories.yml\", \"test/fixtures/categories/subsubdir/arbitrary_filename.yml\", \"test/fixtures/categories.yml\","..., 4096) = 4096
read(3, "tegorizations.yml\", \"test/fixtures/clubs.yml\", \"test/fixtures/comments.yml\", \"test/fixtures/companies.yml\", \"test/fixtures/computers.yml\", \"test/fixtures/courses.yml\", \"test/fixtures/customers.yml\", \"test/fixtures/developers.yml\", \"test/fixtures/developers_projects.yml\", \"test/fixtures/edges.yml\", \"test/fixtures/entrants.yml\", \"test/fixtures/fixture_database.sqlite\", \"test/fixtures/fixture_database.sqlite3\", \"test/fixtures/fixture_database_2.sqlite\", \"test/fixtures/fixture_database_2.sqlite3\", \"test/fixtures/fk_test_has_fk.yml\", \"test/fixtures/fk_test_has_pk.yml\", \"test/fixtures/funny_jokes.yml\", \"test/fixtures/items.yml\", \"test/fixtures/jobs.yml\", \"test/fixtures/legacy_things.yml\", \"test/fixtures/mateys.yml\", \"test/fixtures/member_types.yml\", \"test/fixtures/members.yml\", \"test/fixtures/memberships.yml\", \"test/fixtures/minimalistics.yml\", \"test/fixtures/mixed_case_monkeys.yml\", \"test/fixtures/mixins.yml\", \"test/fixtures/movies.yml\", \"test/fixtures/naked/csv/accounts.csv\", \"test/fixtures/naked/yml/accounts.yml\", \"test/fixtures/naked/yml/companies.yml\", \"test/fixtures/naked/yml/courses.yml\", \"test/fixtures/organizations.yml\", \"test/fixtures/owners.yml\", \"test/fixtures/parrots.yml\", \"test/fixtures/parrots_pirates.yml\", \"test/fixtures/people.yml\", \"test/fixtures/pets.yml\", \"test/fixtures/pirates.yml\", \"test/fixtures/posts.yml\", \"test/fixtures/price_estimates.yml\", \"test/fixtures/projects.yml\", \"test/fixtures/readers.yml\", \"test/fixtures/references.yml\", \"test/fixtures/reserved_words/distinct.yml\", \"test/fixtures/reserved_words/distincts_selects.yml\", \"test/fixtures/reserved_words/group.yml\", \"test/fixtures/reserved_words/select.yml\", \"test/fixtures/reserved_words/values.yml\", \"test/fixtures/ships.yml\", \"test/fixtures/sponsors.yml\", \"test/fixtures/subscribers.yml\", \"test/fixtures/subscriptions.yml\", \"test/fixtures/taggings.yml\", \"test/fixtures/tags.yml\", \"test/fixtures/tasks.yml\", \"test/fixtures/topics.yml\", \"test/fixtures/toys.yml\", \"test/fixtures/treasures.yml\", \"test/fixtures/vertices.yml\", \"test/fixtures/warehouse-things.yml\", \"test/migrations/broken/100_migration_that_raises_exception.rb\", \"test/migrations/decimal/1_give_me_big_numbers.rb\", \"test/migrations/duplicate/1_people_have_last_names.rb\", \"test/migrations/duplicate/2_we_need_reminders.rb\", \"test/migrations/duplicate/3_foo.rb\", \"test/migrations/duplicate/3_innocent_jointable.rb\", \"test/migrations/duplicate_names/20080507052938_chunky.rb\", \"test/migrations/duplicate_names/20080507053028_chunky.rb\", \"test/migrations/interleaved/pass_1/3_innocent_jointable.rb\", \"test/migrations/interleaved/pass_2/1_people_have_last_names.rb\", \"test/migrations/interleaved/pass_2/3_innocent_jointable.rb\", \"test/migrations/interleaved/pass_3/1_people_have_last_names.rb\", \"test/migrations/interleaved/pass_3/2_i_raise_on_down.rb\", \"test/migrations/interleaved/pass_3/3_innocent_jointable.rb\", \"test/migrations/missing/1000_people_have_middle_names.rb\", \"test/migrations/missing/1_people_have_last_names.rb\", \"test/migrations/missing/3_we_need_reminders.rb\", \"test/migrations/missing/4_innocent_jointable.rb\", \"test/migrations/valid/1_people_have_last_names.rb\", \"test/migrations/valid/2_we_need_reminders.rb\", \"test/migrations/valid/3_innocent_jointable.rb\", \"test/models/author.rb\", \"test/models/auto_id.rb\", \"test/models/binary.rb\", \"test/models/bird.rb\", \"test/models/book.rb\", \"test/models/categorization.rb\", \"test/models/category.rb\", \"test/models/citation.rb\", \"test/models/club.rb\", \"test/models/column_name.rb\", \"test/models/comment.rb\", \"test/models/company.rb\", \"test/models/company_in_module.rb\", \"test/models/computer.rb\", \"test/models/contact.rb\", \"test/models/contract.rb\", \"test/models/course.rb\", \"test/models/customer.rb\", \"test/models/default.rb\", \"test/models/developer.rb\", \"test/models/edge.rb\", \"test/models/entrant.rb\", \"test/models/essay.rb\", \"test/models/event.rb\", \"test/models/guid.rb\", \"test/models/item.rb\", \"test/models/job.rb\", \"test/models/joke.rb\", \"test/models/keyboard.rb\", \"test/m"..., 4096) = 4096
read(3, "ail.rb\", \"test/models/member_type.rb\", \"test/models/membership.rb\", \"test/models/minimalistic.rb\", \"test/models/mixed_case_monkey.rb\", \"test/models/movie.rb\", \"test/models/order.rb\", \"test/models/organization.rb\", \"test/models/owner.rb\", \"test/models/parrot.rb\", \"test/models/person.rb\", \"test/models/pet.rb\", \"test/models/pirate.rb\", \"test/models/post.rb\", \"test/models/price_estimate.rb\", \"test/models/project.rb\", \"test/models/reader.rb\", \"test/models/reference.rb\", \"test/models/reply.rb\", \"test/models/ship.rb\", \"test/models/ship_part.rb\", \"test/models/sponsor.rb\", \"test/models/subject.rb\", \"test/models/subscriber.rb\", \"test/models/subscription.rb\", \"test/models/tag.rb\", \"test/models/tagging.rb\", \"test/models/task.rb\", \"test/models/topic.rb\", \"test/models/toy.rb\", \"test/models/treasure.rb\", \"test/models/vertex.rb\", \"test/models/warehouse_thing.rb\", \"test/schema/mysql_specific_schema.rb\", \"test/schema/postgresql_specific_schema.rb\", \"test/schema/schema.rb\", \"test/schema/schema2.rb\", \"test/schema/sqlite_specific_schema.rb\", \"examples/associations.png\", \"examples/performance.rb\"]\n  s.homepage = %q{http://www.rubyonrails.org}\n  s.rdoc_options = [\"--main\", \"README\"]\n  s.require_paths = [\"lib\"]\n  s.rubyforge_project = %q{activerecord}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Implements the ActiveRecord pattern for ORM.}\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 3\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<activesupport>, [\"= 2.3.5\"])\n    else\n      s.add_dependency(%q<activesupport>, [\"= 2.3.5\"])\n    end\n  else\n    s.add_dependency(%q<activesupport>, [\"= 2.3.5\"])\n  end\nend\n", 4096) = 1782
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/fastthread-1.0.7.gemspec", {st_mode=S_IFREG|0644, st_size=1341, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/fastthread-1.0.7.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=1341, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=1341, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{fastthread}\n  s.version = \"1.0.7\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 1.2\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"MenTaLguY <mental@rydia.net>\"]\n  s.date = %q{2009-04-08}\n  s.description = %q{Optimized replacement for thread.rb primitives}\n  s.email = %q{mental@rydia.net}\n  s.extensions = [\"ext/fastthread/extconf.rb\"]\n  s.extra_rdoc_files = [\"ext/fastthread/fastthread.c\", \"ext/fastthread/extconf.rb\", \"CHANGELOG\"]\n  s.files = [\"test/test_queue.rb\", \"test/test_mutex.rb\", \"test/test_condvar.rb\", \"test/test_all.rb\", \"setup.rb\", \"Manifest\", \"ext/fastthread/fastthread.c\", \"ext/fastthread/extconf.rb\", \"CHANGELOG\", \"fastthread.gemspec\", \"Rakefile\"]\n  s.homepage = %q{}\n  s.rdoc_options = [\"--line-numbers\", \"--inline-source\", \"--title\", \"Fastthread\"]\n  s.require_paths = [\"lib\", \"ext\"]\n  s.rubyforge_project = %q{mongrel}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Optimized replacement for thread.rb primitives}\n  s.test_files = [\"test/test_all.rb\"]\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 2\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n    else\n    end\n  else\n  end\nend\n", 4096) = 1341
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/hpricot-0.8.2.gemspec", {st_mode=S_IFREG|0644, st_size=2447, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/hpricot-0.8.2.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=2447, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=2447, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{hpricot}\n  s.version = \"0.8.2\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"why the lucky stiff\"]\n  s.date = %q{2009-11-05}\n  s.description = %q{a swift, liberal HTML parser with a fantastic library}\n  s.email = %q{why@ruby-lang.org}\n  s.extensions = [\"ext/fast_xs/extconf.rb\", \"ext/hpricot_scan/extconf.rb\"]\n  s.extra_rdoc_files = [\"README\", \"CHANGELOG\", \"COPYING\"]\n  s.files = [\"CHANGELOG\", \"COPYING\", \"README\", \"Rakefile\", \"test/files/basic.xhtml\", \"test/files/boingboing.html\", \"test/files/cy0.html\", \"test/files/immob.html\", \"test/files/pace_application.html\", \"test/files/tenderlove.html\", \"test/files/uswebgen.html\", \"test/files/utf8.html\", \"test/files/week9.html\", \"test/files/why.xml\", \"test/load_files.rb\", \"test/nokogiri-bench.rb\", \"test/test_alter.rb\", \"test/test_builder.rb\", \"test/test_parser.rb\", \"test/test_paths.rb\", \"test/test_preserved.rb\", \"test/test_xml.rb\", \"lib/hpricot/blankslate.rb\", \"lib/hpricot/builder.rb\", \"lib/hpricot/elements.rb\", \"lib/hpricot/htmlinfo.rb\", \"lib/hpricot/inspect.rb\", \"lib/hpricot/modules.rb\", \"lib/hpricot/parse.rb\", \"lib/hpricot/tag.rb\", \"lib/hpricot/tags.rb\", \"lib/hpricot/traverse.rb\", \"lib/hpricot/xchar.rb\", \"lib/hpricot.rb\", \"extras/mingw-rbconfig.rb\", \"ext/hpricot_scan/hpricot_scan.h\", \"ext/fast_xs/FastXsService.java\", \"ext/hpricot_scan/HpricotCss.java\", \"ext/hpricot_scan/HpricotScanService.java\", \"ext/fast_xs/fast_xs.c\", \"ext/hpricot_scan/hpricot_css.c\", \"ext/hpricot_scan/hpricot_scan.c\", \"ext/fast_xs/extconf.rb\", \"ext/hpricot_scan/extconf.rb\", \"ext/hpricot_scan/hpricot_common.rl\", \"ext/hpricot_scan/hpricot_css.java.rl\", \"ext/hpricot_scan/hpricot_css.rl\", \"ext/hpricot_scan/hpricot_scan.java.rl\", \"ext/hpricot_scan/hpricot_scan.rl\"]\n  s.homepage = %q{http://code.whytheluckystiff.net/hpricot/}\n  s.rdoc_options = [\"--quiet\", \"--title\", \"The Hpricot Reference\", \"--main\", \"README\", \"--inline-source\"]\n  s.require_paths = [\"lib\"]\n  s.rubyforge_project = %q{hobix}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{a swift, liberal HTML parser with a fantastic library}\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 3\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n    else\n    end\n  else\n  end\nend\n", 4096) = 2447
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/rake-0.8.7.gemspec", {st_mode=S_IFREG|0644, st_size=4934, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/rake-0.8.7.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=4934, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=4934, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{rake}\n  s.version = \"0.8.7\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Jim Weirich\"]\n  s.date = %q{2009-05-15}\n  s.default_executable = %q{rake}\n  s.description = %q{Rake is a Make-like program implemented in Ruby. Tasks and dependencies are specified in standard Ruby syntax.}\n  s.email = %q{jim@weirichhouse.org}\n  s.executables = [\"rake\"]\n  s.extra_rdoc_files = [\"README\", \"MIT-LICENSE\", \"TODO\", \"CHANGES\", \"doc/command_line_usage.rdoc\", \"doc/glossary.rdoc\", \"doc/proto_rake.rdoc\", \"doc/rakefile.rdoc\", \"doc/rational.rdoc\", \"doc/release_notes/rake-0.4.14.rdoc\", \"doc/release_notes/rake-0.4.15.rdoc\", \"doc/release_notes/rake-0.5.0.rdoc\", \"doc/release_notes/rake-0.5.3.rdoc\", \"doc/release_notes/rake-0.5.4.rdoc\", \"doc/release_notes/rake-0.6.0.rdoc\", \"doc/release_notes/rake-0.7.0.rdoc\", \"doc/release_notes/rake-0.7.1.rdoc\", \"doc/release_notes/rake-0.7.2.rdoc\", \"doc/release_notes/rake-0.7.3.rdoc\", \"doc/release_notes/rake-0.8.0.rdoc\", \"doc/release_notes/rake-0.8.2.rdoc\", \"doc/release_notes/rake-0.8.3.rdoc\", \"doc/release_notes/rake-0.8.4.rdoc\", \"doc/release_notes/rake-0.8.5.rdoc\", \"doc/release_notes/rake-0.8.6.rdoc\", \"doc/release_notes/rake-0.8.7.rdoc\"]\n  s.files = [\"install.rb\", \"CHANGES\", \"MIT-LICENSE\", \"Rakefile\", \"README\", \"TODO\", \"bin/rake\", \"lib/rake/alt_system.rb\", \"lib/rake/classic_namespace.rb\", \"lib/rake/clean.rb\", \"lib/rake/contrib/compositepublisher.rb\", \"lib/rake/contrib/ftptools.rb\", \"lib/rake/contrib/publisher.rb\", \"lib/rake/contrib/rubyforgepublisher.rb\", \"lib/rake/contrib/sshpublisher.rb\", \"lib/rake/contrib/sys.rb\", \"lib/rake/gempackagetask.rb\", \"lib/rake/loaders/makefile.rb\", \"lib/rake/packagetask.rb\", \"lib/rake/rake_test_loader.rb\", \"lib/rake/rdoctask.rb\", \"lib/rake/ruby182_test_unit_fix.rb\", \"lib/rake/runtest.rb\", \"lib/rake/tasklib.rb\", \"lib/rake/testtask.rb\", \"lib/rake/win32.rb\", \"lib/rake.rb\", \"test/capture_stdout.rb\", \"test/check_expansion.rb\", \"test/check_no_expansion.rb\", \"test/contrib/test_sys.rb\", \"test/data/rakelib/test1.rb\", \"test/data/rbext/rakefile.rb\", \"test/filecreation.rb\", \"test/functional.rb\", \"test/in_environment.rb\", \"test/rake_test_setup.rb\", \"test/reqfile.rb\", \"test/reqfile2.rb\", \"test/session_functional.rb\", \"test/shellcommand.rb\", \"test/test_application.rb\", \"test/test_clean.rb\", \"test/test_definitions.rb\", \"test/test_earlytime.rb\", \"test/test_extension.rb\", \"test/test_file_creation_task.rb\", \"test/test_file_task.rb\", \"test/test_filelist.rb\", \"test/test_fileutils.rb\", \"test/test_ftp.rb\", \"test/test_invocation_chain.rb\", \"test/test_makefile_loader.rb\", \"test/test_multitask.rb\", \"test/test_namespace.rb\", \"test/test_package_task.rb\", \"test/test_pathmap.rb\", \"test/test_pseudo_status.rb\", \"test/test_rake.rb\", \"test/test_rdoc_task.rb\", \"test/test_require.rb\", \"test/test_rules.rb\", \"test/test_task_arguments.rb\", \"test/test_task_manager.rb\", \"test/test_tasklib.rb\", \"test/test_tasks.rb\", \"test/test_test_task.rb\", \"test/test_top_level_functions.rb\", \"test/test_win32.rb\", \"test/data/imports/deps.mf\", \"test/data/sample.mf\", \"test/data/chains/Rakefile\", \"test/data/default/Rakefile\", \"test/data/dryrun/Rakefile\", \"test/data/file_creation_task/Rakefile\", \"test/data/imports/Rakefile\", \"test/data/multidesc/Rakefile\", \"test/data/namespace/Rakefile\", \"test/data/statusreturn/Rakefile\", \"test/data/unittest/Rakefile\", \"test/data/unittest/subdir\", \"doc/command_line_usage.rdoc\", \"doc/example\", \"doc/example/a.c\", \"doc/example/b.c\", \"doc/example/main.c\", \"doc/example/Rakefile1\", \"doc/example/Rakefile2\", \"doc/glossary.rdoc\", \"doc/jamis.rb\", \"doc/proto_rake.rdoc\", \"doc/rake.1.gz\", \"doc/rakefile.rdoc\", \"doc/rational.rdoc\", \"doc/release_notes\", \"doc/release_notes/rake-0.4.14.rdoc\", \"doc/release_notes/rake-0.4.15.rdoc\", \"doc/release_notes/rake-0.5.0.rdoc\", \"doc/release_notes/rake-0.5.3.rdoc\", \"doc/release_notes/rake-0.5.4.rdoc\", \"doc/release_notes/rake-0.6.0.rdoc\", \"doc/release_note"..., 4096) = 4096
read(3, "oc/release_notes/rake-0.7.3.rdoc\", \"doc/release_notes/rake-0.8.0.rdoc\", \"doc/release_notes/rake-0.8.2.rdoc\", \"doc/release_notes/rake-0.8.3.rdoc\", \"doc/release_notes/rake-0.8.4.rdoc\", \"doc/release_notes/rake-0.8.5.rdoc\", \"doc/release_notes/rake-0.8.6.rdoc\", \"doc/release_notes/rake-0.8.7.rdoc\"]\n  s.homepage = %q{http://rake.rubyforge.org}\n  s.rdoc_options = [\"--line-numbers\", \"--main\", \"README\", \"--title\", \"Rake -- Ruby Make\"]\n  s.require_paths = [\"lib\"]\n  s.rubyforge_project = %q{rake}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Ruby based make-like utility.}\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 2\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n    else\n    end\n  else\n  end\nend\n", 4096) = 838
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/minitest-1.5.0.gemspec", {st_mode=S_IFREG|0644, st_size=3640, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/minitest-1.5.0.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=3640, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=3640, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{minitest}\n  s.version = \"1.5.0\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Ryan Davis\"]\n  s.cert_chain = [\"-----BEGIN CERTIFICATE-----\\nMIIDPjCCAiagAwIBAgIBADANBgkqhkiG9w0BAQUFADBFMRMwEQYDVQQDDApyeWFu\\nZC1ydWJ5MRkwFwYKCZImiZPyLGQBGRYJemVuc3BpZGVyMRMwEQYKCZImiZPyLGQB\\nGRYDY29tMB4XDTA5MDMwNjE4NTMxNVoXDTEwMDMwNjE4NTMxNVowRTETMBEGA1UE\\nAwwKcnlhbmQtcnVieTEZMBcGCgmSJomT8ixkARkWCXplbnNwaWRlcjETMBEGCgmS\\nJomT8ixkARkWA2NvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALda\\nb9DCgK+627gPJkB6XfjZ1itoOQvpqH1EXScSaba9/S2VF22VYQbXU1xQXL/WzCkx\\ntaCPaLmfYIaFcHHCSY4hYDJijRQkLxPeB3xbOfzfLoBDbjvx5JxgJxUjmGa7xhcT\\noOvjtt5P8+GSK9zLzxQP0gVLS/D0FmoE44XuDr3iQkVS2ujU5zZL84mMNqNB1znh\\nGiadM9GHRaDiaxuX0cIUBj19T01mVE2iymf9I6bEsiayK/n6QujtyCbTWsAS9Rqt\\nqhtV7HJxNKuPj/JFH0D2cswvzznE/a5FOYO68g+YCuFi5L8wZuuM8zzdwjrWHqSV\\ngBEfoTEGr7Zii72cx+sCAwEAAaM5MDcwCQYDVR0TBAIwADALBgNVHQ8EBAMCBLAw\\nHQYDVR0OBBYEFEfFe9md/r/tj/Wmwpy+MI8d9k/hMA0GCSqGSIb3DQEBBQUAA4IB\\nAQAY59gYvDxqSqgC92nAP9P8dnGgfZgLxP237xS6XxFGJSghdz/nI6pusfCWKM8m\\nvzjjH2wUMSSf3tNudQ3rCGLf2epkcU13/rguI88wO6MrE0wi4ZqLQX+eZQFskJb/\\nw6x9W1ur8eR01s397LSMexySDBrJOh34cm2AlfKr/jokKCTwcM0OvVZnAutaovC0\\nl1SVZ0ecg88bsWHA0Yhh7NFxK1utWoIhtB6AFC/+trM0FQEB/jZkIS8SaNzn96Rl\\nn0sZEf77FLf5peR8TP/PtmIg7Cyqz23sLM4mCOoTGIy5OcZ8TdyiyINUHtb5ej/T\\nFBHgymkyj/AOSqKRIpXPhjC6\\n-----END CERTIFICATE-----\\n\"]\n  s.date = %q{2010-01-06}\n  s.description = %q{minitest/unit is a small and fast replacement for ruby's huge and slow\ntest/unit. This is meant to be clean and easy to use both as a regular\ntest writer and for language implementors that need a minimal set of\nmethods to bootstrap a working unit test suite.\n\nmini/spec is a functionally complete spec engine.\n\nmini/mock, by Steven Baker, is a beautifully tiny mock object framework.\n\n(This package was called miniunit once upon a time)}\n  s.email = [\"ryand-ruby@zenspider.com\"]\n  s.extra_rdoc_files = [\"History.txt\", \"Manifest.txt\", \"README.txt\"]\n  s.files = [\".autotest\", \"History.txt\", \"Manifest.txt\", \"README.txt\", \"Rakefile\", \"design_rationale.rb\", \"lib/minitest/autorun.rb\", \"lib/minitest/mock.rb\", \"lib/minitest/spec.rb\", \"lib/minitest/unit.rb\", \"test/test_mini_mock.rb\", \"test/test_mini_spec.rb\", \"test/test_mini_test.rb\"]\n  s.homepage = %q{http://rubyforge.org/projects/bfts}\n  s.rdoc_options = [\"--main\", \"README.txt\"]\n  s.require_paths = [\"lib\"]\n  s.rubyforge_project = %q{bfts}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{minitest/unit is a small and fast replacement for ruby's huge and slow test/unit}\n  s.test_files = [\"test/test_mini_mock.rb\", \"test/test_mini_spec.rb\", \"test/test_mini_test.rb\"]\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 3\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n      s.add_development_dependency(%q<rubyforge>, [\">= 2.0.3\"])\n      s.add_development_dependency(%q<gemcutter>, [\">= 0.2.1\"])\n      s.add_development_dependency(%q<minitest>, [\">= 1.4.2\"])\n      s.add_development_dependency(%q<hoe>, [\">= 2.5.0\"])\n    else\n      s.add_dependency(%q<rubyforge>, [\">= 2.0.3\"])\n      s.add_dependency(%q<gemcutter>, [\">= 0.2.1\"])\n      s.add_dependency(%q<minitest>, [\">= 1.4.2\"])\n      s.add_dependency(%q<hoe>, [\">= 2.5.0\"])\n    end\n  else\n    s.add_dependency(%q<rubyforge>, [\">= 2.0.3\"])\n    s.add_dependency(%q<gemcutter>, [\">= 0.2.1\"])\n    s.add_dependency(%q<minitest>, [\">= 1.4.2\"])\n    s.add_dependency(%q<hoe>, [\">= 2.5.0\"])\n  end\nend\n", 4096) = 3640
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/json_pure-1.2.0.gemspec", {st_mode=S_IFREG|0644, st_size=5733, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/json_pure-1.2.0.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=5733, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=5733, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{json_pure}\n  s.version = \"1.2.0\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Florian Frank\"]\n  s.date = %q{2009-11-08}\n  s.default_executable = %q{edit_json.rb}\n  s.description = %q{This is a JSON implementation in pure Ruby.}\n  s.email = %q{flori@ping.de}\n  s.executables = [\"edit_json.rb\", \"prettify_json.rb\"]\n  s.extra_rdoc_files = [\"README\"]\n  s.files = [\"CHANGES\", \"bin/edit_json.rb\", \"bin/prettify_json.rb\", \"VERSION\", \"GPL\", \"TODO\", \"README\", \"benchmarks/parser_benchmark.rb\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkPure.log\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkComparison.log\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkYAML#parser.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkExt#generator_safe.dat\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkExt#parser.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkExt#generator_fast.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkExt#generator_fast-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkPure.log\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkExt#parser-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkRails#generator-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkExt.log\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkPure#generator_fast-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkPure#generator_fast.dat\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkRails#parser.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkPure#generator_pretty-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkPure#parser-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkExt#generator_pretty.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkRails.log\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkExt.log\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkRails.log\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkComparison.log\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkPure#generator_safe.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkRails#generator.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkExt#generator_safe-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkPure#generator_pretty.dat\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkYAML.log\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkYAML#parser-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkExt#generator_pretty-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkRails#parser-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkPure#parser.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkPure#generator_safe-autocorrelation.dat\", \"benchmarks/generator_benchmark.rb\", \"ext/json/ext/generator/extconf.rb\", \"ext/json/ext/generator/unicode.c\", \"ext/json/ext/generator/generator.c\", \"ext/json/ext/generator/unicode.h\", \"ext/json/ext/parser/extconf.rb\", \"ext/json/ext/parser/parser.rl\", \"ext/json/ext/parser/unicode.c\", \"ext/json/ext/parser/parser.c\", \"ext/json/ext/parser/unicode.h\", \"Rakefile\", \"tools/fuzz.rb\", \"tools/server.rb\", \"lib/json.rb\", \"lib/json/json.xpm\", \"lib/json/Key.xpm\", \"lib/json/String.xpm\", \"lib/json/Numeric.xpm\", \"lib/json/Hash.xpm\", \"lib/json/add/rails.rb\", \"lib/json/add/core.rb\", \"lib/json/common.rb\", \"lib/json/Array.xpm\", \"lib/json/FalseClass.xpm\", \"lib/json/pure/generator.rb\", \"lib/json/pure/parser.rb\", \"lib/json/TrueClass.xpm\", \"lib/json/pure.rb\", \"lib/json/version.rb\", \"lib/json/ext.rb\", \"lib/json/editor.rb\", \"lib/json/NilClass.xpm\", \"data/example.json\", \"data/index.html\", \"data/prototype.js\", \"tests/test_json_encoding.rb\", \"tests/test_json_addition.rb\", \"tests/fixtures/pass16.json\", \"tests/fixtures/fail4.json\", \"tests/fixtures/fail1.json\", \"tests/fixtures/fail28"..., 4096) = 4096
read(3, "\"tests/fixtures/pass26.json\", \"tests/fixtures/pass1.json\", \"tests/fixtures/fail3.json\", \"tests/fixtures/fail20.json\", \"tests/fixtures/pass3.json\", \"tests/fixtures/pass15.json\", \"tests/fixtures/fail12.json\", \"tests/fixtures/fail13.json\", \"tests/fixtures/fail22.json\", \"tests/fixtures/fail24.json\", \"tests/fixtures/fail9.json\", \"tests/fixtures/fail2.json\", \"tests/fixtures/fail14.json\", \"tests/fixtures/fail6.json\", \"tests/fixtures/fail21.json\", \"tests/fixtures/fail7.json\", \"tests/fixtures/pass17.json\", \"tests/fixtures/fail11.json\", \"tests/fixtures/fail25.json\", \"tests/fixtures/fail5.json\", \"tests/fixtures/fail18.json\", \"tests/fixtures/fail27.json\", \"tests/fixtures/fail10.json\", \"tests/fixtures/fail23.json\", \"tests/test_json_rails.rb\", \"tests/test_json.rb\", \"tests/test_json_generate.rb\", \"tests/test_json_unicode.rb\", \"tests/test_json_fixtures.rb\", \"COPYING\", \"install.rb\"]\n  s.homepage = %q{http://json.rubyforge.org}\n  s.rdoc_options = [\"--title\", \"JSON -- A JSON implemention\", \"--main\", \"README\"]\n  s.require_paths = [\"lib\"]\n  s.rubyforge_project = %q{json}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{A JSON implementation in Ruby}\n  s.test_files = [\"tests/test_json_encoding.rb\", \"tests/test_json_addition.rb\", \"tests/test_json_rails.rb\", \"tests/test_json.rb\", \"tests/test_json_generate.rb\", \"tests/test_json_unicode.rb\", \"tests/test_json_fixtures.rb\"]\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 3\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n    else\n    end\n  else\n  end\nend\n", 4096) = 1637
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/yahoo-1.1.1.gemspec", {st_mode=S_IFREG|0644, st_size=1377, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/yahoo-1.1.1.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=1377, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=1377, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{yahoo}\n  s.version = \"1.1.1\"\n\n  s.required_rubygems_version = nil if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Eric Hodel\"]\n  s.cert_chain = nil\n  s.date = %q{2006-11-27}\n  s.description = %q{This library makes it easy to implement Yahoo's web services APIs.}\n  s.email = %q{drbrain@segment7.net}\n  s.files = [\"History.txt\", \"LICENSE.txt\", \"Manifest.txt\", \"README.txt\", \"Rakefile\", \"lib/yahoo.rb\", \"test/test_yahoo.rb\"]\n  s.homepage = %q{http://dev.robotcoop.com/Libraries/yahoo}\n  s.require_paths = [\"lib\"]\n  s.required_ruby_version = Gem::Requirement.new(\"> 0.0.0\")\n  s.rubyforge_project = %q{rctools}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Base for Yahoo web services}\n  s.test_files = [\"test/test_yahoo.rb\"]\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 1\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<hoe>, [\">= 1.1.4\"])\n      s.add_runtime_dependency(%q<rc-rest>, [\">= 2.0.0\"])\n    else\n      s.add_dependency(%q<hoe>, [\">= 1.1.4\"])\n      s.add_dependency(%q<rc-rest>, [\">= 2.0.0\"])\n    end\n  else\n    s.add_dependency(%q<hoe>, [\">= 1.1.4\"])\n    s.add_dependency(%q<rc-rest>, [\">= 2.0.0\"])\n  end\nend\n", 4096) = 1377
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/activesupport-2.3.5.gemspec", {st_mode=S_IFREG|0644, st_size=21629, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/activesupport-2.3.5.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=21629, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=21629, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{activesupport}\n  s.version = \"2.3.5\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"David Heinemeier Hansson\"]\n  s.date = %q{2009-11-26}\n  s.description = %q{Utility library which carries commonly used classes and goodies from the Rails framework}\n  s.email = %q{david@loudthinking.com}\n  s.files = [\"CHANGELOG\", \"README\", \"lib/active_support/all.rb\", \"lib/active_support/backtrace_cleaner.rb\", \"lib/active_support/base64.rb\", \"lib/active_support/basic_object.rb\", \"lib/active_support/buffered_logger.rb\", \"lib/active_support/cache/compressed_mem_cache_store.rb\", \"lib/active_support/cache/drb_store.rb\", \"lib/active_support/cache/file_store.rb\", \"lib/active_support/cache/mem_cache_store.rb\", \"lib/active_support/cache/memory_store.rb\", \"lib/active_support/cache/strategy/local_cache.rb\", \"lib/active_support/cache/synchronized_memory_store.rb\", \"lib/active_support/cache.rb\", \"lib/active_support/callbacks.rb\", \"lib/active_support/core_ext/array/access.rb\", \"lib/active_support/core_ext/array/conversions.rb\", \"lib/active_support/core_ext/array/extract_options.rb\", \"lib/active_support/core_ext/array/grouping.rb\", \"lib/active_support/core_ext/array/random_access.rb\", \"lib/active_support/core_ext/array/wrapper.rb\", \"lib/active_support/core_ext/array.rb\", \"lib/active_support/core_ext/base64/encoding.rb\", \"lib/active_support/core_ext/base64.rb\", \"lib/active_support/core_ext/benchmark.rb\", \"lib/active_support/core_ext/bigdecimal/conversions.rb\", \"lib/active_support/core_ext/bigdecimal.rb\", \"lib/active_support/core_ext/blank.rb\", \"lib/active_support/core_ext/cgi/escape_skipping_slashes.rb\", \"lib/active_support/core_ext/cgi.rb\", \"lib/active_support/core_ext/class/attribute_accessors.rb\", \"lib/active_support/core_ext/class/delegating_attributes.rb\", \"lib/active_support/core_ext/class/inheritable_attributes.rb\", \"lib/active_support/core_ext/class/removal.rb\", \"lib/active_support/core_ext/class.rb\", \"lib/active_support/core_ext/date/behavior.rb\", \"lib/active_support/core_ext/date/calculations.rb\", \"lib/active_support/core_ext/date/conversions.rb\", \"lib/active_support/core_ext/date.rb\", \"lib/active_support/core_ext/date_time/calculations.rb\", \"lib/active_support/core_ext/date_time/conversions.rb\", \"lib/active_support/core_ext/date_time.rb\", \"lib/active_support/core_ext/duplicable.rb\", \"lib/active_support/core_ext/enumerable.rb\", \"lib/active_support/core_ext/exception.rb\", \"lib/active_support/core_ext/file/atomic.rb\", \"lib/active_support/core_ext/file.rb\", \"lib/active_support/core_ext/float/rounding.rb\", \"lib/active_support/core_ext/float/time.rb\", \"lib/active_support/core_ext/float.rb\", \"lib/active_support/core_ext/hash/conversions.rb\", \"lib/active_support/core_ext/hash/deep_merge.rb\", \"lib/active_support/core_ext/hash/diff.rb\", \"lib/active_support/core_ext/hash/except.rb\", \"lib/active_support/core_ext/hash/indifferent_access.rb\", \"lib/active_support/core_ext/hash/keys.rb\", \"lib/active_support/core_ext/hash/reverse_merge.rb\", \"lib/active_support/core_ext/hash/slice.rb\", \"lib/active_support/core_ext/hash.rb\", \"lib/active_support/core_ext/integer/even_odd.rb\", \"lib/active_support/core_ext/integer/inflections.rb\", \"lib/active_support/core_ext/integer/time.rb\", \"lib/active_support/core_ext/integer.rb\", \"lib/active_support/core_ext/kernel/agnostics.rb\", \"lib/active_support/core_ext/kernel/daemonizing.rb\", \"lib/active_support/core_ext/kernel/debugger.rb\", \"lib/active_support/core_ext/kernel/reporting.rb\", \"lib/active_support/core_ext/kernel/requires.rb\", \"lib/active_support/core_ext/kernel.rb\", \"lib/active_support/core_ext/load_error.rb\", \"lib/active_support/core_ext/logger.rb\", \"lib/active_support/core_ext/module/aliasing.rb\", \"lib/active_support/core_ext/module/attr_accessor_with_default.rb\", \"lib/active_support/core_ext/module/attr_internal.rb\", \"lib/active_support/core_ext/module/attribute_accessors.rb\", \"lib"..., 4096) = 4096
read(3, "\", \"lib/active_support/core_ext/module/introspection.rb\", \"lib/active_support/core_ext/module/loading.rb\", \"lib/active_support/core_ext/module/model_naming.rb\", \"lib/active_support/core_ext/module/synchronization.rb\", \"lib/active_support/core_ext/module.rb\", \"lib/active_support/core_ext/name_error.rb\", \"lib/active_support/core_ext/numeric/bytes.rb\", \"lib/active_support/core_ext/numeric/conversions.rb\", \"lib/active_support/core_ext/numeric/time.rb\", \"lib/active_support/core_ext/numeric.rb\", \"lib/active_support/core_ext/object/blank.rb\", \"lib/active_support/core_ext/object/conversions.rb\", \"lib/active_support/core_ext/object/extending.rb\", \"lib/active_support/core_ext/object/instance_variables.rb\", \"lib/active_support/core_ext/object/metaclass.rb\", \"lib/active_support/core_ext/object/misc.rb\", \"lib/active_support/core_ext/object.rb\", \"lib/active_support/core_ext/pathname/clean_within.rb\", \"lib/active_support/core_ext/pathname.rb\", \"lib/active_support/core_ext/proc.rb\", \"lib/active_support/core_ext/process/daemon.rb\", \"lib/active_support/core_ext/process.rb\", \"lib/active_support/core_ext/range/blockless_step.rb\", \"lib/active_support/core_ext/range/conversions.rb\", \"lib/active_support/core_ext/range/include_range.rb\", \"lib/active_support/core_ext/range/overlaps.rb\", \"lib/active_support/core_ext/range.rb\", \"lib/active_support/core_ext/rexml.rb\", \"lib/active_support/core_ext/string/access.rb\", \"lib/active_support/core_ext/string/behavior.rb\", \"lib/active_support/core_ext/string/bytesize.rb\", \"lib/active_support/core_ext/string/conversions.rb\", \"lib/active_support/core_ext/string/filters.rb\", \"lib/active_support/core_ext/string/inflections.rb\", \"lib/active_support/core_ext/string/iterators.rb\", \"lib/active_support/core_ext/string/multibyte.rb\", \"lib/active_support/core_ext/string/output_safety.rb\", \"lib/active_support/core_ext/string/starts_ends_with.rb\", \"lib/active_support/core_ext/string/xchar.rb\", \"lib/active_support/core_ext/string.rb\", \"lib/active_support/core_ext/symbol.rb\", \"lib/active_support/core_ext/time/behavior.rb\", \"lib/active_support/core_ext/time/calculations.rb\", \"lib/active_support/core_ext/time/conversions.rb\", \"lib/active_support/core_ext/time/zones.rb\", \"lib/active_support/core_ext/time.rb\", \"lib/active_support/core_ext/try.rb\", \"lib/active_support/core_ext/uri.rb\", \"lib/active_support/core_ext.rb\", \"lib/active_support/dependencies.rb\", \"lib/active_support/deprecation.rb\", \"lib/active_support/duration.rb\", \"lib/active_support/gzip.rb\", \"lib/active_support/inflections.rb\", \"lib/active_support/inflector.rb\", \"lib/active_support/json/backends/jsongem.rb\", \"lib/active_support/json/backends/yaml.rb\", \"lib/active_support/json/decoding.rb\", \"lib/active_support/json/encoders/date.rb\", \"lib/active_support/json/encoders/date_time.rb\", \"lib/active_support/json/encoders/enumerable.rb\", \"lib/active_support/json/encoders/false_class.rb\", \"lib/active_support/json/encoders/hash.rb\", \"lib/active_support/json/encoders/nil_class.rb\", \"lib/active_support/json/encoders/numeric.rb\", \"lib/active_support/json/encoders/object.rb\", \"lib/active_support/json/encoders/regexp.rb\", \"lib/active_support/json/encoders/string.rb\", \"lib/active_support/json/encoders/symbol.rb\", \"lib/active_support/json/encoders/time.rb\", \"lib/active_support/json/encoders/true_class.rb\", \"lib/active_support/json/encoding.rb\", \"lib/active_support/json/variable.rb\", \"lib/active_support/json.rb\", \"lib/active_support/locale/en.yml\", \"lib/active_support/memoizable.rb\", \"lib/active_support/message_encryptor.rb\", \"lib/active_support/message_verifier.rb\", \"lib/active_support/multibyte/chars.rb\", \"lib/active_support/multibyte/exceptions.rb\", \"lib/active_support/multibyte/unicode_database.rb\", \"lib/active_support/multibyte/utils.rb\", \"lib/active_support/multibyte.rb\", \"lib/active_support/option_merger.rb\", \"lib/active_support/ordered_hash.rb\", \"lib/active_support/ordered_options.rb\", \"lib/active_support/rescuable.rb\", \"lib/active_support/secure_random.rb\", \"lib/active_support/"..., 4096) = 4096
read(3, "b\", \"lib/active_support/testing/declarative.rb\", \"lib/active_support/testing/default.rb\", \"lib/active_support/testing/deprecation.rb\", \"lib/active_support/testing/performance.rb\", \"lib/active_support/testing/setup_and_teardown.rb\", \"lib/active_support/time_with_zone.rb\", \"lib/active_support/values/time_zone.rb\", \"lib/active_support/values/unicode_tables.dat\", \"lib/active_support/vendor/builder-2.1.2/blankslate.rb\", \"lib/active_support/vendor/builder-2.1.2/builder/blankslate.rb\", \"lib/active_support/vendor/builder-2.1.2/builder/css.rb\", \"lib/active_support/vendor/builder-2.1.2/builder/xchar.rb\", \"lib/active_support/vendor/builder-2.1.2/builder/xmlbase.rb\", \"lib/active_support/vendor/builder-2.1.2/builder/xmlevents.rb\", \"lib/active_support/vendor/builder-2.1.2/builder/xmlmarkup.rb\", \"lib/active_support/vendor/builder-2.1.2/builder.rb\", \"lib/active_support/vendor/i18n-0.1.3/i18n.gemspec\", \"lib/active_support/vendor/i18n-0.1.3/lib/i18n/backend/simple.rb\", \"lib/active_support/vendor/i18n-0.1.3/lib/i18n/exceptions.rb\", \"lib/active_support/vendor/i18n-0.1.3/lib/i18n.rb\", \"lib/active_support/vendor/i18n-0.1.3/MIT-LICENSE\", \"lib/active_support/vendor/i18n-0.1.3/Rakefile\", \"lib/active_support/vendor/i18n-0.1.3/README.textile\", \"lib/active_support/vendor/i18n-0.1.3/test/all.rb\", \"lib/active_support/vendor/i18n-0.1.3/test/i18n_exceptions_test.rb\", \"lib/active_support/vendor/i18n-0.1.3/test/i18n_test.rb\", \"lib/active_support/vendor/i18n-0.1.3/test/locale/en.rb\", \"lib/active_support/vendor/i18n-0.1.3/test/locale/en.yml\", \"lib/active_support/vendor/i18n-0.1.3/test/simple_backend_test.rb\", \"lib/active_support/vendor/memcache-client-1.7.4/memcache.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/data_timezone.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/data_timezone_info.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Africa/Algiers.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Africa/Cairo.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Africa/Casablanca.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Africa/Harare.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Africa/Johannesburg.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Africa/Monrovia.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Africa/Nairobi.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Argentina/Buenos_Aires.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Argentina/San_Juan.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Bogota.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Caracas.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Chicago.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Chihuahua.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Denver.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Godthab.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Guatemala.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Halifax.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Indiana/Indianapolis.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Juneau.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/La_Paz.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Lima.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Los_Angeles.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Mazatlan.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Mexico_City.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Monterrey.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/New_York.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzi"..., 4096) = 4096
read(3, "/America/Regina.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Santiago.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Sao_Paulo.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/St_Johns.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/America/Tijuana.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Almaty.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Baghdad.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Baku.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Bangkok.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Chongqing.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Colombo.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Dhaka.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Hong_Kong.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Irkutsk.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Jakarta.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Jerusalem.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Kabul.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Kamchatka.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Karachi.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Katmandu.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Kolkata.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Krasnoyarsk.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Kuala_Lumpur.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Kuwait.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Magadan.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Muscat.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Novosibirsk.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Rangoon.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Riyadh.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Seoul.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Shanghai.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Singapore.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Taipei.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Tashkent.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Tbilisi.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Tehran.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Tokyo.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Ulaanbaatar.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Urumqi.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Vladivostok.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Yakutsk.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Yekaterinburg.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Asia/Yerevan.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Atlantic/Azores.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Atlantic/Cape_Verde.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Atlantic/South_Georgia.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Australia/Adelaide.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Australia/Brisbane.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Australia/Darwin.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Australia/Hobart.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Australia/Melbourne"..., 4096) = 4096
read(3, "ve_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Australia/Sydney.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Etc/UTC.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Amsterdam.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Athens.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Belgrade.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Berlin.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Bratislava.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Brussels.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Bucharest.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Budapest.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Copenhagen.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Dublin.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Helsinki.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Istanbul.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Kiev.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Lisbon.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Ljubljana.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/London.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Madrid.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Minsk.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Moscow.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Paris.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Prague.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Riga.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Rome.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Sarajevo.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Skopje.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Sofia.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Stockholm.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Tallinn.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Vienna.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Vilnius.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Warsaw.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Europe/Zagreb.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Pacific/Auckland.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Pacific/Fiji.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Pacific/Guam.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Pacific/Honolulu.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Pacific/Majuro.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Pacific/Midway.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Pacific/Noumea.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Pacific/Pago_Pago.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Pacific/Port_Moresby.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/definitions/Pacific/Tongatapu.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/info_timezone.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/linked_timezone.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/linked_timezone_info.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/offset_rationals.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/ruby_core_support.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/time_or_datetime.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/timezone.rb\", \"lib/a"..., 4096) = 4096
read(3, "info-0.3.12/tzinfo/timezone_info.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/timezone_offset_info.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/timezone_period.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo/timezone_transition_info.rb\", \"lib/active_support/vendor/tzinfo-0.3.12/tzinfo.rb\", \"lib/active_support/vendor.rb\", \"lib/active_support/version.rb\", \"lib/active_support/whiny_nil.rb\", \"lib/active_support/xml_mini/jdom.rb\", \"lib/active_support/xml_mini/libxml.rb\", \"lib/active_support/xml_mini/nokogiri.rb\", \"lib/active_support/xml_mini/rexml.rb\", \"lib/active_support/xml_mini.rb\", \"lib/active_support.rb\", \"lib/activesupport.rb\"]\n  s.homepage = %q{http://www.rubyonrails.org}\n  s.require_paths = [\"lib\"]\n  s.rubyforge_project = %q{activesupport}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Support and utility classes used by the Rails framework.}\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 3\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n    else\n    end\n  else\n  end\nend\n", 4096) = 1149
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/cgi_multipart_eof_fix-2.5.0.gemspec", {st_mode=S_IFREG|0644, st_size=3557, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/cgi_multipart_eof_fix-2.5.0.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=3557, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=3557, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{cgi_multipart_eof_fix}\n  s.version = \"2.5.0\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Evan Weaver\"]\n  s.cert_chain = [\"-----BEGIN CERTIFICATE-----\\nMIIDUDCCAjigAwIBAgIBADANBgkqhkiG9w0BAQUFADBOMRwwGgYDVQQDDBNtb25n\\ncmVsLWRldmVsb3BtZW50MRkwFwYKCZImiZPyLGQBGRYJcnVieWZvcmdlMRMwEQYK\\nCZImiZPyLGQBGRYDb3JnMB4XDTA3MDkxNjEwMzI0OVoXDTA4MDkxNTEwMzI0OVow\\nTjEcMBoGA1UEAwwTbW9uZ3JlbC1kZXZlbG9wbWVudDEZMBcGCgmSJomT8ixkARkW\\nCXJ1Ynlmb3JnZTETMBEGCgmSJomT8ixkARkWA29yZzCCASIwDQYJKoZIhvcNAQEB\\nBQADggEPADCCAQoCggEBAMb9v3B01eOHk3FyypbQgKXzJplUE5P6dXoG+xpPm0Lv\\nP7BQmeMncOwqQ7zXpVQU+lTpXtQFTsOE3vL7KnhQFJKGvUAkbh24VFyopu1I0yqF\\nmGu4nRqNXGXVj8TvLSj4S1WpSRLAa0acLPNyKhGmoV9+crqQypSjM6XKjBeppifo\\n4eBmWGjiJEYMIJBvJZPJ4rAVDDA8C6CM1m3gMBGNh8ELDhU8HI9AP3dMIkTI2Wx9\\n9xkJwHdroAaS0IFFtYChrwee4FbCF1FHDgoTosMwa47DrLHg4hZ6ojaKwK5QVWEV\\nXGb6ju5UqpktnSWF2W+Lvl/K0tI42OH2CAhebT1gEVUCAwEAAaM5MDcwCQYDVR0T\\nBAIwADALBgNVHQ8EBAMCBLAwHQYDVR0OBBYEFGHChyMSZ16u9WOzKhgJSQ9lqDc5\\nMA0GCSqGSIb3DQEBBQUAA4IBAQA/lfeN2WdB1xN+82tT7vNS4HOjRQw6MUh5yktu\\nGQjaGqm0UB+aX0Z9y0B0qpfv9rj7nmIvEGiwBmDepNWYCGuW15JyqpN7QVVnG2xS\\nMrame7VqgjM7A+VGDD5In5LtWbM/CHAATvvFlQ5Ph13YE1EdnVbZ65c+KQv+5sFY\\nQ+zEop74d878uaC/SAHHXS46TiXneocaLSYw1CEZs/MAIy+9c4Q5ESbGpgnfg1Ad\\n6lwl7k3hsNHO/+tZzx4HJtOXDI1yAl3+q6T9J0yI3z97EinwvAKhS1eyOI2Y5eeT\\ntbQaNYkU127B3l/VNpd8fQm3Jkl/PqCCmDBQjUszFrJEODug\\n-----END CERTIFICATE-----\\n\", \"-----BEGIN CERTIFICATE-----\\nMIIDPzCCAiegAwIBAgIBADANBgkqhkiG9w0BAQUFADBOMRwwGgYDVQQDDBNtb25n\\ncmVsLWRldmVsb3BtZW50MRkwFwYKCZImiZPyLGQBGRYJcnVieWZvcmdlMRMwEQYK\\nCZImiZPyLGQBGRYDb3JnMB4XDTA3MDkxNjEwMzMwMFoXDTA4MDkxNTEwMzMwMFow\\nPTENMAsGA1UEAwwEZXZhbjEYMBYGCgmSJomT8ixkARkWCGNsb3VkYnVyMRIwEAYK\\nCZImiZPyLGQBGRYCc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDk\\nLQijz2fICmev4+9s0WB71WzJFYCUYFQQxqGlenbxWut9dlPSsBbskGjg+UITeOXi\\ncTh3MTqAB0i1LJyNOiyvDsAivn7GjKXhVvflp2/npMhBBe83P4HOWqeQBjkk3QJI\\nFFNBvqbFLeEXIP+HiqAOiyNHZEVXMepLEJLzGrg3Ly7M7A6L5fK7jDrt8jkm+c+8\\nzGquVHV5ohAebGd/vpHMLjpA7lCG5+MBgYZd33rRfNtCxDJMNRgnOu9PsB05+LJn\\nMpDKQq3x0SkOf5A+MVOcadNCaAkFflYk3SUcXaXWxu/eCHgqfW1m76RNSp5djpKE\\nCgNPK9lGIWpB3CHzDaVNAgMBAAGjOTA3MAkGA1UdEwQCMAAwCwYDVR0PBAQDAgSw\\nMB0GA1UdDgQWBBT5aonPfFBdJ5rWFG+8dZwgyB54LjANBgkqhkiG9w0BAQUFAAOC\\nAQEAiKbzWgMcvZs/TPwJxr8tJ+7mSGz7+zDkWcbBl8FpQq1DtRcATh1oyTkQT7t+\\nrFEBYMmb0FxbbUnojQp8hIFgFkUwFpStwWBL/okLSehntzI2iwjuEtfj4ac9Q3Y2\\nuSdbmZqsQTuu+lEUc5C4qLK7YKwToaul+cx7vWxyk1YendcVwRlFLIBqA5cPrwo3\\nyyGLTHlRYn2c9PSbM1B63Yg+LqSSAa4QSU3Wv9pNdffVpvwHPVEQpO7ZDo5slQFL\\nGf6+gbD/eZAvhpvmn8JlXb+LxKaFVMs2Yvrk1xOuT76SsPjEGWxkr7jZCIpsYfgQ\\nALN3mi/9z0Mf1YroliUgF0v5Yw==\\n-----END CERTIFICATE-----\\n\"]\n  s.date = %q{2007-10-26}\n  s.description = %q{Fix an exploitable bug in CGI multipart parsing.}\n  s.email = %q{}\n  s.files = [\"CHANGELOG\", \"lib/cgi_multipart_eof_fix.rb\", \"LICENSE\", \"Manifest\", \"README\", \"test/test_cgi_multipart_eof_fix.rb\", \"cgi_multipart_eof_fix.gemspec\"]\n  s.homepage = %q{http://blog.evanweaver.com/pages/code#cgi_multipart_eof_fix}\n  s.require_paths = [\"lib\"]\n  s.rubyforge_project = %q{mongrel}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Fix an exploitable bug in CGI multipart parsing.}\n  s.test_files = [\"test/test_cgi_multipart_eof_fix.rb\"]\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 2\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n    else\n    end\n  else\n  end\nend\n", 4096) = 3557
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/maruku-0.6.0.gemspec", {st_mode=S_IFREG|0644, st_size=7003, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/maruku-0.6.0.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=7003, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=7003, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{maruku}\n  s.version = \"0.6.0\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Andrea Censi\"]\n  s.autorequire = %q{maruku}\n  s.date = %q{2009-05-04}\n  s.description = %q{Maruku is a Markdown interpreter in Ruby. It features native export to HTML and PDF (via Latex). The output is really beautiful!}\n  s.email = %q{andrea@rubyforge.org}\n  s.executables = [\"maruku\", \"marutex\"]\n  s.files = [\"lib/maruku/attributes.rb\", \"lib/maruku/defaults.rb\", \"lib/maruku/errors_management.rb\", \"lib/maruku/ext/div.rb\", \"lib/maruku/ext/math/elements.rb\", \"lib/maruku/ext/math/latex_fix.rb\", \"lib/maruku/ext/math/mathml_engines/blahtex.rb\", \"lib/maruku/ext/math/mathml_engines/itex2mml.rb\", \"lib/maruku/ext/math/mathml_engines/none.rb\", \"lib/maruku/ext/math/mathml_engines/ritex.rb\", \"lib/maruku/ext/math/parsing.rb\", \"lib/maruku/ext/math/to_html.rb\", \"lib/maruku/ext/math/to_latex.rb\", \"lib/maruku/ext/math.rb\", \"lib/maruku/helpers.rb\", \"lib/maruku/input/charsource.rb\", \"lib/maruku/input/extensions.rb\", \"lib/maruku/input/html_helper.rb\", \"lib/maruku/input/linesource.rb\", \"lib/maruku/input/parse_block.rb\", \"lib/maruku/input/parse_doc.rb\", \"lib/maruku/input/parse_span_better.rb\", \"lib/maruku/input/rubypants.rb\", \"lib/maruku/input/type_detection.rb\", \"lib/maruku/input_textile2/t2_parser.rb\", \"lib/maruku/maruku.rb\", \"lib/maruku/output/s5/fancy.rb\", \"lib/maruku/output/s5/to_s5.rb\", \"lib/maruku/output/to_html.rb\", \"lib/maruku/output/to_latex.rb\", \"lib/maruku/output/to_latex_entities.rb\", \"lib/maruku/output/to_latex_strings.rb\", \"lib/maruku/output/to_markdown.rb\", \"lib/maruku/output/to_s.rb\", \"lib/maruku/string_utils.rb\", \"lib/maruku/structures.rb\", \"lib/maruku/structures_inspect.rb\", \"lib/maruku/structures_iterators.rb\", \"lib/maruku/tests/benchmark.rb\", \"lib/maruku/tests/new_parser.rb\", \"lib/maruku/tests/tests.rb\", \"lib/maruku/textile2.rb\", \"lib/maruku/toc.rb\", \"lib/maruku/usage/example1.rb\", \"lib/maruku/version.rb\", \"lib/maruku.rb\", \"docs/changelog.md\", \"docs/div_syntax.md\", \"docs/entity_test.md\", \"docs/markdown_syntax.md\", \"docs/maruku.md\", \"docs/math.md\", \"docs/other_stuff.md\", \"docs/proposal.md\", \"tests/bugs/code_in_links.md\", \"tests/bugs/complex_escaping.md\", \"tests/math/syntax.md\", \"tests/math_usage/document.md\", \"tests/others/abbreviations.md\", \"tests/others/blank.md\", \"tests/others/code.md\", \"tests/others/code2.md\", \"tests/others/code3.md\", \"tests/others/email.md\", \"tests/others/entities.md\", \"tests/others/escaping.md\", \"tests/others/extra_dl.md\", \"tests/others/extra_header_id.md\", \"tests/others/extra_table1.md\", \"tests/others/footnotes.md\", \"tests/others/headers.md\", \"tests/others/hrule.md\", \"tests/others/images.md\", \"tests/others/inline_html.md\", \"tests/others/links.md\", \"tests/others/list1.md\", \"tests/others/list2.md\", \"tests/others/list3.md\", \"tests/others/lists.md\", \"tests/others/lists_after_paragraph.md\", \"tests/others/lists_ol.md\", \"tests/others/misc_sw.md\", \"tests/others/one.md\", \"tests/others/paragraphs.md\", \"tests/others/sss06.md\", \"tests/others/test.md\", \"tests/s5/s5profiling.md\", \"tests/unittest/abbreviations.md\", \"tests/unittest/alt.md\", \"tests/unittest/attributes/att2.md\", \"tests/unittest/attributes/att3.md\", \"tests/unittest/attributes/attributes.md\", \"tests/unittest/attributes/circular.md\", \"tests/unittest/attributes/default.md\", \"tests/unittest/blank.md\", \"tests/unittest/blanks_in_code.md\", \"tests/unittest/bug_def.md\", \"tests/unittest/bug_table.md\", \"tests/unittest/code.md\", \"tests/unittest/code2.md\", \"tests/unittest/code3.md\", \"tests/unittest/data_loss.md\", \"tests/unittest/divs/div1.md\", \"tests/unittest/divs/div2.md\", \"tests/unittest/divs/div3_nest.md\", \"tests/unittest/easy.md\", \"tests/unittest/email.md\", \"tests/unittest/encoding/iso-8859-1.md\", \"tests/unittest/encoding/utf-8.md\", \"tests/unittest/entities.md\", \"tests/unittest/escaping.md\", \"tests/unittest/extra_dl.md\", \"tests/unittest/extra_head"..., 4096) = 4096
read(3, ".md\", \"tests/unittest/headers.md\", \"tests/unittest/hex_entities.md\", \"tests/unittest/hrule.md\", \"tests/unittest/html2.md\", \"tests/unittest/html3.md\", \"tests/unittest/html4.md\", \"tests/unittest/html5.md\", \"tests/unittest/ie.md\", \"tests/unittest/images.md\", \"tests/unittest/images2.md\", \"tests/unittest/inline_html.md\", \"tests/unittest/inline_html2.md\", \"tests/unittest/links.md\", \"tests/unittest/links2.md\", \"tests/unittest/list1.md\", \"tests/unittest/list12.md\", \"tests/unittest/list2.md\", \"tests/unittest/list3.md\", \"tests/unittest/list4.md\", \"tests/unittest/lists.md\", \"tests/unittest/lists10.md\", \"tests/unittest/lists11.md\", \"tests/unittest/lists6.md\", \"tests/unittest/lists9.md\", \"tests/unittest/lists_after_paragraph.md\", \"tests/unittest/lists_ol.md\", \"tests/unittest/loss.md\", \"tests/unittest/math/equations.md\", \"tests/unittest/math/inline.md\", \"tests/unittest/math/math2.md\", \"tests/unittest/math/notmath.md\", \"tests/unittest/math/table.md\", \"tests/unittest/math/table2.md\", \"tests/unittest/misc_sw.md\", \"tests/unittest/notyet/escape.md\", \"tests/unittest/notyet/header_after_par.md\", \"tests/unittest/notyet/ticks.md\", \"tests/unittest/notyet/triggering.md\", \"tests/unittest/olist.md\", \"tests/unittest/one.md\", \"tests/unittest/paragraph.md\", \"tests/unittest/paragraph_rules/dont_merge_ref.md\", \"tests/unittest/paragraph_rules/tab_is_blank.md\", \"tests/unittest/paragraphs.md\", \"tests/unittest/pending/amps.md\", \"tests/unittest/pending/empty_cells.md\", \"tests/unittest/pending/link.md\", \"tests/unittest/pending/ref.md\", \"tests/unittest/recover/recover_links.md\", \"tests/unittest/red_tests/abbrev.md\", \"tests/unittest/red_tests/lists7.md\", \"tests/unittest/red_tests/lists7b.md\", \"tests/unittest/red_tests/lists8.md\", \"tests/unittest/red_tests/xml.md\", \"tests/unittest/references/long_example.md\", \"tests/unittest/references/spaces_and_numbers.md\", \"tests/unittest/smartypants.md\", \"tests/unittest/syntax_hl.md\", \"tests/unittest/table_attributes.md\", \"tests/unittest/test.md\", \"tests/unittest/underscore_in_words.md\", \"tests/unittest/wrapping.md\", \"tests/unittest/xml2.md\", \"tests/unittest/xml3.md\", \"tests/unittest/xml_instruction.md\", \"tests/utf8-files/simple.md\", \"bin/marudown\", \"bin/maruku\", \"bin/marutest\", \"bin/marutex\", \"unit_test_block.sh\", \"unit_test_span.sh\", \"Rakefile\", \"maruku_gem.rb\"]\n  s.homepage = %q{http://maruku.rubyforge.org}\n  s.require_paths = [\"lib\"]\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Maruku is a Markdown-superset interpreter written in Ruby.}\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 2\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<syntax>, [\">= 1.0.0\"])\n    else\n      s.add_dependency(%q<syntax>, [\">= 1.0.0\"])\n    end\n  else\n    s.add_dependency(%q<syntax>, [\">= 1.0.0\"])\n  end\nend\n", 4096) = 2907
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/nokogiri-1.4.1.gemspec", {st_mode=S_IFREG|0644, st_size=14417, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/nokogiri-1.4.1.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=14417, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=14417, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7861000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{nokogiri}\n  s.version = \"1.4.1\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Aaron Patterson\", \"Mike Dalessio\"]\n  s.cert_chain = [\"-----BEGIN CERTIFICATE-----\\nMIIDNjCCAh6gAwIBAgIBADANBgkqhkiG9w0BAQUFADBBMQ8wDQYDVQQDDAZhYXJv\\nbnAxGTAXBgoJkiaJk/IsZAEZFglydWJ5Zm9yZ2UxEzARBgoJkiaJk/IsZAEZFgNv\\ncmcwHhcNMDkxMTA1MDAwNDQ4WhcNMTAxMTA1MDAwNDQ4WjBBMQ8wDQYDVQQDDAZh\\nYXJvbnAxGTAXBgoJkiaJk/IsZAEZFglydWJ5Zm9yZ2UxEzARBgoJkiaJk/IsZAEZ\\nFgNvcmcwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDNSD14Gb2mCX/5\\nfE85uW/jT7fcYI8XolrzdpzfvxD3y+Pt/yA5eciBiE+hNAWU2PM1ZMOq4MOV9EqR\\nhYzupp/zFoC7ZZ3PF8nJBFKgfKNf0sp9o3XCUviaZjoSYNIvGQocrakQo+h3x3Od\\nNqZWtVsLz9P/G1foUBpc95gGGBodbj/CZVc32F+xVvmejqe3RaMLGI70ZOuTcsRi\\nt8V4T7okmUbLi6VmPYlH/9mKvU7ObRHXMYNhkkife5phh8vjsiCd8Q397+jFaL0f\\nCd23idNV7lbvdjIuYLV+9u5cPkDjANLAnGRaRS1x2SEfH/8g0Te6/jeKfzBH83D0\\n5v5HTx+HAgMBAAGjOTA3MAkGA1UdEwQCMAAwCwYDVR0PBAQDAgSwMB0GA1UdDgQW\\nBBTs3LnPhoi2m7BTf9tHvNQYsOG7aTANBgkqhkiG9w0BAQUFAAOCAQEAVH7G+nSf\\nWMPz7Iwcnd+WrWWq/mr5ke0qQoiz4tk0h7bsa3fEnUDBiMfmQhv/uBzA4Gkw9zxB\\nIfKljsZq0yE+du/1u2Mph7dMIg2oiwMurpduPpx9sfaqsqSBBOzggxiUEmHDNrPT\\nuTzaid0gdOx/TacZ4RwrEnx6XNkhxC2YaTH2Y68hoJzSzRGtdU2Kk6mT4YraCP+u\\nETP5hCJAiB5l4jC8U6wwvKQDHTMoaUu3eu/txe1PDjoe3GICzs/e6bzYBWYmKu7J\\n5YM3l5J4rDvIPAGH4VRr5nSs+qbZh+kCdE1khvTxH51xkR3qAfEEogAd2VlnjELM\\nf9Gw8x3RwgLvkA==\\n-----END CERTIFICATE-----\\n\"]\n  s.date = %q{2009-12-10}\n  s.default_executable = %q{nokogiri}\n  s.description = %q{Nokogiri (\351\213\270) is an HTML, XML, SAX, and Reader parser.  Among Nokogiri's\nmany features is the ability to search documents via XPath or CSS3 selectors.\n\nXML is like violence - if it doesn\342\200\231t solve your problems, you are not using\nenough of it.}\n  s.email = [\"aaronp@rubyforge.org\", \"mike.dalessio@gmail.com\"]\n  s.executables = [\"nokogiri\"]\n  s.extensions = [\"ext/nokogiri/extconf.rb\"]\n  s.extra_rdoc_files = [\"Manifest.txt\", \"CHANGELOG.ja.rdoc\", \"CHANGELOG.rdoc\", \"README.ja.rdoc\", \"README.rdoc\"]\n  s.files = [\".autotest\", \"CHANGELOG.ja.rdoc\", \"CHANGELOG.rdoc\", \"Manifest.txt\", \"README.ja.rdoc\", \"README.rdoc\", \"Rakefile\", \"bin/nokogiri\", \"deps.rip\", \"ext/nokogiri/extconf.rb\", \"ext/nokogiri/html_document.c\", \"ext/nokogiri/html_document.h\", \"ext/nokogiri/html_element_description.c\", \"ext/nokogiri/html_element_description.h\", \"ext/nokogiri/html_entity_lookup.c\", \"ext/nokogiri/html_entity_lookup.h\", \"ext/nokogiri/html_sax_parser_context.c\", \"ext/nokogiri/html_sax_parser_context.h\", \"ext/nokogiri/nokogiri.c\", \"ext/nokogiri/nokogiri.h\", \"ext/nokogiri/xml_attr.c\", \"ext/nokogiri/xml_attr.h\", \"ext/nokogiri/xml_attribute_decl.c\", \"ext/nokogiri/xml_attribute_decl.h\", \"ext/nokogiri/xml_cdata.c\", \"ext/nokogiri/xml_cdata.h\", \"ext/nokogiri/xml_comment.c\", \"ext/nokogiri/xml_comment.h\", \"ext/nokogiri/xml_document.c\", \"ext/nokogiri/xml_document.h\", \"ext/nokogiri/xml_document_fragment.c\", \"ext/nokogiri/xml_document_fragment.h\", \"ext/nokogiri/xml_dtd.c\", \"ext/nokogiri/xml_dtd.h\", \"ext/nokogiri/xml_element_content.c\", \"ext/nokogiri/xml_element_content.h\", \"ext/nokogiri/xml_element_decl.c\", \"ext/nokogiri/xml_element_decl.h\", \"ext/nokogiri/xml_encoding_handler.c\", \"ext/nokogiri/xml_encoding_handler.h\", \"ext/nokogiri/xml_entity_decl.c\", \"ext/nokogiri/xml_entity_decl.h\", \"ext/nokogiri/xml_entity_reference.c\", \"ext/nokogiri/xml_entity_reference.h\", \"ext/nokogiri/xml_io.c\", \"ext/nokogiri/xml_io.h\", \"ext/nokogiri/xml_namespace.c\", \"ext/nokogiri/xml_namespace.h\", \"ext/nokogiri/xml_node.c\", \"ext/nokogiri/xml_node.h\", \"ext/nokogiri/xml_node_set.c\", \"ext/nokogiri/xml_node_set.h\", \"ext/nokogiri/xml_processing_instruction.c\", \"ext/nokogiri/xml_processing_instruction.h\", \"ext/nokogiri/xml_reader.c\", \"ext/nokogiri/xml_reader.h\", \"ext/nokogiri/xml_relax_ng.c\", \"ext/nokogiri/xml_relax_ng.h\", \"ext/nokogiri/xml_sax_parser.c\", \"ext/nokogiri/xml_sax_parser.h\", \"ext/nokogiri/xml_sax_parser_context.c\", \"ext/nokogiri/xml_sax_parser_context.h\","..., 4096) = 4096
read(3, "chema.c\", \"ext/nokogiri/xml_schema.h\", \"ext/nokogiri/xml_syntax_error.c\", \"ext/nokogiri/xml_syntax_error.h\", \"ext/nokogiri/xml_text.c\", \"ext/nokogiri/xml_text.h\", \"ext/nokogiri/xml_xpath.c\", \"ext/nokogiri/xml_xpath.h\", \"ext/nokogiri/xml_xpath_context.c\", \"ext/nokogiri/xml_xpath_context.h\", \"ext/nokogiri/xslt_stylesheet.c\", \"ext/nokogiri/xslt_stylesheet.h\", \"lib/nokogiri.rb\", \"lib/nokogiri/css.rb\", \"lib/nokogiri/css/generated_parser.rb\", \"lib/nokogiri/css/generated_tokenizer.rb\", \"lib/nokogiri/css/node.rb\", \"lib/nokogiri/css/parser.rb\", \"lib/nokogiri/css/parser.y\", \"lib/nokogiri/css/syntax_error.rb\", \"lib/nokogiri/css/tokenizer.rb\", \"lib/nokogiri/css/tokenizer.rex\", \"lib/nokogiri/css/xpath_visitor.rb\", \"lib/nokogiri/decorators/slop.rb\", \"lib/nokogiri/ffi/encoding_handler.rb\", \"lib/nokogiri/ffi/html/document.rb\", \"lib/nokogiri/ffi/html/element_description.rb\", \"lib/nokogiri/ffi/html/entity_lookup.rb\", \"lib/nokogiri/ffi/html/sax/parser_context.rb\", \"lib/nokogiri/ffi/io_callbacks.rb\", \"lib/nokogiri/ffi/libxml.rb\", \"lib/nokogiri/ffi/structs/common_node.rb\", \"lib/nokogiri/ffi/structs/html_elem_desc.rb\", \"lib/nokogiri/ffi/structs/html_entity_desc.rb\", \"lib/nokogiri/ffi/structs/xml_alloc.rb\", \"lib/nokogiri/ffi/structs/xml_attr.rb\", \"lib/nokogiri/ffi/structs/xml_attribute.rb\", \"lib/nokogiri/ffi/structs/xml_buffer.rb\", \"lib/nokogiri/ffi/structs/xml_char_encoding_handler.rb\", \"lib/nokogiri/ffi/structs/xml_document.rb\", \"lib/nokogiri/ffi/structs/xml_dtd.rb\", \"lib/nokogiri/ffi/structs/xml_element.rb\", \"lib/nokogiri/ffi/structs/xml_element_content.rb\", \"lib/nokogiri/ffi/structs/xml_entity.rb\", \"lib/nokogiri/ffi/structs/xml_enumeration.rb\", \"lib/nokogiri/ffi/structs/xml_node.rb\", \"lib/nokogiri/ffi/structs/xml_node_set.rb\", \"lib/nokogiri/ffi/structs/xml_notation.rb\", \"lib/nokogiri/ffi/structs/xml_ns.rb\", \"lib/nokogiri/ffi/structs/xml_parser_context.rb\", \"lib/nokogiri/ffi/structs/xml_relax_ng.rb\", \"lib/nokogiri/ffi/structs/xml_sax_handler.rb\", \"lib/nokogiri/ffi/structs/xml_sax_push_parser_context.rb\", \"lib/nokogiri/ffi/structs/xml_schema.rb\", \"lib/nokogiri/ffi/structs/xml_syntax_error.rb\", \"lib/nokogiri/ffi/structs/xml_text_reader.rb\", \"lib/nokogiri/ffi/structs/xml_xpath_context.rb\", \"lib/nokogiri/ffi/structs/xml_xpath_object.rb\", \"lib/nokogiri/ffi/structs/xml_xpath_parser_context.rb\", \"lib/nokogiri/ffi/structs/xslt_stylesheet.rb\", \"lib/nokogiri/ffi/xml/attr.rb\", \"lib/nokogiri/ffi/xml/attribute_decl.rb\", \"lib/nokogiri/ffi/xml/cdata.rb\", \"lib/nokogiri/ffi/xml/comment.rb\", \"lib/nokogiri/ffi/xml/document.rb\", \"lib/nokogiri/ffi/xml/document_fragment.rb\", \"lib/nokogiri/ffi/xml/dtd.rb\", \"lib/nokogiri/ffi/xml/element_content.rb\", \"lib/nokogiri/ffi/xml/element_decl.rb\", \"lib/nokogiri/ffi/xml/entity_decl.rb\", \"lib/nokogiri/ffi/xml/entity_reference.rb\", \"lib/nokogiri/ffi/xml/namespace.rb\", \"lib/nokogiri/ffi/xml/node.rb\", \"lib/nokogiri/ffi/xml/node_set.rb\", \"lib/nokogiri/ffi/xml/processing_instruction.rb\", \"lib/nokogiri/ffi/xml/reader.rb\", \"lib/nokogiri/ffi/xml/relax_ng.rb\", \"lib/nokogiri/ffi/xml/sax/parser.rb\", \"lib/nokogiri/ffi/xml/sax/parser_context.rb\", \"lib/nokogiri/ffi/xml/sax/push_parser.rb\", \"lib/nokogiri/ffi/xml/schema.rb\", \"lib/nokogiri/ffi/xml/syntax_error.rb\", \"lib/nokogiri/ffi/xml/text.rb\", \"lib/nokogiri/ffi/xml/xpath.rb\", \"lib/nokogiri/ffi/xml/xpath_context.rb\", \"lib/nokogiri/ffi/xslt/stylesheet.rb\", \"lib/nokogiri/html.rb\", \"lib/nokogiri/html/builder.rb\", \"lib/nokogiri/html/document.rb\", \"lib/nokogiri/html/document_fragment.rb\", \"lib/nokogiri/html/element_description.rb\", \"lib/nokogiri/html/entity_lookup.rb\", \"lib/nokogiri/html/sax/parser.rb\", \"lib/nokogiri/html/sax/parser_context.rb\", \"lib/nokogiri/syntax_error.rb\", \"lib/nokogiri/version.rb\", \"lib/nokogiri/version_warning.rb\", \"lib/nokogiri/xml.rb\", \"lib/nokogiri/xml/attr.rb\", \"lib/nokogiri/xml/attribute_decl.rb\", \"lib/nokogiri/xml/builder.rb\", \"lib/nokogiri/xml/cdata.rb\", \"lib/nokogiri/xml/character_data.rb\", \"lib/nokogiri/xml/document.rb\", \"lib/nokogiri/xml/document_fragment.rb\", \"lib/no"..., 4096) = 4096
read(3, "lib/nokogiri/xml/entity_decl.rb\", \"lib/nokogiri/xml/fragment_handler.rb\", \"lib/nokogiri/xml/namespace.rb\", \"lib/nokogiri/xml/node.rb\", \"lib/nokogiri/xml/node/save_options.rb\", \"lib/nokogiri/xml/node_set.rb\", \"lib/nokogiri/xml/notation.rb\", \"lib/nokogiri/xml/parse_options.rb\", \"lib/nokogiri/xml/pp.rb\", \"lib/nokogiri/xml/pp/character_data.rb\", \"lib/nokogiri/xml/pp/node.rb\", \"lib/nokogiri/xml/processing_instruction.rb\", \"lib/nokogiri/xml/reader.rb\", \"lib/nokogiri/xml/relax_ng.rb\", \"lib/nokogiri/xml/sax.rb\", \"lib/nokogiri/xml/sax/document.rb\", \"lib/nokogiri/xml/sax/parser.rb\", \"lib/nokogiri/xml/sax/parser_context.rb\", \"lib/nokogiri/xml/sax/push_parser.rb\", \"lib/nokogiri/xml/schema.rb\", \"lib/nokogiri/xml/syntax_error.rb\", \"lib/nokogiri/xml/xpath.rb\", \"lib/nokogiri/xml/xpath/syntax_error.rb\", \"lib/nokogiri/xml/xpath_context.rb\", \"lib/nokogiri/xslt.rb\", \"lib/nokogiri/xslt/stylesheet.rb\", \"lib/xsd/xmlparser/nokogiri.rb\", \"tasks/test.rb\", \"test/css/test_nthiness.rb\", \"test/css/test_parser.rb\", \"test/css/test_tokenizer.rb\", \"test/css/test_xpath_visitor.rb\", \"test/ffi/test_document.rb\", \"test/files/2ch.html\", \"test/files/address_book.rlx\", \"test/files/address_book.xml\", \"test/files/bar/bar.xsd\", \"test/files/dont_hurt_em_why.xml\", \"test/files/exslt.xml\", \"test/files/exslt.xslt\", \"test/files/foo/foo.xsd\", \"test/files/po.xml\", \"test/files/po.xsd\", \"test/files/shift_jis.html\", \"test/files/shift_jis.xml\", \"test/files/snuggles.xml\", \"test/files/staff.dtd\", \"test/files/staff.xml\", \"test/files/staff.xslt\", \"test/files/tlm.html\", \"test/files/valid_bar.xml\", \"test/helper.rb\", \"test/html/sax/test_parser.rb\", \"test/html/sax/test_parser_context.rb\", \"test/html/test_builder.rb\", \"test/html/test_document.rb\", \"test/html/test_document_encoding.rb\", \"test/html/test_document_fragment.rb\", \"test/html/test_element_description.rb\", \"test/html/test_named_characters.rb\", \"test/html/test_node.rb\", \"test/html/test_node_encoding.rb\", \"test/test_convert_xpath.rb\", \"test/test_css_cache.rb\", \"test/test_encoding_handler.rb\", \"test/test_memory_leak.rb\", \"test/test_nokogiri.rb\", \"test/test_reader.rb\", \"test/test_soap4r_sax.rb\", \"test/test_xslt_transforms.rb\", \"test/xml/node/test_save_options.rb\", \"test/xml/node/test_subclass.rb\", \"test/xml/sax/test_parser.rb\", \"test/xml/sax/test_parser_context.rb\", \"test/xml/sax/test_push_parser.rb\", \"test/xml/test_attr.rb\", \"test/xml/test_attribute_decl.rb\", \"test/xml/test_builder.rb\", \"test/xml/test_cdata.rb\", \"test/xml/test_comment.rb\", \"test/xml/test_document.rb\", \"test/xml/test_document_encoding.rb\", \"test/xml/test_document_fragment.rb\", \"test/xml/test_dtd.rb\", \"test/xml/test_dtd_encoding.rb\", \"test/xml/test_element_content.rb\", \"test/xml/test_element_decl.rb\", \"test/xml/test_entity_decl.rb\", \"test/xml/test_entity_reference.rb\", \"test/xml/test_namespace.rb\", \"test/xml/test_node.rb\", \"test/xml/test_node_attributes.rb\", \"test/xml/test_node_encoding.rb\", \"test/xml/test_node_reparenting.rb\", \"test/xml/test_node_set.rb\", \"test/xml/test_parse_options.rb\", \"test/xml/test_processing_instruction.rb\", \"test/xml/test_reader_encoding.rb\", \"test/xml/test_relax_ng.rb\", \"test/xml/test_schema.rb\", \"test/xml/test_syntax_error.rb\", \"test/xml/test_text.rb\", \"test/xml/test_unparented_node.rb\", \"test/xml/test_xpath.rb\"]\n  s.homepage = %q{http://nokogiri.org}\n  s.rdoc_options = [\"--main\", \"README.rdoc\"]\n  s.require_paths = [\"lib\", \"ext\"]\n  s.rubyforge_project = %q{nokogiri}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Nokogiri (\351\213\270) is an HTML, XML, SAX, and Reader parser}\n  s.test_files = [\"test/css/test_nthiness.rb\", \"test/css/test_parser.rb\", \"test/css/test_tokenizer.rb\", \"test/css/test_xpath_visitor.rb\", \"test/ffi/test_document.rb\", \"test/html/sax/test_parser.rb\", \"test/html/sax/test_parser_context.rb\", \"test/html/test_builder.rb\", \"test/html/test_document.rb\", \"test/html/test_document_encoding.rb\", \"test/html/test_document_fragment.rb\", \"test/html/test_element_description.rb\", \"test/html/test_named_characters.rb\", \"test/html/test_node.rb\", \"t"..., 4096) = 4096
read(3, "est_encoding_handler.rb\", \"test/test_memory_leak.rb\", \"test/test_nokogiri.rb\", \"test/test_reader.rb\", \"test/test_soap4r_sax.rb\", \"test/test_xslt_transforms.rb\", \"test/xml/node/test_save_options.rb\", \"test/xml/node/test_subclass.rb\", \"test/xml/sax/test_parser.rb\", \"test/xml/sax/test_parser_context.rb\", \"test/xml/sax/test_push_parser.rb\", \"test/xml/test_attr.rb\", \"test/xml/test_attribute_decl.rb\", \"test/xml/test_builder.rb\", \"test/xml/test_cdata.rb\", \"test/xml/test_comment.rb\", \"test/xml/test_document.rb\", \"test/xml/test_document_encoding.rb\", \"test/xml/test_document_fragment.rb\", \"test/xml/test_dtd.rb\", \"test/xml/test_dtd_encoding.rb\", \"test/xml/test_element_content.rb\", \"test/xml/test_element_decl.rb\", \"test/xml/test_entity_decl.rb\", \"test/xml/test_entity_reference.rb\", \"test/xml/test_namespace.rb\", \"test/xml/test_node.rb\", \"test/xml/test_node_attributes.rb\", \"test/xml/test_node_encoding.rb\", \"test/xml/test_node_reparenting.rb\", \"test/xml/test_node_set.rb\", \"test/xml/test_parse_options.rb\", \"test/xml/test_processing_instruction.rb\", \"test/xml/test_reader_encoding.rb\", \"test/xml/test_relax_ng.rb\", \"test/xml/test_schema.rb\", \"test/xml/test_syntax_error.rb\", \"test/xml/test_text.rb\", \"test/xml/test_unparented_node.rb\", \"test/xml/test_xpath.rb\"]\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 3\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n      s.add_development_dependency(%q<racc>, [\">= 0\"])\n      s.add_development_dependency(%q<rexical>, [\">= 0\"])\n      s.add_development_dependency(%q<rake-compiler>, [\">= 0\"])\n      s.add_development_dependency(%q<hoe>, [\">= 2.3.3\"])\n    else\n      s.add_dependency(%q<racc>, [\">= 0\"])\n      s.add_dependency(%q<rexical>, [\">= 0\"])\n      s.add_dependency(%q<rake-compiler>, [\">= 0\"])\n      s.add_dependency(%q<hoe>, [\">= 2.3.3\"])\n    end\n  else\n    s.add_dependency(%q<racc>, [\">= 0\"])\n    s.add_dependency(%q<rexical>, [\">= 0\"])\n    s.add_dependency(%q<rake-compiler>, [\">= 0\"])\n    s.add_dependency(%q<hoe>, [\">= 2.3.3\"])\n  end\nend\n", 4096) = 2129
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb7861000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
mmap2(NULL, 1167360, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760b000
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/passenger-2.2.8.gemspec", {st_mode=S_IFREG|0644, st_size=52990, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/passenger-2.2.8.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=52990, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=52990, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{passenger}\n  s.version = \"2.2.8\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Phusion - http://www.phusion.nl/\"]\n  s.date = %q{2009-12-15}\n  s.description = %q{Passenger is an Apache module for Ruby on Rails support.}\n  s.email = %q{info@phusion.nl}\n  s.executables = [\"passenger-spawn-server\", \"passenger-install-apache2-module\", \"passenger-install-nginx-module\", \"passenger-config\", \"passenger-memory-stats\", \"passenger-make-enterprisey\", \"passenger-status\", \"passenger-stress-test\"]\n  s.extensions = [\"ext/phusion_passenger/extconf.rb\"]\n  s.extra_rdoc_files = [\"README\"]\n  s.files = [\"Rakefile\", \"README\", \"DEVELOPERS.TXT\", \"LICENSE\", \"INSTALL\", \"NEWS\", \"lib/phusion_passenger/abstract_installer.rb\", \"lib/phusion_passenger/abstract_request_handler.rb\", \"lib/phusion_passenger/abstract_server.rb\", \"lib/phusion_passenger/abstract_server_collection.rb\", \"lib/phusion_passenger/admin_tools/control_process.rb\", \"lib/phusion_passenger/admin_tools.rb\", \"lib/phusion_passenger/application.rb\", \"lib/phusion_passenger/console_text_template.rb\", \"lib/phusion_passenger/constants.rb\", \"lib/phusion_passenger/dependencies.rb\", \"lib/phusion_passenger/events.rb\", \"lib/phusion_passenger/exceptions.rb\", \"lib/phusion_passenger/html_template.rb\", \"lib/phusion_passenger/message_channel.rb\", \"lib/phusion_passenger/packaging.rb\", \"lib/phusion_passenger/platform_info.rb\", \"lib/phusion_passenger/rack/application_spawner.rb\", \"lib/phusion_passenger/rack/request_handler.rb\", \"lib/phusion_passenger/railz/application_spawner.rb\", \"lib/phusion_passenger/railz/cgi_fixed.rb\", \"lib/phusion_passenger/railz/framework_spawner.rb\", \"lib/phusion_passenger/railz/request_handler.rb\", \"lib/phusion_passenger/simple_benchmarking.rb\", \"lib/phusion_passenger/spawn_manager.rb\", \"lib/phusion_passenger/utils/rewindable_input.rb\", \"lib/phusion_passenger/utils.rb\", \"lib/phusion_passenger/wsgi/application_spawner.rb\", \"lib/phusion_passenger/wsgi/request_handler.py\", \"lib/phusion_passenger/templates/app_exited_during_initialization.html.erb\", \"lib/phusion_passenger/templates/app_init_error.html.erb\", \"lib/phusion_passenger/templates/database_error.html.erb\", \"lib/phusion_passenger/templates/error_layout.css\", \"lib/phusion_passenger/templates/error_layout.html.erb\", \"lib/phusion_passenger/templates/framework_init_error.html.erb\", \"lib/phusion_passenger/templates/general_error.html.erb\", \"lib/phusion_passenger/templates/invalid_app_root.html.erb\", \"lib/phusion_passenger/templates/load_error.html.erb\", \"lib/phusion_passenger/templates/version_not_found.html.erb\", \"lib/phusion_passenger/templates/apache2/apache_must_be_compiled_with_compatible_mpm.txt.erb\", \"lib/phusion_passenger/templates/apache2/config_snippets.txt.erb\", \"lib/phusion_passenger/templates/apache2/deployment_example.txt.erb\", \"lib/phusion_passenger/templates/apache2/no_write_permission_to_passenger_root.txt.erb\", \"lib/phusion_passenger/templates/apache2/possible_solutions_for_compilation_and_installation_problems.txt.erb\", \"lib/phusion_passenger/templates/apache2/run_installer_as_root.txt.erb\", \"lib/phusion_passenger/templates/apache2/welcome.txt.erb\", \"lib/phusion_passenger/templates/nginx/ask_for_extra_configure_flags.txt.erb\", \"lib/phusion_passenger/templates/nginx/cannot_write_to_dir.txt.erb\", \"lib/phusion_passenger/templates/nginx/config_snippets.txt.erb\", \"lib/phusion_passenger/templates/nginx/config_snippets_inserted.txt.erb\", \"lib/phusion_passenger/templates/nginx/confirm_extra_configure_flags.txt.erb\", \"lib/phusion_passenger/templates/nginx/deployment_example.txt.erb\", \"lib/phusion_passenger/templates/nginx/pcre_could_not_be_downloaded.txt.erb\", \"lib/phusion_passenger/templates/nginx/pcre_could_not_be_extracted.txt.erb\", \"lib/phusion_passenger/templates/nginx/possible_solutions_for_compilation_and_installation_problems.txt.erb\", \"lib/phusion_passenger/templates/nginx/pos"..., 4096) = 4096
read(3, "nginx/query_download_and_install.txt.erb\", \"lib/phusion_passenger/templates/nginx/run_installer_as_root.txt.erb\", \"lib/phusion_passenger/templates/nginx/welcome.txt.erb\", \"bin/passenger-config\", \"bin/passenger-install-apache2-module\", \"bin/passenger-install-nginx-module\", \"bin/passenger-make-enterprisey\", \"bin/passenger-memory-stats\", \"bin/passenger-spawn-server\", \"bin/passenger-status\", \"bin/passenger-stress-test\", \"doc/ApplicationPool algorithm.txt\", \"doc/Architectural overview.html\", \"doc/Architectural overview.txt\", \"doc/definitions.h\", \"doc/Doxyfile\", \"doc/Security of user switching support.html\", \"doc/Security of user switching support.txt\", \"doc/Users guide Apache.html\", \"doc/Users guide Apache.txt\", \"doc/Users guide Nginx.html\", \"doc/Users guide Nginx.txt\", \"doc/cxxapi/annotated.html\", \"doc/cxxapi/Application_8h-source.html\", \"doc/cxxapi/ApplicationPool_8h-source.html\", \"doc/cxxapi/ApplicationPoolServer_8h-source.html\", \"doc/cxxapi/Bucket_8h-source.html\", \"doc/cxxapi/CachedFileStat_8h-source.html\", \"doc/cxxapi/classClient-members.html\", \"doc/cxxapi/classClient.html\", \"doc/cxxapi/classes.html\", \"doc/cxxapi/classHooks-members.html\", \"doc/cxxapi/classHooks.html\", \"doc/cxxapi/classPassenger_1_1Application-members.html\", \"doc/cxxapi/classPassenger_1_1Application.html\", \"doc/cxxapi/classPassenger_1_1Application_1_1Session-members.html\", \"doc/cxxapi/classPassenger_1_1Application_1_1Session.html\", \"doc/cxxapi/classPassenger_1_1ApplicationPool-members.html\", \"doc/cxxapi/classPassenger_1_1ApplicationPool.html\", \"doc/cxxapi/classPassenger_1_1ApplicationPool__inherit__graph.map\", \"doc/cxxapi/classPassenger_1_1ApplicationPool__inherit__graph.md5\", \"doc/cxxapi/classPassenger_1_1ApplicationPool__inherit__graph.png\", \"doc/cxxapi/classPassenger_1_1ApplicationPoolServer-members.html\", \"doc/cxxapi/classPassenger_1_1ApplicationPoolServer.html\", \"doc/cxxapi/classPassenger_1_1BufferedUpload-members.html\", \"doc/cxxapi/classPassenger_1_1BufferedUpload.html\", \"doc/cxxapi/classPassenger_1_1BusyException-members.html\", \"doc/cxxapi/classPassenger_1_1BusyException.html\", \"doc/cxxapi/classPassenger_1_1ConfigurationException-members.html\", \"doc/cxxapi/classPassenger_1_1ConfigurationException.html\", \"doc/cxxapi/classPassenger_1_1DirectoryMapper-members.html\", \"doc/cxxapi/classPassenger_1_1DirectoryMapper.html\", \"doc/cxxapi/classPassenger_1_1DummySpawnManager-members.html\", \"doc/cxxapi/classPassenger_1_1DummySpawnManager.html\", \"doc/cxxapi/classPassenger_1_1FileChecker-members.html\", \"doc/cxxapi/classPassenger_1_1FileChecker.html\", \"doc/cxxapi/classPassenger_1_1FileNotFoundException-members.html\", \"doc/cxxapi/classPassenger_1_1FileNotFoundException.html\", \"doc/cxxapi/classPassenger_1_1FileNotFoundException__inherit__graph.map\", \"doc/cxxapi/classPassenger_1_1FileNotFoundException__inherit__graph.md5\", \"doc/cxxapi/classPassenger_1_1FileNotFoundException__inherit__graph.png\", \"doc/cxxapi/classPassenger_1_1FileSystemException-members.html\", \"doc/cxxapi/classPassenger_1_1FileSystemException.html\", \"doc/cxxapi/classPassenger_1_1FileSystemException__inherit__graph.map\", \"doc/cxxapi/classPassenger_1_1FileSystemException__inherit__graph.md5\", \"doc/cxxapi/classPassenger_1_1FileSystemException__inherit__graph.png\", \"doc/cxxapi/classPassenger_1_1IOException-members.html\", \"doc/cxxapi/classPassenger_1_1IOException.html\", \"doc/cxxapi/classPassenger_1_1IOException__inherit__graph.map\", \"doc/cxxapi/classPassenger_1_1IOException__inherit__graph.md5\", \"doc/cxxapi/classPassenger_1_1IOException__inherit__graph.png\", \"doc/cxxapi/classPassenger_1_1MessageChannel-members.html\", \"doc/cxxapi/classPassenger_1_1MessageChannel.html\", \"doc/cxxapi/classPassenger_1_1RuntimeException-members.html\", \"doc/cxxapi/classPassenger_1_1RuntimeException.html\", \"doc/cxxapi/classPassenger_1_1SpawnException-members.html\", \"doc/cxxapi/classPassenger_1_1SpawnException.html\", \"doc/cxxapi/classPassenger_1_1SpawnManager-members.html\", \"doc/cxxapi/classPassenger_1_1SpawnManager.html\", \"doc/cxxapi/cla"..., 4096) = 4096
read(3, "icationPool.html\", \"doc/cxxapi/classPassenger_1_1StandardApplicationPool__inherit__graph.map\", \"doc/cxxapi/classPassenger_1_1StandardApplicationPool__inherit__graph.md5\", \"doc/cxxapi/classPassenger_1_1StandardApplicationPool__inherit__graph.png\", \"doc/cxxapi/classPassenger_1_1SystemException-members.html\", \"doc/cxxapi/classPassenger_1_1SystemException.html\", \"doc/cxxapi/classPassenger_1_1SystemException__inherit__graph.map\", \"doc/cxxapi/classPassenger_1_1SystemException__inherit__graph.md5\", \"doc/cxxapi/classPassenger_1_1SystemException__inherit__graph.png\", \"doc/cxxapi/classPassenger_1_1SystemTime-members.html\", \"doc/cxxapi/classPassenger_1_1SystemTime.html\", \"doc/cxxapi/Configuration_8h-source.html\", \"doc/cxxapi/definitions_8h-source.html\", \"doc/cxxapi/DirectoryMapper_8h-source.html\", \"doc/cxxapi/doxygen.css\", \"doc/cxxapi/doxygen.png\", \"doc/cxxapi/DummySpawnManager_8h-source.html\", \"doc/cxxapi/Exceptions_8h-source.html\", \"doc/cxxapi/FileChecker_8h-source.html\", \"doc/cxxapi/files.html\", \"doc/cxxapi/ftv2blank.png\", \"doc/cxxapi/ftv2doc.png\", \"doc/cxxapi/ftv2folderclosed.png\", \"doc/cxxapi/ftv2folderopen.png\", \"doc/cxxapi/ftv2lastnode.png\", \"doc/cxxapi/ftv2link.png\", \"doc/cxxapi/ftv2mlastnode.png\", \"doc/cxxapi/ftv2mnode.png\", \"doc/cxxapi/ftv2node.png\", \"doc/cxxapi/ftv2plastnode.png\", \"doc/cxxapi/ftv2pnode.png\", \"doc/cxxapi/ftv2vertline.png\", \"doc/cxxapi/functions.html\", \"doc/cxxapi/functions_func.html\", \"doc/cxxapi/functions_type.html\", \"doc/cxxapi/functions_vars.html\", \"doc/cxxapi/graph_legend.dot\", \"doc/cxxapi/graph_legend.html\", \"doc/cxxapi/graph_legend.png\", \"doc/cxxapi/group__Configuration.html\", \"doc/cxxapi/group__Configuration.png\", \"doc/cxxapi/group__Core.html\", \"doc/cxxapi/group__Core.png\", \"doc/cxxapi/group__Exceptions.html\", \"doc/cxxapi/group__Hooks.html\", \"doc/cxxapi/group__Hooks.png\", \"doc/cxxapi/group__Support.html\", \"doc/cxxapi/hierarchy.html\", \"doc/cxxapi/Hooks_8h-source.html\", \"doc/cxxapi/index.html\", \"doc/cxxapi/inherit__graph__0.map\", \"doc/cxxapi/inherit__graph__0.md5\", \"doc/cxxapi/inherit__graph__0.png\", \"doc/cxxapi/inherit__graph__1.map\", \"doc/cxxapi/inherit__graph__1.md5\", \"doc/cxxapi/inherit__graph__1.png\", \"doc/cxxapi/inherit__graph__10.map\", \"doc/cxxapi/inherit__graph__10.md5\", \"doc/cxxapi/inherit__graph__10.png\", \"doc/cxxapi/inherit__graph__11.map\", \"doc/cxxapi/inherit__graph__11.md5\", \"doc/cxxapi/inherit__graph__11.png\", \"doc/cxxapi/inherit__graph__12.map\", \"doc/cxxapi/inherit__graph__12.md5\", \"doc/cxxapi/inherit__graph__12.png\", \"doc/cxxapi/inherit__graph__13.map\", \"doc/cxxapi/inherit__graph__13.md5\", \"doc/cxxapi/inherit__graph__13.png\", \"doc/cxxapi/inherit__graph__14.map\", \"doc/cxxapi/inherit__graph__14.md5\", \"doc/cxxapi/inherit__graph__14.png\", \"doc/cxxapi/inherit__graph__15.map\", \"doc/cxxapi/inherit__graph__15.md5\", \"doc/cxxapi/inherit__graph__15.png\", \"doc/cxxapi/inherit__graph__16.map\", \"doc/cxxapi/inherit__graph__16.md5\", \"doc/cxxapi/inherit__graph__16.png\", \"doc/cxxapi/inherit__graph__17.map\", \"doc/cxxapi/inherit__graph__17.md5\", \"doc/cxxapi/inherit__graph__17.png\", \"doc/cxxapi/inherit__graph__18.map\", \"doc/cxxapi/inherit__graph__18.md5\", \"doc/cxxapi/inherit__graph__18.png\", \"doc/cxxapi/inherit__graph__19.map\", \"doc/cxxapi/inherit__graph__19.md5\", \"doc/cxxapi/inherit__graph__19.png\", \"doc/cxxapi/inherit__graph__2.map\", \"doc/cxxapi/inherit__graph__2.md5\", \"doc/cxxapi/inherit__graph__2.png\", \"doc/cxxapi/inherit__graph__20.map\", \"doc/cxxapi/inherit__graph__20.md5\", \"doc/cxxapi/inherit__graph__20.png\", \"doc/cxxapi/inherit__graph__21.map\", \"doc/cxxapi/inherit__graph__21.md5\", \"doc/cxxapi/inherit__graph__21.png\", \"doc/cxxapi/inherit__graph__3.map\", \"doc/cxxapi/inherit__graph__3.md5\", \"doc/cxxapi/inherit__graph__3.png\", \"doc/cxxapi/inherit__graph__4.map\", \"doc/cxxapi/inherit__graph__4.md5\", \"doc/cxxapi/inherit__graph__4.png\", \"doc/cxxapi/inherit__graph__5.map\", \"doc/cxxapi/inherit__graph__5.md5\", \"doc/cxxapi/inherit__graph__5.png\", \"doc/cxxapi/inherit__graph__6.map\", \"doc/cxxapi/inherit__graph__6.md5\","..., 4096) = 4096
read(3, "aph__7.md5\", \"doc/cxxapi/inherit__graph__7.png\", \"doc/cxxapi/inherit__graph__8.map\", \"doc/cxxapi/inherit__graph__8.md5\", \"doc/cxxapi/inherit__graph__8.png\", \"doc/cxxapi/inherit__graph__9.map\", \"doc/cxxapi/inherit__graph__9.md5\", \"doc/cxxapi/inherit__graph__9.png\", \"doc/cxxapi/inherits.html\", \"doc/cxxapi/Logging_8h-source.html\", \"doc/cxxapi/main.html\", \"doc/cxxapi/MessageChannel_8h-source.html\", \"doc/cxxapi/modules.html\", \"doc/cxxapi/PoolOptions_8h-source.html\", \"doc/cxxapi/SpawnManager_8h-source.html\", \"doc/cxxapi/StandardApplicationPool_8h-source.html\", \"doc/cxxapi/structPassenger_1_1AnythingToString-members.html\", \"doc/cxxapi/structPassenger_1_1AnythingToString.html\", \"doc/cxxapi/structPassenger_1_1AnythingToString_3_01vector_3_01string_01_4_01_4-members.html\", \"doc/cxxapi/structPassenger_1_1AnythingToString_3_01vector_3_01string_01_4_01_4.html\", \"doc/cxxapi/structPassenger_1_1PoolOptions-members.html\", \"doc/cxxapi/structPassenger_1_1PoolOptions.html\", \"doc/cxxapi/SystemTime_8h-source.html\", \"doc/cxxapi/tab_b.gif\", \"doc/cxxapi/tab_l.gif\", \"doc/cxxapi/tab_r.gif\", \"doc/cxxapi/tabs.css\", \"doc/cxxapi/tree.html\", \"doc/cxxapi/Utils_8h-source.html\", \"doc/images/by_sa.png\", \"doc/images/conservative_spawning.png\", \"doc/images/conservative_spawning.svg\", \"doc/images/passenger_architecture.png\", \"doc/images/passenger_architecture.svg\", \"doc/images/phusion_banner.png\", \"doc/images/smart-lv2.png\", \"doc/images/smart-lv2.svg\", \"doc/images/spawn_server_architecture.png\", \"doc/images/spawn_server_architecture.svg\", \"doc/images/typical_isolated_web_application.png\", \"doc/images/typical_isolated_web_application.svg\", \"doc/rdoc/created.rid\", \"doc/rdoc/fr_class_index.html\", \"doc/rdoc/fr_file_index.html\", \"doc/rdoc/fr_method_index.html\", \"doc/rdoc/index.html\", \"doc/rdoc/rdoc-style.css\", \"doc/template/horo.rb\", \"doc/users_guide_snippets/analysis_and_system_maintenance_tools.txt\", \"doc/users_guide_snippets/appendix_a_about.txt\", \"doc/users_guide_snippets/appendix_b_terminology.txt\", \"doc/users_guide_snippets/appendix_c_spawning_methods.txt\", \"doc/users_guide_snippets/global_queueing_explained.txt\", \"doc/users_guide_snippets/rackup_specifications.txt\", \"doc/users_guide_snippets/rails_spawn_method.txt\", \"doc/users_guide_snippets/tips.txt\", \"doc/images/icons/caution.png\", \"doc/images/icons/example.png\", \"doc/images/icons/home.png\", \"doc/images/icons/important.png\", \"doc/images/icons/next.png\", \"doc/images/icons/note.png\", \"doc/images/icons/prev.png\", \"doc/images/icons/README\", \"doc/images/icons/tip.png\", \"doc/images/icons/up.png\", \"doc/images/icons/warning.png\", \"doc/rdoc/classes/ConditionVariable.html\", \"doc/rdoc/classes/Exception.html\", \"doc/rdoc/classes/GC.html\", \"doc/rdoc/classes/IO.html\", \"doc/rdoc/classes/PhusionPassenger.html\", \"doc/rdoc/classes/PlatformInfo.html\", \"doc/rdoc/classes/RakeExtensions.html\", \"doc/rdoc/classes/Signal.html\", \"doc/rdoc/files/DEVELOPERS_TXT.html\", \"doc/rdoc/files/README.html\", \"doc/images/icons/callouts/1.png\", \"doc/images/icons/callouts/10.png\", \"doc/images/icons/callouts/11.png\", \"doc/images/icons/callouts/12.png\", \"doc/images/icons/callouts/13.png\", \"doc/images/icons/callouts/14.png\", \"doc/images/icons/callouts/15.png\", \"doc/images/icons/callouts/2.png\", \"doc/images/icons/callouts/3.png\", \"doc/images/icons/callouts/4.png\", \"doc/images/icons/callouts/5.png\", \"doc/images/icons/callouts/6.png\", \"doc/images/icons/callouts/7.png\", \"doc/images/icons/callouts/8.png\", \"doc/images/icons/callouts/9.png\", \"doc/rdoc/classes/PhusionPassenger/AbstractInstaller.html\", \"doc/rdoc/classes/PhusionPassenger/AbstractRequestHandler.html\", \"doc/rdoc/classes/PhusionPassenger/AbstractServer.html\", \"doc/rdoc/classes/PhusionPassenger/AbstractServerCollection.html\", \"doc/rdoc/classes/PhusionPassenger/AdminTools.html\", \"doc/rdoc/classes/PhusionPassenger/AppInitError.html\", \"doc/rdoc/classes/PhusionPassenger/Application.html\", \"doc/rdoc/classes/PhusionPassenger/ConsoleTextTemplate.html\", \"doc/rdoc/classes/PhusionPassenger/FrameworkInitError.html"..., 4096) = 4096
read(3, "tializationError.html\", \"doc/rdoc/classes/PhusionPassenger/InvalidPath.html\", \"doc/rdoc/classes/PhusionPassenger/MessageChannel.html\", \"doc/rdoc/classes/PhusionPassenger/NativeSupport.html\", \"doc/rdoc/classes/PhusionPassenger/Rack.html\", \"doc/rdoc/classes/PhusionPassenger/Railz.html\", \"doc/rdoc/classes/PhusionPassenger/SpawnManager.html\", \"doc/rdoc/classes/PhusionPassenger/UnknownError.html\", \"doc/rdoc/classes/PhusionPassenger/Utils.html\", \"doc/rdoc/classes/PhusionPassenger/VersionNotFound.html\", \"doc/rdoc/classes/PhusionPassenger/WSGI.html\", \"doc/rdoc/classes/PhusionPassenger/AbstractServer/ServerAlreadyStarted.html\", \"doc/rdoc/classes/PhusionPassenger/AbstractServer/ServerError.html\", \"doc/rdoc/classes/PhusionPassenger/AbstractServer/ServerNotStarted.html\", \"doc/rdoc/classes/PhusionPassenger/AbstractServer/UnknownMessage.html\", \"doc/rdoc/classes/PhusionPassenger/AdminTools/ControlProcess.html\", \"doc/rdoc/classes/PhusionPassenger/Rack/ApplicationSpawner.html\", \"doc/rdoc/classes/PhusionPassenger/Rack/RequestHandler.html\", \"doc/rdoc/classes/PhusionPassenger/Railz/ApplicationSpawner.html\", \"doc/rdoc/classes/PhusionPassenger/Railz/CGIFixed.html\", \"doc/rdoc/classes/PhusionPassenger/Railz/FrameworkSpawner.html\", \"doc/rdoc/classes/PhusionPassenger/Railz/RequestHandler.html\", \"doc/rdoc/classes/PhusionPassenger/Utils/PseudoIO.html\", \"doc/rdoc/classes/PhusionPassenger/WSGI/ApplicationSpawner.html\", \"doc/rdoc/files/ext/phusion_passenger/native_support_c.html\", \"doc/rdoc/files/lib/phusion_passenger/abstract_installer_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/abstract_request_handler_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/abstract_server_collection_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/abstract_server_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/admin_tools_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/application_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/console_text_template_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/constants_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/dependencies_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/events_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/exceptions_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/html_template_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/message_channel_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/packaging_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/platform_info_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/simple_benchmarking_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/spawn_manager_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/utils_rb.html\", \"doc/rdoc/files/misc/rake/extensions_rb.html\", \"doc/rdoc/classes/PhusionPassenger/AdminTools/ControlProcess/Instance.html\", \"doc/rdoc/classes/PhusionPassenger/Railz/ApplicationSpawner/Error.html\", \"doc/rdoc/classes/PhusionPassenger/Railz/FrameworkSpawner/Error.html\", \"doc/rdoc/files/lib/phusion_passenger/admin_tools/control_process_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/rack/application_spawner_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/rack/request_handler_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/railz/application_spawner_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/railz/cgi_fixed_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/railz/framework_spawner_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/railz/request_handler_rb.html\", \"doc/rdoc/files/lib/phusion_passenger/wsgi/application_spawner_rb.html\", \"man/passenger-config.1\", \"man/passenger-make-enterprisey.8\", \"man/passenger-memory-stats.8\", \"man/passenger-status.8\", \"man/passenger-stress-test.1\", \"debian/compat\", \"debian/control\", \"debian/postinst\", \"debian/prerm\", \"ext/common/ApplicationPoolServerExecutable.cpp\", \"ext/common/Base64.cpp\", \"ext/common/CachedFileStat.cpp\", \"ext/common/Logging.cpp\", \"ext/common/SystemTime.cpp\", \"ext/common/Utils.cpp\", \"ext/common/Application.h\", \"ext/common/ApplicationPool.h\", \"ext/common/ApplicationPoolServer.h\", \"ext/common/ApplicationPoolStatusReporter.h\", \"e"..., 4096) = 4096
read(3, "n/Exceptions.h\", \"ext/common/FileChangeChecker.h\", \"ext/common/Logging.h\", \"ext/common/MessageChannel.h\", \"ext/common/PoolOptions.h\", \"ext/common/SpawnManager.h\", \"ext/common/StandardApplicationPool.h\", \"ext/common/StaticString.h\", \"ext/common/StringListCreator.h\", \"ext/common/SystemTime.h\", \"ext/common/Timer.h\", \"ext/common/Utils.h\", \"ext/common/Version.h\", \"ext/common/CachedFileStat.hpp\", \"ext/apache2/Bucket.cpp\", \"ext/apache2/Configuration.cpp\", \"ext/apache2/Hooks.cpp\", \"ext/apache2/Bucket.h\", \"ext/apache2/Configuration.h\", \"ext/apache2/DirectoryMapper.h\", \"ext/apache2/Hooks.h\", \"ext/apache2/mod_passenger.c\", \"ext/apache2/LICENSE-CNRI.TXT\", \"ext/nginx/Configuration.c\", \"ext/nginx/ContentHandler.c\", \"ext/nginx/ngx_http_passenger_module.c\", \"ext/nginx/StaticContentHandler.c\", \"ext/nginx/HelperServer.cpp\", \"ext/nginx/Configuration.h\", \"ext/nginx/ContentHandler.h\", \"ext/nginx/HttpStatusExtractor.h\", \"ext/nginx/ngx_http_passenger_module.h\", \"ext/nginx/ScgiRequestParser.h\", \"ext/nginx/StaticContentHandler.h\", \"ext/nginx/config\", \"ext/boost/assert.hpp\", \"ext/boost/bind.hpp\", \"ext/boost/call_traits.hpp\", \"ext/boost/checked_delete.hpp\", \"ext/boost/concept_check.hpp\", \"ext/boost/config.hpp\", \"ext/boost/cstdint.hpp\", \"ext/boost/current_function.hpp\", \"ext/boost/enable_shared_from_this.hpp\", \"ext/boost/function.hpp\", \"ext/boost/function_equal.hpp\", \"ext/boost/get_pointer.hpp\", \"ext/boost/implicit_cast.hpp\", \"ext/boost/integer_traits.hpp\", \"ext/boost/io_fwd.hpp\", \"ext/boost/is_placeholder.hpp\", \"ext/boost/iterator.hpp\", \"ext/boost/lexical_cast.hpp\", \"ext/boost/limits.hpp\", \"ext/boost/mem_fn.hpp\", \"ext/boost/next_prior.hpp\", \"ext/boost/non_type.hpp\", \"ext/boost/noncopyable.hpp\", \"ext/boost/none.hpp\", \"ext/boost/none_t.hpp\", \"ext/boost/operators.hpp\", \"ext/boost/optional.hpp\", \"ext/boost/ref.hpp\", \"ext/boost/shared_ptr.hpp\", \"ext/boost/static_assert.hpp\", \"ext/boost/thread.hpp\", \"ext/boost/throw_exception.hpp\", \"ext/boost/token_functions.hpp\", \"ext/boost/token_iterator.hpp\", \"ext/boost/tokenizer.hpp\", \"ext/boost/type.hpp\", \"ext/boost/utility.hpp\", \"ext/boost/visit_each.hpp\", \"ext/boost/weak_ptr.hpp\", \"ext/boost/LICENSE.TXT\", \"ext/boost/VERSION.TXT\", \"ext/boost/algorithm/string/case_conv.hpp\", \"ext/boost/algorithm/string/compare.hpp\", \"ext/boost/algorithm/string/concept.hpp\", \"ext/boost/algorithm/string/config.hpp\", \"ext/boost/algorithm/string/constants.hpp\", \"ext/boost/algorithm/string/detail/case_conv.hpp\", \"ext/boost/algorithm/string/detail/find_format.hpp\", \"ext/boost/algorithm/string/detail/find_format_all.hpp\", \"ext/boost/algorithm/string/detail/find_format_store.hpp\", \"ext/boost/algorithm/string/detail/finder.hpp\", \"ext/boost/algorithm/string/detail/formatter.hpp\", \"ext/boost/algorithm/string/detail/replace_storage.hpp\", \"ext/boost/algorithm/string/detail/sequence.hpp\", \"ext/boost/algorithm/string/detail/util.hpp\", \"ext/boost/algorithm/string/erase.hpp\", \"ext/boost/algorithm/string/find_format.hpp\", \"ext/boost/algorithm/string/finder.hpp\", \"ext/boost/algorithm/string/formatter.hpp\", \"ext/boost/algorithm/string/replace.hpp\", \"ext/boost/algorithm/string/sequence_traits.hpp\", \"ext/boost/algorithm/string/yes_no_type.hpp\", \"ext/boost/bind/arg.hpp\", \"ext/boost/bind/bind_cc.hpp\", \"ext/boost/bind/bind_mf_cc.hpp\", \"ext/boost/bind/bind_template.hpp\", \"ext/boost/bind/mem_fn_cc.hpp\", \"ext/boost/bind/mem_fn_template.hpp\", \"ext/boost/bind/placeholders.hpp\", \"ext/boost/bind/storage.hpp\", \"ext/boost/concept/assert.hpp\", \"ext/boost/concept/detail/concept_def.hpp\", \"ext/boost/concept/detail/concept_undef.hpp\", \"ext/boost/concept/detail/general.hpp\", \"ext/boost/concept/detail/has_constraints.hpp\", \"ext/boost/concept/usage.hpp\", \"ext/boost/config/abi/borland_prefix.hpp\", \"ext/boost/config/abi/borland_suffix.hpp\", \"ext/boost/config/abi/msvc_prefix.hpp\", \"ext/boost/config/abi/msvc_suffix.hpp\", \"ext/boost/config/abi_prefix.hpp\", \"ext/boost/config/abi_suffix.hpp\", \"ext/boost/config/auto_link.hpp\", \"ext/boost/config/compiler/borland.hpp\", \"ext/boost/config/"..., 4096) = 4096
read(3, "paq_cxx.hpp\", \"ext/boost/config/compiler/digitalmars.hpp\", \"ext/boost/config/compiler/gcc.hpp\", \"ext/boost/config/compiler/gcc_xml.hpp\", \"ext/boost/config/compiler/greenhills.hpp\", \"ext/boost/config/compiler/hp_acc.hpp\", \"ext/boost/config/compiler/intel.hpp\", \"ext/boost/config/compiler/kai.hpp\", \"ext/boost/config/compiler/metrowerks.hpp\", \"ext/boost/config/compiler/mpw.hpp\", \"ext/boost/config/compiler/pgi.hpp\", \"ext/boost/config/compiler/sgi_mipspro.hpp\", \"ext/boost/config/compiler/sunpro_cc.hpp\", \"ext/boost/config/compiler/vacpp.hpp\", \"ext/boost/config/compiler/visualc.hpp\", \"ext/boost/config/no_tr1/complex.hpp\", \"ext/boost/config/no_tr1/functional.hpp\", \"ext/boost/config/no_tr1/memory.hpp\", \"ext/boost/config/no_tr1/utility.hpp\", \"ext/boost/config/platform/aix.hpp\", \"ext/boost/config/platform/amigaos.hpp\", \"ext/boost/config/platform/beos.hpp\", \"ext/boost/config/platform/bsd.hpp\", \"ext/boost/config/platform/cygwin.hpp\", \"ext/boost/config/platform/hpux.hpp\", \"ext/boost/config/platform/irix.hpp\", \"ext/boost/config/platform/linux.hpp\", \"ext/boost/config/platform/macos.hpp\", \"ext/boost/config/platform/qnxnto.hpp\", \"ext/boost/config/platform/solaris.hpp\", \"ext/boost/config/platform/win32.hpp\", \"ext/boost/config/posix_features.hpp\", \"ext/boost/config/requires_threads.hpp\", \"ext/boost/config/select_compiler_config.hpp\", \"ext/boost/config/select_platform_config.hpp\", \"ext/boost/config/select_stdlib_config.hpp\", \"ext/boost/config/stdlib/dinkumware.hpp\", \"ext/boost/config/stdlib/libcomo.hpp\", \"ext/boost/config/stdlib/libstdcpp3.hpp\", \"ext/boost/config/stdlib/modena.hpp\", \"ext/boost/config/stdlib/msl.hpp\", \"ext/boost/config/stdlib/roguewave.hpp\", \"ext/boost/config/stdlib/sgi.hpp\", \"ext/boost/config/stdlib/stlport.hpp\", \"ext/boost/config/stdlib/vacpp.hpp\", \"ext/boost/config/suffix.hpp\", \"ext/boost/config/user.hpp\", \"ext/boost/date_time/adjust_functors.hpp\", \"ext/boost/date_time/c_time.hpp\", \"ext/boost/date_time/compiler_config.hpp\", \"ext/boost/date_time/constrained_value.hpp\", \"ext/boost/date_time/date.hpp\", \"ext/boost/date_time/date_clock_device.hpp\", \"ext/boost/date_time/date_defs.hpp\", \"ext/boost/date_time/date_duration.hpp\", \"ext/boost/date_time/date_duration_types.hpp\", \"ext/boost/date_time/date_facet.hpp\", \"ext/boost/date_time/date_format_simple.hpp\", \"ext/boost/date_time/date_formatting.hpp\", \"ext/boost/date_time/date_formatting_limited.hpp\", \"ext/boost/date_time/date_formatting_locales.hpp\", \"ext/boost/date_time/date_generator_formatter.hpp\", \"ext/boost/date_time/date_generator_parser.hpp\", \"ext/boost/date_time/date_generators.hpp\", \"ext/boost/date_time/date_iterator.hpp\", \"ext/boost/date_time/date_names_put.hpp\", \"ext/boost/date_time/date_parsing.hpp\", \"ext/boost/date_time/dst_rules.hpp\", \"ext/boost/date_time/filetime_functions.hpp\", \"ext/boost/date_time/format_date_parser.hpp\", \"ext/boost/date_time/gregorian/conversion.hpp\", \"ext/boost/date_time/gregorian/formatters.hpp\", \"ext/boost/date_time/gregorian/formatters_limited.hpp\", \"ext/boost/date_time/gregorian/greg_calendar.hpp\", \"ext/boost/date_time/gregorian/greg_date.hpp\", \"ext/boost/date_time/gregorian/greg_day.hpp\", \"ext/boost/date_time/gregorian/greg_day_of_year.hpp\", \"ext/boost/date_time/gregorian/greg_duration.hpp\", \"ext/boost/date_time/gregorian/greg_duration_types.hpp\", \"ext/boost/date_time/gregorian/greg_month.hpp\", \"ext/boost/date_time/gregorian/greg_weekday.hpp\", \"ext/boost/date_time/gregorian/greg_year.hpp\", \"ext/boost/date_time/gregorian/greg_ymd.hpp\", \"ext/boost/date_time/gregorian/gregorian.hpp\", \"ext/boost/date_time/gregorian/gregorian_io.hpp\", \"ext/boost/date_time/gregorian/gregorian_types.hpp\", \"ext/boost/date_time/gregorian/parsers.hpp\", \"ext/boost/date_time/gregorian_calendar.hpp\", \"ext/boost/date_time/int_adapter.hpp\", \"ext/boost/date_time/iso_format.hpp\", \"ext/boost/date_time/locale_config.hpp\", \"ext/boost/date_time/microsec_time_clock.hpp\", \"ext/boost/date_time/parse_format_base.hpp\", \"ext/boost/date_time/period.hpp\", \"ext/boost/date_time/period_formatter.h"..., 4096) = 4096
read(3, "ext/boost/date_time/posix_time/date_duration_operators.hpp\", \"ext/boost/date_time/posix_time/posix_time.hpp\", \"ext/boost/date_time/posix_time/posix_time_config.hpp\", \"ext/boost/date_time/posix_time/posix_time_duration.hpp\", \"ext/boost/date_time/posix_time/posix_time_io.hpp\", \"ext/boost/date_time/posix_time/posix_time_system.hpp\", \"ext/boost/date_time/posix_time/posix_time_types.hpp\", \"ext/boost/date_time/posix_time/ptime.hpp\", \"ext/boost/date_time/posix_time/time_formatters.hpp\", \"ext/boost/date_time/posix_time/time_parsers.hpp\", \"ext/boost/date_time/posix_time/time_period.hpp\", \"ext/boost/date_time/special_defs.hpp\", \"ext/boost/date_time/special_values_formatter.hpp\", \"ext/boost/date_time/special_values_parser.hpp\", \"ext/boost/date_time/string_convert.hpp\", \"ext/boost/date_time/string_parse_tree.hpp\", \"ext/boost/date_time/strings_from_facet.hpp\", \"ext/boost/date_time/time.hpp\", \"ext/boost/date_time/time_clock.hpp\", \"ext/boost/date_time/time_defs.hpp\", \"ext/boost/date_time/time_duration.hpp\", \"ext/boost/date_time/time_facet.hpp\", \"ext/boost/date_time/time_formatting_streams.hpp\", \"ext/boost/date_time/time_iterator.hpp\", \"ext/boost/date_time/time_parsing.hpp\", \"ext/boost/date_time/time_resolution_traits.hpp\", \"ext/boost/date_time/time_system_counted.hpp\", \"ext/boost/date_time/time_system_split.hpp\", \"ext/boost/date_time/wrapping_int.hpp\", \"ext/boost/date_time/year_month_day.hpp\", \"ext/boost/detail/atomic_count.hpp\", \"ext/boost/detail/atomic_count_gcc.hpp\", \"ext/boost/detail/atomic_count_gcc_x86.hpp\", \"ext/boost/detail/atomic_count_pthreads.hpp\", \"ext/boost/detail/atomic_count_solaris.hpp\", \"ext/boost/detail/atomic_count_sync.hpp\", \"ext/boost/detail/atomic_count_win32.hpp\", \"ext/boost/detail/bad_weak_ptr.hpp\", \"ext/boost/detail/call_traits.hpp\", \"ext/boost/detail/endian.hpp\", \"ext/boost/detail/indirect_traits.hpp\", \"ext/boost/detail/iterator.hpp\", \"ext/boost/detail/lcast_precision.hpp\", \"ext/boost/detail/limits.hpp\", \"ext/boost/detail/reference_content.hpp\", \"ext/boost/detail/shared_count.hpp\", \"ext/boost/detail/sp_counted_base.hpp\", \"ext/boost/detail/sp_counted_base_acc_ia64.hpp\", \"ext/boost/detail/sp_counted_base_cw_ppc.hpp\", \"ext/boost/detail/sp_counted_base_cw_x86.hpp\", \"ext/boost/detail/sp_counted_base_gcc_ia64.hpp\", \"ext/boost/detail/sp_counted_base_gcc_ppc.hpp\", \"ext/boost/detail/sp_counted_base_gcc_sparc.hpp\", \"ext/boost/detail/sp_counted_base_gcc_x86.hpp\", \"ext/boost/detail/sp_counted_base_nt.hpp\", \"ext/boost/detail/sp_counted_base_pt.hpp\", \"ext/boost/detail/sp_counted_base_solaris.hpp\", \"ext/boost/detail/sp_counted_base_sync.hpp\", \"ext/boost/detail/sp_counted_base_w32.hpp\", \"ext/boost/detail/sp_counted_impl.hpp\", \"ext/boost/detail/sp_typeinfo.hpp\", \"ext/boost/detail/workaround.hpp\", \"ext/boost/function/detail/function_iterate.hpp\", \"ext/boost/function/detail/maybe_include.hpp\", \"ext/boost/function/detail/prologue.hpp\", \"ext/boost/function/function_base.hpp\", \"ext/boost/function/function_template.hpp\", \"ext/boost/io/ios_state.hpp\", \"ext/boost/iterator/detail/config_def.hpp\", \"ext/boost/iterator/detail/config_undef.hpp\", \"ext/boost/iterator/detail/enable_if.hpp\", \"ext/boost/iterator/detail/facade_iterator_category.hpp\", \"ext/boost/iterator/detail/minimum_category.hpp\", \"ext/boost/iterator/interoperable.hpp\", \"ext/boost/iterator/iterator_adaptor.hpp\", \"ext/boost/iterator/iterator_categories.hpp\", \"ext/boost/iterator/iterator_facade.hpp\", \"ext/boost/iterator/iterator_traits.hpp\", \"ext/boost/iterator/reverse_iterator.hpp\", \"ext/boost/iterator/transform_iterator.hpp\", \"ext/boost/mpl/always.hpp\", \"ext/boost/mpl/and.hpp\", \"ext/boost/mpl/apply.hpp\", \"ext/boost/mpl/apply_fwd.hpp\", \"ext/boost/mpl/apply_wrap.hpp\", \"ext/boost/mpl/arg.hpp\", \"ext/boost/mpl/arg_fwd.hpp\", \"ext/boost/mpl/assert.hpp\", \"ext/boost/mpl/aux_/adl_barrier.hpp\", \"ext/boost/mpl/aux_/arg_typedef.hpp\", \"ext/boost/mpl/aux_/arity.hpp\", \"ext/boost/mpl/aux_/arity_spec.hpp\", \"ext/boost/mpl/aux_/common_name_wknd.hpp\", \"ext/boost/mpl/aux_/config/adl.hpp\", \"ext/boost/mpl/"..., 4096) = 4096
read(3, "er.hpp\", \"ext/boost/mpl/aux_/config/ctps.hpp\", \"ext/boost/mpl/aux_/config/dtp.hpp\", \"ext/boost/mpl/aux_/config/eti.hpp\", \"ext/boost/mpl/aux_/config/gcc.hpp\", \"ext/boost/mpl/aux_/config/has_apply.hpp\", \"ext/boost/mpl/aux_/config/has_xxx.hpp\", \"ext/boost/mpl/aux_/config/integral.hpp\", \"ext/boost/mpl/aux_/config/intel.hpp\", \"ext/boost/mpl/aux_/config/lambda.hpp\", \"ext/boost/mpl/aux_/config/msvc.hpp\", \"ext/boost/mpl/aux_/config/msvc_typename.hpp\", \"ext/boost/mpl/aux_/config/nttp.hpp\", \"ext/boost/mpl/aux_/config/overload_resolution.hpp\", \"ext/boost/mpl/aux_/config/pp_counter.hpp\", \"ext/boost/mpl/aux_/config/preprocessor.hpp\", \"ext/boost/mpl/aux_/config/static_constant.hpp\", \"ext/boost/mpl/aux_/config/ttp.hpp\", \"ext/boost/mpl/aux_/config/use_preprocessed.hpp\", \"ext/boost/mpl/aux_/config/workaround.hpp\", \"ext/boost/mpl/aux_/full_lambda.hpp\", \"ext/boost/mpl/aux_/has_apply.hpp\", \"ext/boost/mpl/aux_/has_type.hpp\", \"ext/boost/mpl/aux_/include_preprocessed.hpp\", \"ext/boost/mpl/aux_/integral_wrapper.hpp\", \"ext/boost/mpl/aux_/lambda_arity_param.hpp\", \"ext/boost/mpl/aux_/lambda_support.hpp\", \"ext/boost/mpl/aux_/msvc_never_true.hpp\", \"ext/boost/mpl/aux_/na.hpp\", \"ext/boost/mpl/aux_/na_assert.hpp\", \"ext/boost/mpl/aux_/na_fwd.hpp\", \"ext/boost/mpl/aux_/na_spec.hpp\", \"ext/boost/mpl/aux_/nested_type_wknd.hpp\", \"ext/boost/mpl/aux_/nttp_decl.hpp\", \"ext/boost/mpl/aux_/preprocessed/gcc/and.hpp\", \"ext/boost/mpl/aux_/preprocessed/gcc/apply.hpp\", \"ext/boost/mpl/aux_/preprocessed/gcc/apply_fwd.hpp\", \"ext/boost/mpl/aux_/preprocessed/gcc/apply_wrap.hpp\", \"ext/boost/mpl/aux_/preprocessed/gcc/arg.hpp\", \"ext/boost/mpl/aux_/preprocessed/gcc/bind.hpp\", \"ext/boost/mpl/aux_/preprocessed/gcc/bind_fwd.hpp\", \"ext/boost/mpl/aux_/preprocessed/gcc/full_lambda.hpp\", \"ext/boost/mpl/aux_/preprocessed/gcc/or.hpp\", \"ext/boost/mpl/aux_/preprocessed/gcc/placeholders.hpp\", \"ext/boost/mpl/aux_/preprocessed/gcc/quote.hpp\", \"ext/boost/mpl/aux_/preprocessed/gcc/template_arity.hpp\", \"ext/boost/mpl/aux_/preprocessor/def_params_tail.hpp\", \"ext/boost/mpl/aux_/preprocessor/enum.hpp\", \"ext/boost/mpl/aux_/preprocessor/filter_params.hpp\", \"ext/boost/mpl/aux_/preprocessor/params.hpp\", \"ext/boost/mpl/aux_/preprocessor/sub.hpp\", \"ext/boost/mpl/aux_/static_cast.hpp\", \"ext/boost/mpl/aux_/template_arity.hpp\", \"ext/boost/mpl/aux_/template_arity_fwd.hpp\", \"ext/boost/mpl/aux_/type_wrapper.hpp\", \"ext/boost/mpl/aux_/value_wknd.hpp\", \"ext/boost/mpl/aux_/yes_no.hpp\", \"ext/boost/mpl/bind.hpp\", \"ext/boost/mpl/bind_fwd.hpp\", \"ext/boost/mpl/bool.hpp\", \"ext/boost/mpl/bool_fwd.hpp\", \"ext/boost/mpl/eval_if.hpp\", \"ext/boost/mpl/has_xxx.hpp\", \"ext/boost/mpl/identity.hpp\", \"ext/boost/mpl/if.hpp\", \"ext/boost/mpl/int.hpp\", \"ext/boost/mpl/int_fwd.hpp\", \"ext/boost/mpl/integral_c.hpp\", \"ext/boost/mpl/integral_c_fwd.hpp\", \"ext/boost/mpl/integral_c_tag.hpp\", \"ext/boost/mpl/lambda.hpp\", \"ext/boost/mpl/lambda_fwd.hpp\", \"ext/boost/mpl/limits/arity.hpp\", \"ext/boost/mpl/logical.hpp\", \"ext/boost/mpl/next.hpp\", \"ext/boost/mpl/next_prior.hpp\", \"ext/boost/mpl/not.hpp\", \"ext/boost/mpl/or.hpp\", \"ext/boost/mpl/placeholders.hpp\", \"ext/boost/mpl/protect.hpp\", \"ext/boost/mpl/quote.hpp\", \"ext/boost/mpl/size_t.hpp\", \"ext/boost/mpl/size_t_fwd.hpp\", \"ext/boost/mpl/void.hpp\", \"ext/boost/mpl/void_fwd.hpp\", \"ext/boost/optional/optional.hpp\", \"ext/boost/optional/optional_fwd.hpp\", \"ext/boost/preprocessor/arithmetic/add.hpp\", \"ext/boost/preprocessor/arithmetic/dec.hpp\", \"ext/boost/preprocessor/arithmetic/inc.hpp\", \"ext/boost/preprocessor/arithmetic/sub.hpp\", \"ext/boost/preprocessor/array/data.hpp\", \"ext/boost/preprocessor/array/elem.hpp\", \"ext/boost/preprocessor/array/size.hpp\", \"ext/boost/preprocessor/cat.hpp\", \"ext/boost/preprocessor/comma_if.hpp\", \"ext/boost/preprocessor/config/config.hpp\", \"ext/boost/preprocessor/control/detail/while.hpp\", \"ext/boost/preprocessor/control/expr_iif.hpp\", \"ext/boost/preprocessor/control/if.hpp\", \"ext/boost/preprocessor/control/iif.hpp\", \"ext/boost/preprocessor/control/while.hpp\", \"ext/boost/preprocessor/debu"..., 4096) = 4096
read(3, ".hpp\", \"ext/boost/preprocessor/detail/is_binary.hpp\", \"ext/boost/preprocessor/empty.hpp\", \"ext/boost/preprocessor/enum.hpp\", \"ext/boost/preprocessor/enum_params.hpp\", \"ext/boost/preprocessor/facilities/empty.hpp\", \"ext/boost/preprocessor/facilities/identity.hpp\", \"ext/boost/preprocessor/identity.hpp\", \"ext/boost/preprocessor/inc.hpp\", \"ext/boost/preprocessor/iterate.hpp\", \"ext/boost/preprocessor/iteration/detail/bounds/lower1.hpp\", \"ext/boost/preprocessor/iteration/detail/bounds/upper1.hpp\", \"ext/boost/preprocessor/iteration/detail/iter/forward1.hpp\", \"ext/boost/preprocessor/iteration/iterate.hpp\", \"ext/boost/preprocessor/list/adt.hpp\", \"ext/boost/preprocessor/list/append.hpp\", \"ext/boost/preprocessor/list/detail/fold_left.hpp\", \"ext/boost/preprocessor/list/detail/fold_right.hpp\", \"ext/boost/preprocessor/list/fold_left.hpp\", \"ext/boost/preprocessor/list/fold_right.hpp\", \"ext/boost/preprocessor/list/for_each_i.hpp\", \"ext/boost/preprocessor/list/reverse.hpp\", \"ext/boost/preprocessor/list/transform.hpp\", \"ext/boost/preprocessor/logical/and.hpp\", \"ext/boost/preprocessor/logical/bitand.hpp\", \"ext/boost/preprocessor/logical/bool.hpp\", \"ext/boost/preprocessor/logical/compl.hpp\", \"ext/boost/preprocessor/punctuation/comma.hpp\", \"ext/boost/preprocessor/punctuation/comma_if.hpp\", \"ext/boost/preprocessor/repeat.hpp\", \"ext/boost/preprocessor/repetition/detail/for.hpp\", \"ext/boost/preprocessor/repetition/enum.hpp\", \"ext/boost/preprocessor/repetition/enum_binary_params.hpp\", \"ext/boost/preprocessor/repetition/enum_params.hpp\", \"ext/boost/preprocessor/repetition/for.hpp\", \"ext/boost/preprocessor/repetition/repeat.hpp\", \"ext/boost/preprocessor/repetition/repeat_from_to.hpp\", \"ext/boost/preprocessor/seq/elem.hpp\", \"ext/boost/preprocessor/seq/enum.hpp\", \"ext/boost/preprocessor/seq/for_each_i.hpp\", \"ext/boost/preprocessor/seq/seq.hpp\", \"ext/boost/preprocessor/seq/size.hpp\", \"ext/boost/preprocessor/slot/detail/def.hpp\", \"ext/boost/preprocessor/slot/detail/shared.hpp\", \"ext/boost/preprocessor/slot/slot.hpp\", \"ext/boost/preprocessor/stringize.hpp\", \"ext/boost/preprocessor/tuple/eat.hpp\", \"ext/boost/preprocessor/tuple/elem.hpp\", \"ext/boost/preprocessor/tuple/rem.hpp\", \"ext/boost/preprocessor/tuple/to_list.hpp\", \"ext/boost/range/as_literal.hpp\", \"ext/boost/range/begin.hpp\", \"ext/boost/range/config.hpp\", \"ext/boost/range/const_iterator.hpp\", \"ext/boost/range/detail/common.hpp\", \"ext/boost/range/detail/implementation_help.hpp\", \"ext/boost/range/detail/sfinae.hpp\", \"ext/boost/range/detail/str_types.hpp\", \"ext/boost/range/difference_type.hpp\", \"ext/boost/range/distance.hpp\", \"ext/boost/range/empty.hpp\", \"ext/boost/range/end.hpp\", \"ext/boost/range/functions.hpp\", \"ext/boost/range/iterator.hpp\", \"ext/boost/range/iterator_range.hpp\", \"ext/boost/range/mutable_iterator.hpp\", \"ext/boost/range/rbegin.hpp\", \"ext/boost/range/rend.hpp\", \"ext/boost/range/reverse_iterator.hpp\", \"ext/boost/range/size.hpp\", \"ext/boost/range/size_type.hpp\", \"ext/boost/range/value_type.hpp\", \"ext/boost/thread/condition.hpp\", \"ext/boost/thread/condition_variable.hpp\", \"ext/boost/thread/detail/config.hpp\", \"ext/boost/thread/detail/move.hpp\", \"ext/boost/thread/detail/platform.hpp\", \"ext/boost/thread/exceptions.hpp\", \"ext/boost/thread/locks.hpp\", \"ext/boost/thread/mutex.hpp\", \"ext/boost/thread/once.hpp\", \"ext/boost/thread/pthread/condition_variable.hpp\", \"ext/boost/thread/pthread/condition_variable_fwd.hpp\", \"ext/boost/thread/pthread/mutex.hpp\", \"ext/boost/thread/pthread/once.hpp\", \"ext/boost/thread/pthread/pthread_mutex_scoped_lock.hpp\", \"ext/boost/thread/pthread/recursive_mutex.hpp\", \"ext/boost/thread/pthread/thread.hpp\", \"ext/boost/thread/pthread/thread_data.hpp\", \"ext/boost/thread/pthread/timespec.hpp\", \"ext/boost/thread/pthread/tss.hpp\", \"ext/boost/thread/recursive_mutex.hpp\", \"ext/boost/thread/thread.hpp\", \"ext/boost/thread/thread_time.hpp\", \"ext/boost/thread/tss.hpp\", \"ext/boost/thread/xtime.hpp\", \"ext/boost/type_traits/add_const.hpp\", \"ext/boost/type_traits/add_pointer.hpp\", \"ext/boo"..., 4096) = 4096
read(3, "its/broken_compiler_spec.hpp\", \"ext/boost/type_traits/composite_traits.hpp\", \"ext/boost/type_traits/config.hpp\", \"ext/boost/type_traits/conversion_traits.hpp\", \"ext/boost/type_traits/detail/bool_trait_def.hpp\", \"ext/boost/type_traits/detail/bool_trait_undef.hpp\", \"ext/boost/type_traits/detail/cv_traits_impl.hpp\", \"ext/boost/type_traits/detail/false_result.hpp\", \"ext/boost/type_traits/detail/ice_and.hpp\", \"ext/boost/type_traits/detail/ice_eq.hpp\", \"ext/boost/type_traits/detail/ice_not.hpp\", \"ext/boost/type_traits/detail/ice_or.hpp\", \"ext/boost/type_traits/detail/is_function_ptr_helper.hpp\", \"ext/boost/type_traits/detail/is_mem_fun_pointer_impl.hpp\", \"ext/boost/type_traits/detail/size_t_trait_def.hpp\", \"ext/boost/type_traits/detail/size_t_trait_undef.hpp\", \"ext/boost/type_traits/detail/template_arity_spec.hpp\", \"ext/boost/type_traits/detail/type_trait_def.hpp\", \"ext/boost/type_traits/detail/type_trait_undef.hpp\", \"ext/boost/type_traits/detail/yes_no_type.hpp\", \"ext/boost/type_traits/function_traits.hpp\", \"ext/boost/type_traits/has_nothrow_copy.hpp\", \"ext/boost/type_traits/has_trivial_copy.hpp\", \"ext/boost/type_traits/ice.hpp\", \"ext/boost/type_traits/integral_constant.hpp\", \"ext/boost/type_traits/intrinsics.hpp\", \"ext/boost/type_traits/is_abstract.hpp\", \"ext/boost/type_traits/is_arithmetic.hpp\", \"ext/boost/type_traits/is_array.hpp\", \"ext/boost/type_traits/is_class.hpp\", \"ext/boost/type_traits/is_const.hpp\", \"ext/boost/type_traits/is_convertible.hpp\", \"ext/boost/type_traits/is_enum.hpp\", \"ext/boost/type_traits/is_float.hpp\", \"ext/boost/type_traits/is_function.hpp\", \"ext/boost/type_traits/is_integral.hpp\", \"ext/boost/type_traits/is_member_function_pointer.hpp\", \"ext/boost/type_traits/is_member_pointer.hpp\", \"ext/boost/type_traits/is_pod.hpp\", \"ext/boost/type_traits/is_pointer.hpp\", \"ext/boost/type_traits/is_reference.hpp\", \"ext/boost/type_traits/is_same.hpp\", \"ext/boost/type_traits/is_scalar.hpp\", \"ext/boost/type_traits/is_union.hpp\", \"ext/boost/type_traits/is_void.hpp\", \"ext/boost/type_traits/is_volatile.hpp\", \"ext/boost/type_traits/remove_const.hpp\", \"ext/boost/type_traits/remove_cv.hpp\", \"ext/boost/type_traits/remove_pointer.hpp\", \"ext/boost/type_traits/remove_reference.hpp\", \"ext/boost/type_traits/type_with_alignment.hpp\", \"ext/boost/utility/addressof.hpp\", \"ext/boost/utility/base_from_member.hpp\", \"ext/boost/utility/compare_pointees.hpp\", \"ext/boost/utility/enable_if.hpp\", \"ext/boost/src/pthread/exceptions.cpp\", \"ext/boost/src/pthread/once.cpp\", \"ext/boost/src/pthread/thread.cpp\", \"ext/boost/src/tss_null.cpp\", \"ext/boost/src/win32/exceptions.cpp\", \"ext/boost/src/win32/thread.cpp\", \"ext/boost/src/win32/tss_dll.cpp\", \"ext/boost/src/win32/tss_pe.cpp\", \"ext/boost/src/pthread/timeconv.inl\", \"ext/boost/src/win32/timeconv.inl\", \"ext/boost/date_time/gregorian_calendar.ipp\", \"ext/oxt/backtrace.hpp\", \"ext/oxt/macros.hpp\", \"ext/oxt/spin_lock.hpp\", \"ext/oxt/system_calls.hpp\", \"ext/oxt/thread.hpp\", \"ext/oxt/tracable_exception.hpp\", \"ext/oxt/backtrace.cpp\", \"ext/oxt/system_calls.cpp\", \"ext/oxt/thread.cpp\", \"ext/oxt/tracable_exception.cpp\", \"ext/oxt/detail/backtrace_disabled.hpp\", \"ext/oxt/detail/backtrace_enabled.hpp\", \"ext/oxt/detail/spin_lock_gcc_x86.hpp\", \"ext/oxt/detail/spin_lock_portable.hpp\", \"ext/oxt/detail/spin_lock_pthreads.hpp\", \"ext/oxt/detail/tracable_exception_disabled.hpp\", \"ext/oxt/detail/tracable_exception_enabled.hpp\", \"ext/phusion_passenger/native_support.c\", \"ext/phusion_passenger/extconf.rb\", \"benchmark/ApplicationPool.cpp\", \"benchmark/accept_vs_socketpair_vs_named_pipes.rb\", \"benchmark/dispatcher.rb\", \"benchmark/overhead_of_password_checking.rb\", \"benchmark/socket_connections_vs_persistent_pipe.rb\", \"benchmark/unix_sockets_vs_pipes.rb\", \"misc/copy_boost_headers.rb\", \"misc/find_owner_pipe_leaks.rb\", \"misc/render_error_pages.rb\", \"misc/rake/cplusplus.rb\", \"misc/rake/extensions.rb\", \"misc/rake/gempackagetask.rb\", \"misc/rake/packagetask.rb\", \"misc/rake/rdoctask.rb\", \"test/ApplicationPoolServer_ApplicationPoolTest.cpp\", \"tes"..., 4096) = 4096
read(3, "achedFileStatTest.cpp\", \"test/CxxTestMain.cpp\", \"test/FileChangeCheckerTest.cpp\", \"test/HttpStatusExtractorTest.cpp\", \"test/MessageChannelTest.cpp\", \"test/PoolOptionsTest.cpp\", \"test/ScgiRequestParserTest.cpp\", \"test/SpawnManagerTest.cpp\", \"test/StandardApplicationPoolTest.cpp\", \"test/StaticStringTest.cpp\", \"test/SystemTimeTest.cpp\", \"test/UtilsTest.cpp\", \"test/config.yml.example\", \"test/support/Support.cpp\", \"test/support/Support.h\", \"test/support/tut.h\", \"test/support/tut_reporter.h\", \"test/support/valgrind.h\", \"test/support/apache2_controller.rb\", \"test/support/config.rb\", \"test/support/multipart.rb\", \"test/support/nginx_controller.rb\", \"test/support/run_rspec_tests.rb\", \"test/support/test_helper.rb\", \"test/oxt/backtrace_test.cpp\", \"test/oxt/oxt_test_main.cpp\", \"test/oxt/syscall_interruption_test.cpp\", \"test/ruby/abstract_request_handler_spec.rb\", \"test/ruby/abstract_server_collection_spec.rb\", \"test/ruby/abstract_server_spec.rb\", \"test/ruby/application_spec.rb\", \"test/ruby/message_channel_spec.rb\", \"test/ruby/rack/application_spawner_spec.rb\", \"test/ruby/rails/application_spawner_spec.rb\", \"test/ruby/rails/framework_spawner_spec.rb\", \"test/ruby/rails/minimal_spawner_spec.rb\", \"test/ruby/rails/spawner_error_handling_spec.rb\", \"test/ruby/rails/spawner_privilege_lowering_spec.rb\", \"test/ruby/spawn_manager_spec.rb\", \"test/ruby/spawn_server_spec.rb\", \"test/ruby/utils_spec.rb\", \"test/ruby/wsgi/application_spawner_spec.rb\", \"test/integration_tests/apache2_tests.rb\", \"test/integration_tests/hello_world_rack_spec.rb\", \"test/integration_tests/hello_world_wsgi_spec.rb\", \"test/integration_tests/mycook_spec.rb\", \"test/integration_tests/nginx_tests.rb\", \"test/stub/apache2/httpd.conf.erb\", \"test/stub/apache2/mime.types\", \"test/stub/garbage1.dat\", \"test/stub/garbage2.dat\", \"test/stub/garbage3.dat\", \"test/stub/http_request.yml\", \"test/stub/message_channel.rb\", \"test/stub/message_channel_2.rb\", \"test/stub/message_channel_3.rb\", \"test/stub/MessageServer.dSYM/Contents/Info.plist\", \"test/stub/MessageServer.dSYM/Contents/Resources/DWARF/MessageServer\", \"test/stub/nginx/koi-utf\", \"test/stub/nginx/koi-win\", \"test/stub/nginx/mime.types\", \"test/stub/nginx/nginx.conf.erb\", \"test/stub/nginx/win-utf\", \"test/stub/rack/config.ru\", \"test/stub/rack/public/rack.jpg\", \"test/stub/rails_apps/foobar/app/controllers/application.rb\", \"test/stub/rails_apps/foobar/app/controllers/bar_controller_1.rb\", \"test/stub/rails_apps/foobar/app/controllers/bar_controller_2.rb\", \"test/stub/rails_apps/foobar/app/controllers/foo_controller.rb\", \"test/stub/rails_apps/foobar/app/helpers/application_helper.rb\", \"test/stub/rails_apps/foobar/config/boot.rb\", \"test/stub/rails_apps/foobar/config/database.yml\", \"test/stub/rails_apps/foobar/config/environment.rb\", \"test/stub/rails_apps/foobar/config/environments/development.rb\", \"test/stub/rails_apps/foobar/config/environments/production.rb\", \"test/stub/rails_apps/foobar/config/initializers/inflections.rb\", \"test/stub/rails_apps/foobar/config/initializers/mime_types.rb\", \"test/stub/rails_apps/foobar/config/routes.rb\", \"test/stub/rails_apps/mycook/app/controllers/application.rb\", \"test/stub/rails_apps/mycook/app/controllers/recipes_controller.rb\", \"test/stub/rails_apps/mycook/app/controllers/uploads_controller.rb\", \"test/stub/rails_apps/mycook/app/controllers/welcome_controller.rb\", \"test/stub/rails_apps/mycook/app/helpers/application_helper.rb\", \"test/stub/rails_apps/mycook/app/views/layouts/default.rhtml\", \"test/stub/rails_apps/mycook/app/views/recipes/create.rhtml\", \"test/stub/rails_apps/mycook/app/views/recipes/index.rhtml\", \"test/stub/rails_apps/mycook/app/views/recipes/new.rhtml\", \"test/stub/rails_apps/mycook/app/views/uploads/index.rhtml\", \"test/stub/rails_apps/mycook/app/views/uploads/new.html.erb\", \"test/stub/rails_apps/mycook/app/views/welcome/cached.rhtml\", \"test/stub/rails_apps/mycook/app/views/welcome/index.rhtml\", \"test/stub/rails_apps/mycook/config/boot.rb\", \"test/stub/rails_apps/mycook/config/database.yml\", \"test/stub/rai"..., 4096) = 4096
read(3, "ent.rb\", \"test/stub/rails_apps/mycook/config/environments/production.rb\", \"test/stub/rails_apps/mycook/config/initializers/inflections.rb\", \"test/stub/rails_apps/mycook/config/initializers/mime_types.rb\", \"test/stub/rails_apps/mycook/config/routes.rb\", \"test/stub/rails_apps/mycook/log/useless.txt\", \"test/stub/rails_apps/mycook/public/404.html\", \"test/stub/rails_apps/mycook/public/422.html\", \"test/stub/rails_apps/mycook/public/500.html\", \"test/stub/rails_apps/mycook/public/dispatch.cgi\", \"test/stub/rails_apps/mycook/public/dispatch.fcgi\", \"test/stub/rails_apps/mycook/public/dispatch.rb\", \"test/stub/rails_apps/mycook/public/favicon.ico\", \"test/stub/rails_apps/mycook/public/images/angrywizard.gif\", \"test/stub/rails_apps/mycook/public/images/cookbook.gif\", \"test/stub/rails_apps/mycook/public/images/header.png\", \"test/stub/rails_apps/mycook/public/images/rails.png\", \"test/stub/rails_apps/mycook/public/javascripts/application.js\", \"test/stub/rails_apps/mycook/public/javascripts/controls.js\", \"test/stub/rails_apps/mycook/public/javascripts/dragdrop.js\", \"test/stub/rails_apps/mycook/public/javascripts/effects.js\", \"test/stub/rails_apps/mycook/public/javascripts/prototype.js\", \"test/stub/rails_apps/mycook/public/robots.txt\", \"test/stub/rails_apps/mycook/public/uploads.html\", \"test/stub/rails_apps/mycook/public/welcome/cached.html\", \"test/stub/rails_apps/mycook/sites/some.site/public/uploads.html\", \"test/stub/rails_apps/mycook/sites/some.site/public/welcome/cached.html\", \"test/stub/rails_apps/mycook/tmp/cache/useless.txt\", \"test/stub/rails_apps/mycook/tmp/pids/useless.txt\", \"test/stub/rails_apps/mycook/tmp/sessions/useless.txt\", \"test/stub/rails_apps/mycook/tmp/sockets/useless.txt\", \"test/stub/spawn_server.rb\", \"test/stub/upload_data.txt\", \"test/stub/vendor_rails/minimal/actionmailer/lib/action_mailer.rb\", \"test/stub/vendor_rails/minimal/actionpack/lib/action_controller.rb\", \"test/stub/vendor_rails/minimal/actionpack/lib/action_pack.rb\", \"test/stub/vendor_rails/minimal/actionpack/lib/action_view.rb\", \"test/stub/vendor_rails/minimal/activerecord/lib/active_record.rb\", \"test/stub/vendor_rails/minimal/activeresource/lib/active_resource.rb\", \"test/stub/vendor_rails/minimal/activesupport/lib/active_support/whiny_nil.rb\", \"test/stub/vendor_rails/minimal/activesupport/lib/active_support.rb\", \"test/stub/vendor_rails/minimal/railties/lib/dispatcher.rb\", \"test/stub/vendor_rails/minimal/railties/lib/initializer.rb\", \"test/stub/vendor_rails/minimal/railties/lib/ruby_version_check.rb\", \"test/stub/vendor_rails/minimal/README\", \"test/stub/wsgi/passenger_wsgi.py\", \"test/stub/wsgi/passenger_wsgi.pyc\", \"test/stub/wsgi/public/wsgi-snake.jpg\", \"test/stub/zsfa/header.png\", \"test/stub/zsfa/index.html\", \"test/stub/zsfa/zsfa.png\"]\n  s.homepage = %q{http://www.modrails.com/}\n  s.rdoc_options = [\"-S\", \"-N\", \"-p\", \"-H\", \"--main\", \"README\", \"--title\", \"Passenger Ruby API\"]\n  s.require_paths = [\"lib\", \"ext\"]\n  s.requirements = [\"fastthread\", \"Apache 2 with development headers\"]\n  s.rubyforge_project = %q{passenger}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Apache module for Ruby on Rails support.}\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 3\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<rake>, [\">= 0.8.1\"])\n      s.add_runtime_dependency(%q<fastthread>, [\">= 1.0.1\"])\n      s.add_runtime_dependency(%q<rack>, [\">= 0\"])\n    else\n      s.add_dependency(%q<rake>, [\">= 0.8.1\"])\n      s.add_dependency(%q<fastthread>, [\">= 1.0.1\"])\n      s.add_dependency(%q<rack>, [\">= 0\"])\n    end\n  else\n    s.add_dependency(%q<rake>, [\">= 0.8.1\"])\n    s.add_dependency(%q<fastthread>, [\">= 1.0.1\"])\n    s.add_dependency(%q<rack>, [\">= 0\"])\n  end\nend\n", 4096) = 3838
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
brk(0x9f71000)                          = 0x9f71000
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/gem_plugin-0.2.3.gemspec", {st_mode=S_IFREG|0644, st_size=3716, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/gem_plugin-0.2.3.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=3716, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=3716, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{gem_plugin}\n  s.version = \"0.2.3\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Zed A. Shaw\"]\n  s.cert_chain = [\"-----BEGIN CERTIFICATE-----\\nMIIDUDCCAjigAwIBAgIBADANBgkqhkiG9w0BAQUFADBOMRwwGgYDVQQDDBNtb25n\\ncmVsLWRldmVsb3BtZW50MRkwFwYKCZImiZPyLGQBGRYJcnVieWZvcmdlMRMwEQYK\\nCZImiZPyLGQBGRYDb3JnMB4XDTA3MDkxNjEwMzI0OVoXDTA4MDkxNTEwMzI0OVow\\nTjEcMBoGA1UEAwwTbW9uZ3JlbC1kZXZlbG9wbWVudDEZMBcGCgmSJomT8ixkARkW\\nCXJ1Ynlmb3JnZTETMBEGCgmSJomT8ixkARkWA29yZzCCASIwDQYJKoZIhvcNAQEB\\nBQADggEPADCCAQoCggEBAMb9v3B01eOHk3FyypbQgKXzJplUE5P6dXoG+xpPm0Lv\\nP7BQmeMncOwqQ7zXpVQU+lTpXtQFTsOE3vL7KnhQFJKGvUAkbh24VFyopu1I0yqF\\nmGu4nRqNXGXVj8TvLSj4S1WpSRLAa0acLPNyKhGmoV9+crqQypSjM6XKjBeppifo\\n4eBmWGjiJEYMIJBvJZPJ4rAVDDA8C6CM1m3gMBGNh8ELDhU8HI9AP3dMIkTI2Wx9\\n9xkJwHdroAaS0IFFtYChrwee4FbCF1FHDgoTosMwa47DrLHg4hZ6ojaKwK5QVWEV\\nXGb6ju5UqpktnSWF2W+Lvl/K0tI42OH2CAhebT1gEVUCAwEAAaM5MDcwCQYDVR0T\\nBAIwADALBgNVHQ8EBAMCBLAwHQYDVR0OBBYEFGHChyMSZ16u9WOzKhgJSQ9lqDc5\\nMA0GCSqGSIb3DQEBBQUAA4IBAQA/lfeN2WdB1xN+82tT7vNS4HOjRQw6MUh5yktu\\nGQjaGqm0UB+aX0Z9y0B0qpfv9rj7nmIvEGiwBmDepNWYCGuW15JyqpN7QVVnG2xS\\nMrame7VqgjM7A+VGDD5In5LtWbM/CHAATvvFlQ5Ph13YE1EdnVbZ65c+KQv+5sFY\\nQ+zEop74d878uaC/SAHHXS46TiXneocaLSYw1CEZs/MAIy+9c4Q5ESbGpgnfg1Ad\\n6lwl7k3hsNHO/+tZzx4HJtOXDI1yAl3+q6T9J0yI3z97EinwvAKhS1eyOI2Y5eeT\\ntbQaNYkU127B3l/VNpd8fQm3Jkl/PqCCmDBQjUszFrJEODug\\n-----END CERTIFICATE-----\\n\", \"-----BEGIN CERTIFICATE-----\\nMIIDPzCCAiegAwIBAgIBADANBgkqhkiG9w0BAQUFADBOMRwwGgYDVQQDDBNtb25n\\ncmVsLWRldmVsb3BtZW50MRkwFwYKCZImiZPyLGQBGRYJcnVieWZvcmdlMRMwEQYK\\nCZImiZPyLGQBGRYDb3JnMB4XDTA3MDkxNjEwMzMwMFoXDTA4MDkxNTEwMzMwMFow\\nPTENMAsGA1UEAwwEZXZhbjEYMBYGCgmSJomT8ixkARkWCGNsb3VkYnVyMRIwEAYK\\nCZImiZPyLGQBGRYCc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDk\\nLQijz2fICmev4+9s0WB71WzJFYCUYFQQxqGlenbxWut9dlPSsBbskGjg+UITeOXi\\ncTh3MTqAB0i1LJyNOiyvDsAivn7GjKXhVvflp2/npMhBBe83P4HOWqeQBjkk3QJI\\nFFNBvqbFLeEXIP+HiqAOiyNHZEVXMepLEJLzGrg3Ly7M7A6L5fK7jDrt8jkm+c+8\\nzGquVHV5ohAebGd/vpHMLjpA7lCG5+MBgYZd33rRfNtCxDJMNRgnOu9PsB05+LJn\\nMpDKQq3x0SkOf5A+MVOcadNCaAkFflYk3SUcXaXWxu/eCHgqfW1m76RNSp5djpKE\\nCgNPK9lGIWpB3CHzDaVNAgMBAAGjOTA3MAkGA1UdEwQCMAAwCwYDVR0PBAQDAgSw\\nMB0GA1UdDgQWBBT5aonPfFBdJ5rWFG+8dZwgyB54LjANBgkqhkiG9w0BAQUFAAOC\\nAQEAiKbzWgMcvZs/TPwJxr8tJ+7mSGz7+zDkWcbBl8FpQq1DtRcATh1oyTkQT7t+\\nrFEBYMmb0FxbbUnojQp8hIFgFkUwFpStwWBL/okLSehntzI2iwjuEtfj4ac9Q3Y2\\nuSdbmZqsQTuu+lEUc5C4qLK7YKwToaul+cx7vWxyk1YendcVwRlFLIBqA5cPrwo3\\nyyGLTHlRYn2c9PSbM1B63Yg+LqSSAa4QSU3Wv9pNdffVpvwHPVEQpO7ZDo5slQFL\\nGf6+gbD/eZAvhpvmn8JlXb+LxKaFVMs2Yvrk1xOuT76SsPjEGWxkr7jZCIpsYfgQ\\nALN3mi/9z0Mf1YroliUgF0v5Yw==\\n-----END CERTIFICATE-----\\n\"]\n  s.date = %q{2007-10-26}\n  s.default_executable = %q{gpgen}\n  s.description = %q{A plugin system based on rubygems that uses dependencies only}\n  s.email = %q{}\n  s.executables = [\"gpgen\"]\n  s.files = [\"test/test_plugins.rb\", \"setup.rb\", \"resources/resources/defaults.yaml\", \"resources/README\", \"resources/Rakefile\", \"resources/LICENSE\", \"resources/lib/project/init.rb\", \"resources/COPYING\", \"README\", \"Manifest\", \"LICENSE\", \"lib/gem_plugin.rb\", \"COPYING\", \"CHANGELOG\", \"bin/gpgen\", \"gem_plugin.gemspec\"]\n  s.homepage = %q{}\n  s.require_paths = [\"lib\"]\n  s.rubyforge_project = %q{mongrel}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{A plugin system based on rubygems that uses dependencies only}\n  s.test_files = [\"test/test_plugins.rb\"]\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 2\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n    else\n    end\n  else\n  end\nend\n", 4096) = 3716
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/daemons-1.0.10.gemspec", {st_mode=S_IFREG|0644, st_size=2549, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/daemons-1.0.10.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=2549, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=2549, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{daemons}\n  s.version = \"1.0.10\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Thomas Uehlinger\"]\n  s.autorequire = %q{daemons}\n  s.date = %q{2008-03-21}\n  s.description = %q{Daemons provides an easy way to wrap existing ruby scripts (for example a self-written server)  to be run as a daemon and to be controlled by simple start/stop/restart commands.  You can also call blocks as daemons and control them from the parent or just daemonize the current process.  Besides this basic functionality, daemons offers many advanced features like exception  backtracing and logging (in case your ruby script crashes) and monitoring and automatic restarting of your processes if they crash.}\n  s.email = %q{th.uehlinger@gmx.ch}\n  s.extra_rdoc_files = [\"README\", \"Releases\", \"TODO\"]\n  s.files = [\"Rakefile\", \"Releases\", \"TODO\", \"README\", \"LICENSE\", \"setup.rb\", \"lib/daemons/application.rb\", \"lib/daemons/application_group.rb\", \"lib/daemons/cmdline.rb\", \"lib/daemons/controller.rb\", \"lib/daemons/daemonize.rb\", \"lib/daemons/exceptions.rb\", \"lib/daemons/monitor.rb\", \"lib/daemons/pid.rb\", \"lib/daemons/pidfile.rb\", \"lib/daemons/pidmem.rb\", \"lib/daemons.rb\", \"examples/call\", \"examples/call/call.rb\", \"examples/call/call_monitor.rb\", \"examples/daemonize\", \"examples/daemonize/daemonize.rb\", \"examples/run\", \"examples/run/ctrl_crash.rb\", \"examples/run/ctrl_exec.rb\", \"examples/run/ctrl_exit.rb\", \"examples/run/ctrl_keep_pid_files.rb\", \"examples/run/ctrl_monitor.rb\", \"examples/run/ctrl_multiple.rb\", \"examples/run/ctrl_normal.rb\", \"examples/run/ctrl_ontop.rb\", \"examples/run/ctrl_optionparser.rb\", \"examples/run/ctrl_proc.rb\", \"examples/run/ctrl_proc.rb.output\", \"examples/run/ctrl_proc_multiple.rb\", \"examples/run/ctrl_proc_multiple.rb.output\", \"examples/run/ctrl_proc_simple.rb\", \"examples/run/myserver.rb\", \"examples/run/myserver_crashing.rb\", \"examples/run/myserver_crashing.rb.output\", \"examples/run/myserver_exiting.rb\"]\n  s.homepage = %q{http://daemons.rubyforge.org}\n  s.require_paths = [\"lib\"]\n  s.rubyforge_project = %q{daemons}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{A toolkit to create and control daemons in different ways}\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 2\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n    else\n    end\n  else\n  end\nend\n", 4096) = 2549
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/rc-rest-3.0.0.gemspec", {st_mode=S_IFREG|0644, st_size=2951, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/rc-rest-3.0.0.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=2951, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=2951, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{rc-rest}\n  s.version = \"3.0.0\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Eric Hodel\"]\n  s.cert_chain = [\"-----BEGIN CERTIFICATE-----\\nMIIDNjCCAh6gAwIBAgIBADANBgkqhkiG9w0BAQUFADBBMRAwDgYDVQQDDAdkcmJy\\nYWluMRgwFgYKCZImiZPyLGQBGRYIc2VnbWVudDcxEzARBgoJkiaJk/IsZAEZFgNu\\nZXQwHhcNMDcxMjIxMDIwNDE0WhcNMDgxMjIwMDIwNDE0WjBBMRAwDgYDVQQDDAdk\\ncmJyYWluMRgwFgYKCZImiZPyLGQBGRYIc2VnbWVudDcxEzARBgoJkiaJk/IsZAEZ\\nFgNuZXQwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCbbgLrGLGIDE76\\nLV/cvxdEzCuYuS3oG9PrSZnuDweySUfdp/so0cDq+j8bqy6OzZSw07gdjwFMSd6J\\nU5ddZCVywn5nnAQ+Ui7jMW54CYt5/H6f2US6U0hQOjJR6cpfiymgxGdfyTiVcvTm\\nGj/okWrQl0NjYOYBpDi+9PPmaH2RmLJu0dB/NylsDnW5j6yN1BEI8MfJRR+HRKZY\\nmUtgzBwF1V4KIZQ8EuL6I/nHVu07i6IkrpAgxpXUfdJQJi0oZAqXurAV3yTxkFwd\\ng62YrrW26mDe+pZBzR6bpLE+PmXCzz7UxUq3AE0gPHbiMXie3EFE0oxnsU3lIduh\\nsCANiQ8BAgMBAAGjOTA3MAkGA1UdEwQCMAAwCwYDVR0PBAQDAgSwMB0GA1UdDgQW\\nBBS5k4Z75VSpdM0AclG2UvzFA/VW5DANBgkqhkiG9w0BAQUFAAOCAQEAHagT4lfX\\nkP/hDaiwGct7XPuVGbrOsKRVD59FF5kETBxEc9UQ1clKWngf8JoVuEoKD774dW19\\nbU0GOVWO+J6FMmT/Cp7nuFJ79egMf/gy4gfUfQMuvfcr6DvZUPIs9P/TlK59iMYF\\nDIOQ3DxdF3rMzztNUCizN4taVscEsjCcgW6WkUJnGdqlu3OHWpQxZBJkBTjPCoc6\\nUW6on70SFPmAy/5Cq0OJNGEWBfgD9q7rrs/X8GGwUWqXb85RXnUVi/P8Up75E0ag\\n14jEc90kN+C7oI/AGCBN0j6JnEtYIEJZibjjDJTSMWlUKKkj30kq7hlUC2CepJ4v\\nx52qPcexcYZR7w==\\n-----END CERTIFICATE-----\\n\"]\n  s.date = %q{2009-07-10}\n  s.description = %q{Robot Co-op REST web services base class. This library makes it easy to\nimplement REST-like web services APIs.}\n  s.email = [\"drbrain@segment7.net\"]\n  s.extra_rdoc_files = [\"History.txt\", \"LICENSE.txt\", \"Manifest.txt\", \"README.txt\"]\n  s.files = [\"History.txt\", \"LICENSE.txt\", \"Manifest.txt\", \"README.txt\", \"Rakefile\", \"lib/rc_rest.rb\", \"lib/rc_rest/net_http_stub.rb\", \"lib/rc_rest/uri_stub.rb\", \"test/test_rc_rest.rb\"]\n  s.homepage = %q{http://seattlerb.rubyforge.org/rc-rest}\n  s.rdoc_options = [\"--main\", \"README.txt\"]\n  s.require_paths = [\"lib\"]\n  s.rubyforge_project = %q{seattlerb}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Robot Co-op REST web services base class}\n  s.test_files = [\"test/test_rc_rest.rb\"]\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 3\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<nokogiri>, [\">= 1.3.1\"])\n      s.add_runtime_dependency(%q<minitest>, [\"~> 1.4\"])\n      s.add_development_dependency(%q<hoe>, [\">= 2.3.2\"])\n    else\n      s.add_dependency(%q<nokogiri>, [\">= 1.3.1\"])\n      s.add_dependency(%q<minitest>, [\"~> 1.4\"])\n      s.add_dependency(%q<hoe>, [\">= 2.3.2\"])\n    end\n  else\n    s.add_dependency(%q<nokogiri>, [\">= 1.3.1\"])\n    s.add_dependency(%q<minitest>, [\"~> 1.4\"])\n    s.add_dependency(%q<hoe>, [\">= 2.3.2\"])\n  end\nend\n", 4096) = 2951
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/will_paginate-2.3.11.gemspec", {st_mode=S_IFREG|0644, st_size=2949, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/will_paginate-2.3.11.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=2949, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=2949, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{will_paginate}\n  s.version = \"2.3.11\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Mislav Marohni\\304\\207\", \"PJ Hyett\"]\n  s.date = %q{2009-06-02}\n  s.description = %q{The will_paginate library provides a simple, yet powerful and extensible API for ActiveRecord pagination and rendering of pagination links in ActionView templates.}\n  s.email = %q{mislav.marohnic@gmail.com}\n  s.extra_rdoc_files = [\"README.rdoc\", \"LICENSE\", \"CHANGELOG.rdoc\"]\n  s.files = [\"CHANGELOG.rdoc\", \"LICENSE\", \"README.rdoc\", \"Rakefile\", \"examples/apple-circle.gif\", \"examples/index.haml\", \"examples/index.html\", \"examples/pagination.css\", \"examples/pagination.sass\", \"init.rb\", \"lib/will_paginate.rb\", \"lib/will_paginate/array.rb\", \"lib/will_paginate/collection.rb\", \"lib/will_paginate/core_ext.rb\", \"lib/will_paginate/finder.rb\", \"lib/will_paginate/named_scope.rb\", \"lib/will_paginate/named_scope_patch.rb\", \"lib/will_paginate/version.rb\", \"lib/will_paginate/view_helpers.rb\", \"test/boot.rb\", \"test/collection_test.rb\", \"test/console\", \"test/database.yml\", \"test/finder_test.rb\", \"test/fixtures/admin.rb\", \"test/fixtures/developer.rb\", \"test/fixtures/developers_projects.yml\", \"test/fixtures/project.rb\", \"test/fixtures/projects.yml\", \"test/fixtures/replies.yml\", \"test/fixtures/reply.rb\", \"test/fixtures/schema.rb\", \"test/fixtures/topic.rb\", \"test/fixtures/topics.yml\", \"test/fixtures/user.rb\", \"test/fixtures/users.yml\", \"test/helper.rb\", \"test/lib/activerecord_test_case.rb\", \"test/lib/activerecord_test_connector.rb\", \"test/lib/load_fixtures.rb\", \"test/lib/view_test_process.rb\", \"test/tasks.rake\", \"test/view_test.rb\"]\n  s.homepage = %q{http://github.com/mislav/will_paginate/wikis}\n  s.rdoc_options = [\"--main\", \"README.rdoc\", \"--inline-source\", \"--charset=UTF-8\"]\n  s.require_paths = [\"lib\"]\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Most awesome pagination solution for Rails}\n  s.test_files = [\"test/boot.rb\", \"test/collection_test.rb\", \"test/console\", \"test/database.yml\", \"test/finder_test.rb\", \"test/fixtures/admin.rb\", \"test/fixtures/developer.rb\", \"test/fixtures/developers_projects.yml\", \"test/fixtures/project.rb\", \"test/fixtures/projects.yml\", \"test/fixtures/replies.yml\", \"test/fixtures/reply.rb\", \"test/fixtures/schema.rb\", \"test/fixtures/topic.rb\", \"test/fixtures/topics.yml\", \"test/fixtures/user.rb\", \"test/fixtures/users.yml\", \"test/helper.rb\", \"test/lib/activerecord_test_case.rb\", \"test/lib/activerecord_test_connector.rb\", \"test/lib/load_fixtures.rb\", \"test/lib/view_test_process.rb\", \"test/tasks.rake\", \"test/view_test.rb\"]\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 3\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n    else\n    end\n  else\n  end\nend\n", 4096) = 2949
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/activeresource-2.3.5.gemspec", {st_mode=S_IFREG|0644, st_size=2095, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/activeresource-2.3.5.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=2095, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=2095, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{activeresource}\n  s.version = \"2.3.5\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"David Heinemeier Hansson\"]\n  s.autorequire = %q{active_resource}\n  s.date = %q{2009-11-26}\n  s.description = %q{Wraps web resources in model classes that can be manipulated through XML over REST.}\n  s.email = %q{david@loudthinking.com}\n  s.extra_rdoc_files = [\"README\"]\n  s.files = [\"Rakefile\", \"README\", \"CHANGELOG\", \"lib/active_resource/base.rb\", \"lib/active_resource/connection.rb\", \"lib/active_resource/custom_methods.rb\", \"lib/active_resource/exceptions.rb\", \"lib/active_resource/formats/json_format.rb\", \"lib/active_resource/formats/xml_format.rb\", \"lib/active_resource/formats.rb\", \"lib/active_resource/http_mock.rb\", \"lib/active_resource/validations.rb\", \"lib/active_resource/version.rb\", \"lib/active_resource.rb\", \"lib/activeresource.rb\", \"test/abstract_unit.rb\", \"test/authorization_test.rb\", \"test/base/custom_methods_test.rb\", \"test/base/equality_test.rb\", \"test/base/load_test.rb\", \"test/base_errors_test.rb\", \"test/base_test.rb\", \"test/connection_test.rb\", \"test/debug.log\", \"test/fixtures/beast.rb\", \"test/fixtures/customer.rb\", \"test/fixtures/person.rb\", \"test/fixtures/proxy.rb\", \"test/fixtures/street_address.rb\", \"test/format_test.rb\", \"test/setter_trap.rb\"]\n  s.homepage = %q{http://www.rubyonrails.org}\n  s.rdoc_options = [\"--main\", \"README\"]\n  s.require_paths = [\"lib\"]\n  s.rubyforge_project = %q{activeresource}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Think Active Record for web resources.}\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 3\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<activesupport>, [\"= 2.3.5\"])\n    else\n      s.add_dependency(%q<activesupport>, [\"= 2.3.5\"])\n    end\n  else\n    s.add_dependency(%q<activesupport>, [\"= 2.3.5\"])\n  end\nend\n", 4096) = 2095
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/mongrel_cluster-1.0.5.gemspec", {st_mode=S_IFREG|0644, st_size=4108, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/mongrel_cluster-1.0.5.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=4108, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=4108, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{mongrel_cluster}\n  s.version = \"1.0.5\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Bradley Taylor\"]\n  s.cert_chain = [\"-----BEGIN CERTIFICATE-----\\nMIIDUDCCAjigAwIBAgIBADANBgkqhkiG9w0BAQUFADBOMRwwGgYDVQQDDBNtb25n\\ncmVsLWRldmVsb3BtZW50MRkwFwYKCZImiZPyLGQBGRYJcnVieWZvcmdlMRMwEQYK\\nCZImiZPyLGQBGRYDb3JnMB4XDTA3MDkxNjEwMzI0OVoXDTA4MDkxNTEwMzI0OVow\\nTjEcMBoGA1UEAwwTbW9uZ3JlbC1kZXZlbG9wbWVudDEZMBcGCgmSJomT8ixkARkW\\nCXJ1Ynlmb3JnZTETMBEGCgmSJomT8ixkARkWA29yZzCCASIwDQYJKoZIhvcNAQEB\\nBQADggEPADCCAQoCggEBAMb9v3B01eOHk3FyypbQgKXzJplUE5P6dXoG+xpPm0Lv\\nP7BQmeMncOwqQ7zXpVQU+lTpXtQFTsOE3vL7KnhQFJKGvUAkbh24VFyopu1I0yqF\\nmGu4nRqNXGXVj8TvLSj4S1WpSRLAa0acLPNyKhGmoV9+crqQypSjM6XKjBeppifo\\n4eBmWGjiJEYMIJBvJZPJ4rAVDDA8C6CM1m3gMBGNh8ELDhU8HI9AP3dMIkTI2Wx9\\n9xkJwHdroAaS0IFFtYChrwee4FbCF1FHDgoTosMwa47DrLHg4hZ6ojaKwK5QVWEV\\nXGb6ju5UqpktnSWF2W+Lvl/K0tI42OH2CAhebT1gEVUCAwEAAaM5MDcwCQYDVR0T\\nBAIwADALBgNVHQ8EBAMCBLAwHQYDVR0OBBYEFGHChyMSZ16u9WOzKhgJSQ9lqDc5\\nMA0GCSqGSIb3DQEBBQUAA4IBAQA/lfeN2WdB1xN+82tT7vNS4HOjRQw6MUh5yktu\\nGQjaGqm0UB+aX0Z9y0B0qpfv9rj7nmIvEGiwBmDepNWYCGuW15JyqpN7QVVnG2xS\\nMrame7VqgjM7A+VGDD5In5LtWbM/CHAATvvFlQ5Ph13YE1EdnVbZ65c+KQv+5sFY\\nQ+zEop74d878uaC/SAHHXS46TiXneocaLSYw1CEZs/MAIy+9c4Q5ESbGpgnfg1Ad\\n6lwl7k3hsNHO/+tZzx4HJtOXDI1yAl3+q6T9J0yI3z97EinwvAKhS1eyOI2Y5eeT\\ntbQaNYkU127B3l/VNpd8fQm3Jkl/PqCCmDBQjUszFrJEODug\\n-----END CERTIFICATE-----\\n\", \"-----BEGIN CERTIFICATE-----\\nMIIDPzCCAiegAwIBAgIBADANBgkqhkiG9w0BAQUFADBOMRwwGgYDVQQDDBNtb25n\\ncmVsLWRldmVsb3BtZW50MRkwFwYKCZImiZPyLGQBGRYJcnVieWZvcmdlMRMwEQYK\\nCZImiZPyLGQBGRYDb3JnMB4XDTA3MDkxNjEwMzMwMFoXDTA4MDkxNTEwMzMwMFow\\nPTENMAsGA1UEAwwEZXZhbjEYMBYGCgmSJomT8ixkARkWCGNsb3VkYnVyMRIwEAYK\\nCZImiZPyLGQBGRYCc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDk\\nLQijz2fICmev4+9s0WB71WzJFYCUYFQQxqGlenbxWut9dlPSsBbskGjg+UITeOXi\\ncTh3MTqAB0i1LJyNOiyvDsAivn7GjKXhVvflp2/npMhBBe83P4HOWqeQBjkk3QJI\\nFFNBvqbFLeEXIP+HiqAOiyNHZEVXMepLEJLzGrg3Ly7M7A6L5fK7jDrt8jkm+c+8\\nzGquVHV5ohAebGd/vpHMLjpA7lCG5+MBgYZd33rRfNtCxDJMNRgnOu9PsB05+LJn\\nMpDKQq3x0SkOf5A+MVOcadNCaAkFflYk3SUcXaXWxu/eCHgqfW1m76RNSp5djpKE\\nCgNPK9lGIWpB3CHzDaVNAgMBAAGjOTA3MAkGA1UdEwQCMAAwCwYDVR0PBAQDAgSw\\nMB0GA1UdDgQWBBT5aonPfFBdJ5rWFG+8dZwgyB54LjANBgkqhkiG9w0BAQUFAAOC\\nAQEAiKbzWgMcvZs/TPwJxr8tJ+7mSGz7+zDkWcbBl8FpQq1DtRcATh1oyTkQT7t+\\nrFEBYMmb0FxbbUnojQp8hIFgFkUwFpStwWBL/okLSehntzI2iwjuEtfj4ac9Q3Y2\\nuSdbmZqsQTuu+lEUc5C4qLK7YKwToaul+cx7vWxyk1YendcVwRlFLIBqA5cPrwo3\\nyyGLTHlRYn2c9PSbM1B63Yg+LqSSAa4QSU3Wv9pNdffVpvwHPVEQpO7ZDo5slQFL\\nGf6+gbD/eZAvhpvmn8JlXb+LxKaFVMs2Yvrk1xOuT76SsPjEGWxkr7jZCIpsYfgQ\\nALN3mi/9z0Mf1YroliUgF0v5Yw==\\n-----END CERTIFICATE-----\\n\"]\n  s.date = %q{2007-11-13}\n  s.default_executable = %q{mongrel_cluster_ctl}\n  s.description = %q{Mongrel plugin that provides commands and Capistrano tasks for managing multiple Mongrel processes.}\n  s.email = %q{}\n  s.executables = [\"mongrel_cluster_ctl\"]\n  s.files = [\"bin/mongrel_cluster_ctl\", \"CHANGELOG\", \"COPYING\", \"lib/mongrel_cluster/init.rb\", \"lib/mongrel_cluster/recipes.rb\", \"lib/mongrel_cluster/recipes_1.rb\", \"lib/mongrel_cluster/recipes_2.rb\", \"LICENSE\", \"Manifest\", \"README\", \"resources/defaults.yaml\", \"resources/mongrel_cluster\", \"mongrel_cluster.gemspec\"]\n  s.homepage = %q{}\n  s.require_paths = [\"lib\"]\n  s.rubyforge_project = %q{mongrel}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Mongrel plugin that provides commands and Capistrano tasks for managing multiple Mongrel processes.}\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 2\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<gem_plugin>, [\">= 0.2.3\"])\n      s.add_runtime_dependency(%q<mongrel>, [\">= 1.0.2\"])\n    else\n      s.add_dependency(%q<gem_plugin>, [\">= 0.2.3\"])\n      s.add_dependency(%q<mongrel>, [\">= 1.0.2\"])\n    end\n  else\n "..., 4096) = 4096
read(3, ")\n  end\nend\n", 4096)        = 12
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/json-1.2.0.gemspec", {st_mode=S_IFREG|0644, st_size=5864, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/json-1.2.0.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=5864, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=5864, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{json}\n  s.version = \"1.2.0\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Florian Frank\"]\n  s.date = %q{2009-11-08}\n  s.default_executable = %q{edit_json.rb}\n  s.description = %q{This is a JSON implementation as a Ruby extension in C.}\n  s.email = %q{flori@ping.de}\n  s.executables = [\"edit_json.rb\", \"prettify_json.rb\"]\n  s.extensions = [\"ext/json/ext/generator/extconf.rb\", \"ext/json/ext/parser/extconf.rb\"]\n  s.extra_rdoc_files = [\"README\"]\n  s.files = [\"CHANGES\", \"bin/edit_json.rb\", \"bin/prettify_json.rb\", \"VERSION\", \"GPL\", \"TODO\", \"README\", \"benchmarks/parser_benchmark.rb\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkPure.log\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkComparison.log\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkYAML#parser.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkExt#generator_safe.dat\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkExt#parser.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkExt#generator_fast.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkExt#generator_fast-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkPure.log\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkExt#parser-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkRails#generator-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkExt.log\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkPure#generator_fast-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkPure#generator_fast.dat\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkRails#parser.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkPure#generator_pretty-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkPure#parser-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkExt#generator_pretty.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkRails.log\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkExt.log\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkRails.log\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkComparison.log\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkPure#generator_safe.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkRails#generator.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkExt#generator_safe-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkPure#generator_pretty.dat\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkYAML.log\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkYAML#parser-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkExt#generator_pretty-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkRails#parser-autocorrelation.dat\", \"benchmarks/data-p4-3GHz-ruby18/ParserBenchmarkPure#parser.dat\", \"benchmarks/data-p4-3GHz-ruby18/GeneratorBenchmarkPure#generator_safe-autocorrelation.dat\", \"benchmarks/generator_benchmark.rb\", \"ext/json/ext/generator/extconf.rb\", \"ext/json/ext/generator/unicode.c\", \"ext/json/ext/generator/generator.c\", \"ext/json/ext/generator/unicode.h\", \"ext/json/ext/parser/extconf.rb\", \"ext/json/ext/parser/parser.rl\", \"ext/json/ext/parser/unicode.c\", \"ext/json/ext/parser/parser.c\", \"ext/json/ext/parser/unicode.h\", \"Rakefile\", \"tools/fuzz.rb\", \"tools/server.rb\", \"lib/json.rb\", \"lib/json/json.xpm\", \"lib/json/Key.xpm\", \"lib/json/String.xpm\", \"lib/json/Numeric.xpm\", \"lib/json/Hash.xpm\", \"lib/json/add/rails.rb\", \"lib/json/add/core.rb\", \"lib/json/common.rb\", \"lib/json/Array.xpm\", \"lib/json/FalseClass.xpm\", \"lib/json/pure/generator.rb\", \"lib/json/pure/parser.rb\", \"lib/json/TrueClass.xpm\", \"lib/json/pure.rb\", \"lib/json/version.rb\", \"lib/json/ext.rb\", \"lib/json/editor.rb\", \"lib/json/NilClass.xpm\", \"data/example.json\", \"data/index.html\", \"data/prototype.js\", \"tests/test_json_encoding.rb\", \"tests/test_json_addition.rb\", \"tests/fixture"..., 4096) = 4096
read(3, ".json\", \"tests/fixtures/fail8.json\", \"tests/fixtures/fail19.json\", \"tests/fixtures/pass2.json\", \"tests/fixtures/pass26.json\", \"tests/fixtures/pass1.json\", \"tests/fixtures/fail3.json\", \"tests/fixtures/fail20.json\", \"tests/fixtures/pass3.json\", \"tests/fixtures/pass15.json\", \"tests/fixtures/fail12.json\", \"tests/fixtures/fail13.json\", \"tests/fixtures/fail22.json\", \"tests/fixtures/fail24.json\", \"tests/fixtures/fail9.json\", \"tests/fixtures/fail2.json\", \"tests/fixtures/fail14.json\", \"tests/fixtures/fail6.json\", \"tests/fixtures/fail21.json\", \"tests/fixtures/fail7.json\", \"tests/fixtures/pass17.json\", \"tests/fixtures/fail11.json\", \"tests/fixtures/fail25.json\", \"tests/fixtures/fail5.json\", \"tests/fixtures/fail18.json\", \"tests/fixtures/fail27.json\", \"tests/fixtures/fail10.json\", \"tests/fixtures/fail23.json\", \"tests/test_json_rails.rb\", \"tests/test_json.rb\", \"tests/test_json_generate.rb\", \"tests/test_json_unicode.rb\", \"tests/test_json_fixtures.rb\", \"COPYING\", \"install.rb\"]\n  s.homepage = %q{http://json.rubyforge.org}\n  s.rdoc_options = [\"--title\", \"JSON -- A JSON implemention\", \"--main\", \"README\"]\n  s.require_paths = [\"ext/json/ext\", \"ext\", \"lib\"]\n  s.rubyforge_project = %q{json}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{A JSON implementation as a Ruby extension}\n  s.test_files = [\"tests/test_json_encoding.rb\", \"tests/test_json_addition.rb\", \"tests/test_json_rails.rb\", \"tests/test_json.rb\", \"tests/test_json_generate.rb\", \"tests/test_json_unicode.rb\", \"tests/test_json_fixtures.rb\"]\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 3\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n    else\n    end\n  else\n  end\nend\n", 4096) = 1768
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/hoe-2.5.0.gemspec", {st_mode=S_IFREG|0644, st_size=4086, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/hoe-2.5.0.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=4086, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=4086, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{hoe}\n  s.version = \"2.5.0\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 1.3.1\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Ryan Davis\"]\n  s.cert_chain = [\"-----BEGIN CERTIFICATE-----\\nMIIDPjCCAiagAwIBAgIBADANBgkqhkiG9w0BAQUFADBFMRMwEQYDVQQDDApyeWFu\\nZC1ydWJ5MRkwFwYKCZImiZPyLGQBGRYJemVuc3BpZGVyMRMwEQYKCZImiZPyLGQB\\nGRYDY29tMB4XDTA5MDMwNjE4NTMxNVoXDTEwMDMwNjE4NTMxNVowRTETMBEGA1UE\\nAwwKcnlhbmQtcnVieTEZMBcGCgmSJomT8ixkARkWCXplbnNwaWRlcjETMBEGCgmS\\nJomT8ixkARkWA2NvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALda\\nb9DCgK+627gPJkB6XfjZ1itoOQvpqH1EXScSaba9/S2VF22VYQbXU1xQXL/WzCkx\\ntaCPaLmfYIaFcHHCSY4hYDJijRQkLxPeB3xbOfzfLoBDbjvx5JxgJxUjmGa7xhcT\\noOvjtt5P8+GSK9zLzxQP0gVLS/D0FmoE44XuDr3iQkVS2ujU5zZL84mMNqNB1znh\\nGiadM9GHRaDiaxuX0cIUBj19T01mVE2iymf9I6bEsiayK/n6QujtyCbTWsAS9Rqt\\nqhtV7HJxNKuPj/JFH0D2cswvzznE/a5FOYO68g+YCuFi5L8wZuuM8zzdwjrWHqSV\\ngBEfoTEGr7Zii72cx+sCAwEAAaM5MDcwCQYDVR0TBAIwADALBgNVHQ8EBAMCBLAw\\nHQYDVR0OBBYEFEfFe9md/r/tj/Wmwpy+MI8d9k/hMA0GCSqGSIb3DQEBBQUAA4IB\\nAQAY59gYvDxqSqgC92nAP9P8dnGgfZgLxP237xS6XxFGJSghdz/nI6pusfCWKM8m\\nvzjjH2wUMSSf3tNudQ3rCGLf2epkcU13/rguI88wO6MrE0wi4ZqLQX+eZQFskJb/\\nw6x9W1ur8eR01s397LSMexySDBrJOh34cm2AlfKr/jokKCTwcM0OvVZnAutaovC0\\nl1SVZ0ecg88bsWHA0Yhh7NFxK1utWoIhtB6AFC/+trM0FQEB/jZkIS8SaNzn96Rl\\nn0sZEf77FLf5peR8TP/PtmIg7Cyqz23sLM4mCOoTGIy5OcZ8TdyiyINUHtb5ej/T\\nFBHgymkyj/AOSqKRIpXPhjC6\\n-----END CERTIFICATE-----\\n\"]\n  s.date = %q{2010-01-06}\n  s.default_executable = %q{sow}\n  s.description = %q{Hoe is a rake/rubygems helper for project Rakefiles. It helps you\nmanage and maintain, and release your project and includes a dynamic\nplug-in system allowing for easy extensibility. Hoe ships with\nplug-ins for all your usual project tasks including rdoc generation,\ntesting, packaging, and deployment.\n\nSee class rdoc for help. Hint: `ri Hoe` or any of the plugins listed\nbelow.\n\nFor extra goodness, see: http://seattlerb.rubyforge.org/hoe/Hoe.pdf}\n  s.email = [\"ryand-ruby@zenspider.com\"]\n  s.executables = [\"sow\"]\n  s.extra_rdoc_files = [\"History.txt\", \"Manifest.txt\", \"README.txt\"]\n  s.files = [\".autotest\", \"History.txt\", \"Hoe.pdf\", \"Manifest.txt\", \"README.txt\", \"Rakefile\", \"bin/sow\", \"lib/hoe.rb\", \"lib/hoe/clean.rb\", \"lib/hoe/debug.rb\", \"lib/hoe/deps.rb\", \"lib/hoe/flay.rb\", \"lib/hoe/flog.rb\", \"lib/hoe/gemcutter.rb\", \"lib/hoe/inline.rb\", \"lib/hoe/newb.rb\", \"lib/hoe/package.rb\", \"lib/hoe/publish.rb\", \"lib/hoe/rake.rb\", \"lib/hoe/rcov.rb\", \"lib/hoe/rubyforge.rb\", \"lib/hoe/signing.rb\", \"lib/hoe/test.rb\", \"template/.autotest.erb\", \"template/History.txt.erb\", \"template/Manifest.txt.erb\", \"template/README.txt.erb\", \"template/Rakefile.erb\", \"template/bin/file_name.erb\", \"template/lib/file_name.rb.erb\", \"template/test/test_file_name.rb.erb\", \"test/test_hoe.rb\", \"test/test_hoe_gemcutter.rb\"]\n  s.homepage = %q{http://rubyforge.org/projects/seattlerb/}\n  s.rdoc_options = [\"--main\", \"README.txt\"]\n  s.require_paths = [\"lib\"]\n  s.rubyforge_project = %q{seattlerb}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Hoe is a rake/rubygems helper for project Rakefiles}\n  s.test_files = [\"test/test_hoe.rb\", \"test/test_hoe_gemcutter.rb\"]\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 3\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<rubyforge>, [\">= 2.0.3\"])\n      s.add_runtime_dependency(%q<gemcutter>, [\">= 0.2.1\"])\n      s.add_runtime_dependency(%q<rake>, [\">= 0.8.7\"])\n      s.add_development_dependency(%q<minitest>, [\">= 1.4.2\"])\n    else\n      s.add_dependency(%q<rubyforge>, [\">= 2.0.3\"])\n      s.add_dependency(%q<gemcutter>, [\">= 0.2.1\"])\n      s.add_dependency(%q<rake>, [\">= 0.8.7\"])\n      s.add_dependency(%q<minitest>, [\">= 1.4.2\"])\n    end\n  else\n    s.add_dependency(%q<rubyforge>, [\">= 2.0.3\"])\n    s.add_dependency(%q<gemcutter>, [\">= 0.2.1\"])\n    s.add_dependen"..., 4096) = 4086
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/xml-simple-1.0.12.gemspec", {st_mode=S_IFREG|0644, st_size=812, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/xml-simple-1.0.12.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=812, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=812, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{xml-simple}\n  s.version = \"1.0.12\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Maik Schmidt\"]\n  s.date = %q{2009-02-27}\n  s.email = %q{contact@maik-schmidt.de}\n  s.files = [\"lib/xmlsimple.rb\"]\n  s.homepage = %q{http://xml-simple.rubyforge.org}\n  s.require_paths = [\"lib\"]\n  s.rubyforge_project = %q{xml-simple}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{A simple API for XML processing.}\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 2\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n    else\n    end\n  else\n  end\nend\n", 4096) = 812
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/rails-2.3.5.gemspec", {st_mode=S_IFREG|0644, st_size=15847, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/rails-2.3.5.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=15847, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=15847, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{rails}\n  s.version = \"2.3.5\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"David Heinemeier Hansson\"]\n  s.date = %q{2009-11-26}\n  s.default_executable = %q{rails}\n  s.description = %q{    Rails is a framework for building web-application using CGI, FCGI, mod_ruby, or WEBrick\n    on top of either MySQL, PostgreSQL, SQLite, DB2, SQL Server, or Oracle with eRuby- or Builder-based templates.\n}\n  s.email = %q{david@loudthinking.com}\n  s.executables = [\"rails\"]\n  s.files = [\"CHANGELOG\", \"fresh_rakefile\", \"MIT-LICENSE\", \"Rakefile\", \"README\", \"bin/about\", \"bin/console\", \"bin/dbconsole\", \"bin/destroy\", \"bin/generate\", \"bin/performance/benchmarker\", \"bin/performance/profiler\", \"bin/plugin\", \"bin/rails\", \"bin/runner\", \"bin/server\", \"builtin/rails_info/rails/info.rb\", \"builtin/rails_info/rails/info_controller.rb\", \"builtin/rails_info/rails/info_helper.rb\", \"builtin/rails_info/rails_info_controller.rb\", \"configs/databases/frontbase.yml\", \"configs/databases/ibm_db.yml\", \"configs/databases/mysql.yml\", \"configs/databases/oracle.yml\", \"configs/databases/postgresql.yml\", \"configs/databases/sqlite2.yml\", \"configs/databases/sqlite3.yml\", \"configs/empty.log\", \"configs/initializers/backtrace_silencers.rb\", \"configs/initializers/inflections.rb\", \"configs/initializers/mime_types.rb\", \"configs/initializers/new_rails_defaults.rb\", \"configs/initializers/session_store.rb\", \"configs/locales/en.yml\", \"configs/routes.rb\", \"configs/seeds.rb\", \"doc/README_FOR_APP\", \"dispatches/config.ru\", \"dispatches/dispatch.fcgi\", \"dispatches/dispatch.rb\", \"dispatches/gateway.cgi\", \"environments/boot.rb\", \"environments/development.rb\", \"environments/environment.rb\", \"environments/production.rb\", \"environments/test.rb\", \"guides/files/javascripts/code_highlighter.js\", \"guides/files/javascripts/guides.js\", \"guides/files/javascripts/highlighters.js\", \"guides/files/stylesheets/main.css\", \"guides/files/stylesheets/print.css\", \"guides/files/stylesheets/reset.css\", \"guides/files/stylesheets/style.css\", \"guides/files/stylesheets/syntax.css\", \"guides/images/belongs_to.png\", \"guides/images/book_icon.gif\", \"guides/images/bullet.gif\", \"guides/images/chapters_icon.gif\", \"guides/images/check_bullet.gif\", \"guides/images/credits_pic_blank.gif\", \"guides/images/csrf.png\", \"guides/images/customized_error_messages.png\", \"guides/images/error_messages.png\", \"guides/images/feature_tile.gif\", \"guides/images/footer_tile.gif\", \"guides/images/fxn.jpg\", \"guides/images/grey_bullet.gif\", \"guides/images/habtm.png\", \"guides/images/has_many.png\", \"guides/images/has_many_through.png\", \"guides/images/has_one.png\", \"guides/images/has_one_through.png\", \"guides/images/header_backdrop.png\", \"guides/images/header_tile.gif\", \"guides/images/i18n/demo_localized_pirate.png\", \"guides/images/i18n/demo_translated_en.png\", \"guides/images/i18n/demo_translated_pirate.png\", \"guides/images/i18n/demo_translation_missing.png\", \"guides/images/i18n/demo_untranslated.png\", \"guides/images/icons/callouts/1.png\", \"guides/images/icons/callouts/10.png\", \"guides/images/icons/callouts/11.png\", \"guides/images/icons/callouts/12.png\", \"guides/images/icons/callouts/13.png\", \"guides/images/icons/callouts/14.png\", \"guides/images/icons/callouts/15.png\", \"guides/images/icons/callouts/2.png\", \"guides/images/icons/callouts/3.png\", \"guides/images/icons/callouts/4.png\", \"guides/images/icons/callouts/5.png\", \"guides/images/icons/callouts/6.png\", \"guides/images/icons/callouts/7.png\", \"guides/images/icons/callouts/8.png\", \"guides/images/icons/callouts/9.png\", \"guides/images/icons/caution.png\", \"guides/images/icons/example.png\", \"guides/images/icons/home.png\", \"guides/images/icons/important.png\", \"guides/images/icons/next.png\", \"guides/images/icons/note.png\", \"guides/images/icons/prev.png\", \"guides/images/icons/README\", \"guides/images/icons/tip.png\", \"guides/images/icons/up.png\", \"guides/images/icons/warning"..., 4096) = 4096
read(3, "x.png\", \"guides/images/rails_guides_logo.gif\", \"guides/images/rails_logo_remix.gif\", \"guides/images/rails_welcome.png\", \"guides/images/session_fixation.png\", \"guides/images/tab_grey.gif\", \"guides/images/tab_info.gif\", \"guides/images/tab_note.gif\", \"guides/images/tab_red.gif\", \"guides/images/tab_yellow.gif\", \"guides/images/tab_yellow.png\", \"guides/images/validation_error_messages.png\", \"guides/rails_guides/generator.rb\", \"guides/rails_guides/helpers.rb\", \"guides/rails_guides/indexer.rb\", \"guides/rails_guides/textile_extensions.rb\", \"guides/rails_guides.rb\", \"guides/source/2_2_release_notes.textile\", \"guides/source/2_3_release_notes.textile\", \"guides/source/action_controller_overview.textile\", \"guides/source/action_mailer_basics.textile\", \"guides/source/active_record_basics.textile\", \"guides/source/active_record_querying.textile\", \"guides/source/activerecord_validations_callbacks.textile\", \"guides/source/association_basics.textile\", \"guides/source/caching_with_rails.textile\", \"guides/source/command_line.textile\", \"guides/source/configuring.textile\", \"guides/source/contribute.textile\", \"guides/source/contributing_to_rails.textile\", \"guides/source/credits.erb.textile\", \"guides/source/debugging_rails_applications.textile\", \"guides/source/form_helpers.textile\", \"guides/source/getting_started.textile\", \"guides/source/i18n.textile\", \"guides/source/index.erb.textile\", \"guides/source/layout.html.erb\", \"guides/source/layouts_and_rendering.textile\", \"guides/source/migrations.textile\", \"guides/source/nested_model_forms.textile\", \"guides/source/performance_testing.textile\", \"guides/source/plugins.textile\", \"guides/source/rails_on_rack.textile\", \"guides/source/routing.textile\", \"guides/source/security.textile\", \"guides/source/testing.textile\", \"helpers/application_controller.rb\", \"helpers/application_helper.rb\", \"helpers/performance_test.rb\", \"helpers/test_helper.rb\", \"html/404.html\", \"html/422.html\", \"html/500.html\", \"html/favicon.ico\", \"html/images/rails.png\", \"html/index.html\", \"html/javascripts/application.js\", \"html/javascripts/controls.js\", \"html/javascripts/dragdrop.js\", \"html/javascripts/effects.js\", \"html/javascripts/prototype.js\", \"html/robots.txt\", \"lib/code_statistics.rb\", \"lib/commands/about.rb\", \"lib/commands/console.rb\", \"lib/commands/dbconsole.rb\", \"lib/commands/destroy.rb\", \"lib/commands/generate.rb\", \"lib/commands/ncgi/listener\", \"lib/commands/ncgi/tracker\", \"lib/commands/performance/benchmarker.rb\", \"lib/commands/performance/profiler.rb\", \"lib/commands/plugin.rb\", \"lib/commands/runner.rb\", \"lib/commands/server.rb\", \"lib/commands/update.rb\", \"lib/commands.rb\", \"lib/console_app.rb\", \"lib/console_sandbox.rb\", \"lib/console_with_helpers.rb\", \"lib/dispatcher.rb\", \"lib/fcgi_handler.rb\", \"lib/initializer.rb\", \"lib/performance_test_help.rb\", \"lib/rails/backtrace_cleaner.rb\", \"lib/rails/gem_builder.rb\", \"lib/rails/gem_dependency.rb\", \"lib/rails/plugin/loader.rb\", \"lib/rails/plugin/locator.rb\", \"lib/rails/plugin.rb\", \"lib/rails/rack/debugger.rb\", \"lib/rails/rack/log_tailer.rb\", \"lib/rails/rack/metal.rb\", \"lib/rails/rack/static.rb\", \"lib/rails/rack.rb\", \"lib/rails/vendor_gem_source_index.rb\", \"lib/rails/version.rb\", \"lib/rails_generator/base.rb\", \"lib/rails_generator/commands.rb\", \"lib/rails_generator/generated_attribute.rb\", \"lib/rails_generator/generators/applications/app/app_generator.rb\", \"lib/rails_generator/generators/applications/app/scm/git.rb\", \"lib/rails_generator/generators/applications/app/scm/scm.rb\", \"lib/rails_generator/generators/applications/app/scm/svn.rb\", \"lib/rails_generator/generators/applications/app/template_runner.rb\", \"lib/rails_generator/generators/applications/app/USAGE\", \"lib/rails_generator/generators/components/controller/controller_generator.rb\", \"lib/rails_generator/generators/components/controller/templates/controller.rb\", \"lib/rails_generator/generators/components/controller/templates/functional_test.rb\", \"lib/rails_generator/generators/components/controller/templates/helper.rb\", \"lib/rails_generator"..., 4096) = 4096
read(3, "ponents/controller/templates/view.html.erb\", \"lib/rails_generator/generators/components/controller/USAGE\", \"lib/rails_generator/generators/components/helper/helper_generator.rb\", \"lib/rails_generator/generators/components/helper/templates/helper.rb\", \"lib/rails_generator/generators/components/helper/templates/helper_test.rb\", \"lib/rails_generator/generators/components/helper/USAGE\", \"lib/rails_generator/generators/components/integration_test/integration_test_generator.rb\", \"lib/rails_generator/generators/components/integration_test/templates/integration_test.rb\", \"lib/rails_generator/generators/components/integration_test/USAGE\", \"lib/rails_generator/generators/components/mailer/mailer_generator.rb\", \"lib/rails_generator/generators/components/mailer/templates/fixture.erb\", \"lib/rails_generator/generators/components/mailer/templates/fixture.rhtml\", \"lib/rails_generator/generators/components/mailer/templates/mailer.rb\", \"lib/rails_generator/generators/components/mailer/templates/unit_test.rb\", \"lib/rails_generator/generators/components/mailer/templates/view.erb\", \"lib/rails_generator/generators/components/mailer/templates/view.rhtml\", \"lib/rails_generator/generators/components/mailer/USAGE\", \"lib/rails_generator/generators/components/metal/metal_generator.rb\", \"lib/rails_generator/generators/components/metal/templates/metal.rb\", \"lib/rails_generator/generators/components/metal/USAGE\", \"lib/rails_generator/generators/components/migration/migration_generator.rb\", \"lib/rails_generator/generators/components/migration/templates/migration.rb\", \"lib/rails_generator/generators/components/migration/USAGE\", \"lib/rails_generator/generators/components/model/model_generator.rb\", \"lib/rails_generator/generators/components/model/templates/fixtures.yml\", \"lib/rails_generator/generators/components/model/templates/migration.rb\", \"lib/rails_generator/generators/components/model/templates/model.rb\", \"lib/rails_generator/generators/components/model/templates/unit_test.rb\", \"lib/rails_generator/generators/components/model/USAGE\", \"lib/rails_generator/generators/components/observer/observer_generator.rb\", \"lib/rails_generator/generators/components/observer/templates/observer.rb\", \"lib/rails_generator/generators/components/observer/templates/unit_test.rb\", \"lib/rails_generator/generators/components/observer/USAGE\", \"lib/rails_generator/generators/components/performance_test/performance_test_generator.rb\", \"lib/rails_generator/generators/components/performance_test/templates/performance_test.rb\", \"lib/rails_generator/generators/components/performance_test/USAGE\", \"lib/rails_generator/generators/components/plugin/plugin_generator.rb\", \"lib/rails_generator/generators/components/plugin/templates/generator.rb\", \"lib/rails_generator/generators/components/plugin/templates/init.rb\", \"lib/rails_generator/generators/components/plugin/templates/install.rb\", \"lib/rails_generator/generators/components/plugin/templates/MIT-LICENSE\", \"lib/rails_generator/generators/components/plugin/templates/plugin.rb\", \"lib/rails_generator/generators/components/plugin/templates/Rakefile\", \"lib/rails_generator/generators/components/plugin/templates/README\", \"lib/rails_generator/generators/components/plugin/templates/tasks.rake\", \"lib/rails_generator/generators/components/plugin/templates/test_helper.rb\", \"lib/rails_generator/generators/components/plugin/templates/uninstall.rb\", \"lib/rails_generator/generators/components/plugin/templates/unit_test.rb\", \"lib/rails_generator/generators/components/plugin/templates/USAGE\", \"lib/rails_generator/generators/components/plugin/USAGE\", \"lib/rails_generator/generators/components/resource/resource_generator.rb\", \"lib/rails_generator/generators/components/resource/templates/controller.rb\", \"lib/rails_generator/generators/components/resource/templates/functional_test.rb\", \"lib/rails_generator/generators/components/resource/templates/helper.rb\", \"lib/rails_generator/generators/components/resource/templates/helper_test.rb\", \"lib/rails_generator/gene"..., 4096) = 4096
read(3, "generator.rb\", \"lib/rails_generator/generators/components/scaffold/templates/controller.rb\", \"lib/rails_generator/generators/components/scaffold/templates/functional_test.rb\", \"lib/rails_generator/generators/components/scaffold/templates/helper.rb\", \"lib/rails_generator/generators/components/scaffold/templates/helper_test.rb\", \"lib/rails_generator/generators/components/scaffold/templates/layout.html.erb\", \"lib/rails_generator/generators/components/scaffold/templates/style.css\", \"lib/rails_generator/generators/components/scaffold/templates/view_edit.html.erb\", \"lib/rails_generator/generators/components/scaffold/templates/view_index.html.erb\", \"lib/rails_generator/generators/components/scaffold/templates/view_new.html.erb\", \"lib/rails_generator/generators/components/scaffold/templates/view_show.html.erb\", \"lib/rails_generator/generators/components/scaffold/USAGE\", \"lib/rails_generator/generators/components/session_migration/session_migration_generator.rb\", \"lib/rails_generator/generators/components/session_migration/templates/migration.rb\", \"lib/rails_generator/generators/components/session_migration/USAGE\", \"lib/rails_generator/lookup.rb\", \"lib/rails_generator/manifest.rb\", \"lib/rails_generator/options.rb\", \"lib/rails_generator/scripts/destroy.rb\", \"lib/rails_generator/scripts/generate.rb\", \"lib/rails_generator/scripts/update.rb\", \"lib/rails_generator/scripts.rb\", \"lib/rails_generator/secret_key_generator.rb\", \"lib/rails_generator/simple_logger.rb\", \"lib/rails_generator/spec.rb\", \"lib/rails_generator.rb\", \"lib/railties_path.rb\", \"lib/ruby_version_check.rb\", \"lib/rubyprof_ext.rb\", \"lib/source_annotation_extractor.rb\", \"lib/tasks/annotations.rake\", \"lib/tasks/databases.rake\", \"lib/tasks/documentation.rake\", \"lib/tasks/framework.rake\", \"lib/tasks/gems.rake\", \"lib/tasks/log.rake\", \"lib/tasks/middleware.rake\", \"lib/tasks/misc.rake\", \"lib/tasks/rails.rb\", \"lib/tasks/routes.rake\", \"lib/tasks/statistics.rake\", \"lib/tasks/testing.rake\", \"lib/tasks/tmp.rake\", \"lib/test_help.rb\", \"lib/webrick_server.rb\"]\n  s.homepage = %q{http://www.rubyonrails.org}\n  s.rdoc_options = [\"--exclude\", \".\"]\n  s.require_paths = [\"lib\"]\n  s.rubyforge_project = %q{rails}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Web-application framework with template engine, control-flow layer, and ORM.}\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 3\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<rake>, [\">= 0.8.3\"])\n      s.add_runtime_dependency(%q<activesupport>, [\"= 2.3.5\"])\n      s.add_runtime_dependency(%q<activerecord>, [\"= 2.3.5\"])\n      s.add_runtime_dependency(%q<actionpack>, [\"= 2.3.5\"])\n      s.add_runtime_dependency(%q<actionmailer>, [\"= 2.3.5\"])\n      s.add_runtime_dependency(%q<activeresource>, [\"= 2.3.5\"])\n    else\n      s.add_dependency(%q<rake>, [\">= 0.8.3\"])\n      s.add_dependency(%q<activesupport>, [\"= 2.3.5\"])\n      s.add_dependency(%q<activerecord>, [\"= 2.3.5\"])\n      s.add_dependency(%q<actionpack>, [\"= 2.3.5\"])\n      s.add_dependency(%q<actionmailer>, [\"= 2.3.5\"])\n      s.add_dependency(%q<activeresource>, [\"= 2.3.5\"])\n    end\n  else\n    s.add_dependency(%q<rake>, [\">= 0.8.3\"])\n    s.add_dependency(%q<activesupport>, [\"= 2.3.5\"])\n    s.add_dependency(%q<activerecord>, [\"= 2.3.5\"])\n    s.add_dependency(%q<actionpack>, [\"= 2.3.5\"])\n    s.add_dependency(%q<actionmailer>, [\"= 2.3.5\"])\n    s.add_dependency(%q<activeresource>, [\"= 2.3.5\"])\n  end\nend\n", 4096) = 3559
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/syntax-1.0.0.gemspec", {st_mode=S_IFREG|0644, st_size=1343, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/syntax-1.0.0.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=1343, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=1343, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{syntax}\n  s.version = \"1.0.0\"\n\n  s.required_rubygems_version = nil if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Jamis Buck\"]\n  s.autorequire = %q{syntax}\n  s.cert_chain = nil\n  s.date = %q{2005-06-18}\n  s.email = %q{jamis@jamisbuck.org}\n  s.files = [\"data/ruby.css\", \"data/xml.css\", \"data/yaml.css\", \"lib/syntax\", \"lib/syntax.rb\", \"lib/syntax/common.rb\", \"lib/syntax/convertors\", \"lib/syntax/lang\", \"lib/syntax/version.rb\", \"lib/syntax/convertors/abstract.rb\", \"lib/syntax/convertors/html.rb\", \"lib/syntax/lang/ruby.rb\", \"lib/syntax/lang/xml.rb\", \"lib/syntax/lang/yaml.rb\", \"test/ALL-TESTS.rb\", \"test/syntax\", \"test/tc_syntax.rb\", \"test/syntax/tc_ruby.rb\", \"test/syntax/tc_xml.rb\", \"test/syntax/tc_yaml.rb\", \"test/syntax/tokenizer_testcase.rb\"]\n  s.require_paths = [\"lib\"]\n  s.required_ruby_version = Gem::Requirement.new(\"> 0.0.0\")\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Syntax is Ruby library for performing simple syntax highlighting.}\n  s.test_files = [\"test/ALL-TESTS.rb\"]\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 1\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n    else\n    end\n  else\n  end\nend\n", 4096) = 1343
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/yahoo-search-1.1.1.gemspec", {st_mode=S_IFREG|0644, st_size=1501, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/yahoo-search-1.1.1.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=1501, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=1501, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{yahoo-search}\n  s.version = \"1.1.1\"\n\n  s.required_rubygems_version = nil if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Eric Hodel\"]\n  s.cert_chain = nil\n  s.date = %q{2006-11-27}\n  s.description = %q{An interface to Yahoo's Search services.}\n  s.email = %q{drbrain@segment7.net}\n  s.files = [\"History.txt\", \"LICENSE.txt\", \"Manifest.txt\", \"README.txt\", \"Rakefile\", \"lib/yahoo/local_search.rb\", \"lib/yahoo/search.rb\", \"lib/yahoo/web_search.rb\", \"test/test_local_search.rb\", \"test/test_web_search.rb\"]\n  s.homepage = %q{http://dev.robotcoop.com/Libraries/yahoo-search}\n  s.require_paths = [\"lib\"]\n  s.required_ruby_version = Gem::Requirement.new(\"> 0.0.0\")\n  s.rubyforge_project = %q{rctools}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{A Ruby Yahoo Search API Implementation}\n  s.test_files = [\"test/test_local_search.rb\", \"test/test_web_search.rb\"]\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 1\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<hoe>, [\">= 1.1.4\"])\n      s.add_runtime_dependency(%q<yahoo>, [\">= 1.1.1\"])\n    else\n      s.add_dependency(%q<hoe>, [\">= 1.1.4\"])\n      s.add_dependency(%q<yahoo>, [\">= 1.1.1\"])\n    end\n  else\n    s.add_dependency(%q<hoe>, [\">= 1.1.4\"])\n    s.add_dependency(%q<yahoo>, [\">= 1.1.1\"])\n  end\nend\n", 4096) = 1501
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/rack-1.0.1.gemspec", {st_mode=S_IFREG|0644, st_size=6702, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/rack-1.0.1.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=6702, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=6702, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{rack}\n  s.version = \"1.0.1\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Christian Neukirchen\"]\n  s.date = %q{2009-10-18}\n  s.default_executable = %q{rackup}\n  s.description = %q{Rack provides minimal, modular and adaptable interface for developing web applications in Ruby.  By wrapping HTTP requests and responses in the simplest way possible, it unifies and distills the API for web servers, web frameworks, and software in between (the so-called middleware) into a single method call.  Also see http://rack.rubyforge.org.}\n  s.email = %q{chneukirchen@gmail.com}\n  s.executables = [\"rackup\"]\n  s.extra_rdoc_files = [\"README\", \"SPEC\", \"RDOX\", \"KNOWN-ISSUES\"]\n  s.files = [\"COPYING\", \"KNOWN-ISSUES\", \"README\", \"Rakefile\", \"bin/rackup\", \"contrib/rack_logo.svg\", \"example/lobster.ru\", \"example/protectedlobster.rb\", \"example/protectedlobster.ru\", \"lib/rack.rb\", \"lib/rack/adapter/camping.rb\", \"lib/rack/auth/abstract/handler.rb\", \"lib/rack/auth/abstract/request.rb\", \"lib/rack/auth/basic.rb\", \"lib/rack/auth/digest/md5.rb\", \"lib/rack/auth/digest/nonce.rb\", \"lib/rack/auth/digest/params.rb\", \"lib/rack/auth/digest/request.rb\", \"lib/rack/auth/openid.rb\", \"lib/rack/builder.rb\", \"lib/rack/cascade.rb\", \"lib/rack/chunked.rb\", \"lib/rack/commonlogger.rb\", \"lib/rack/conditionalget.rb\", \"lib/rack/content_length.rb\", \"lib/rack/content_type.rb\", \"lib/rack/deflater.rb\", \"lib/rack/directory.rb\", \"lib/rack/file.rb\", \"lib/rack/handler.rb\", \"lib/rack/handler/cgi.rb\", \"lib/rack/handler/evented_mongrel.rb\", \"lib/rack/handler/fastcgi.rb\", \"lib/rack/handler/lsws.rb\", \"lib/rack/handler/mongrel.rb\", \"lib/rack/handler/scgi.rb\", \"lib/rack/handler/swiftiplied_mongrel.rb\", \"lib/rack/handler/thin.rb\", \"lib/rack/handler/webrick.rb\", \"lib/rack/head.rb\", \"lib/rack/lint.rb\", \"lib/rack/lobster.rb\", \"lib/rack/lock.rb\", \"lib/rack/methodoverride.rb\", \"lib/rack/mime.rb\", \"lib/rack/mock.rb\", \"lib/rack/recursive.rb\", \"lib/rack/reloader.rb\", \"lib/rack/request.rb\", \"lib/rack/response.rb\", \"lib/rack/rewindable_input.rb\", \"lib/rack/session/abstract/id.rb\", \"lib/rack/session/cookie.rb\", \"lib/rack/session/memcache.rb\", \"lib/rack/session/pool.rb\", \"lib/rack/showexceptions.rb\", \"lib/rack/showstatus.rb\", \"lib/rack/static.rb\", \"lib/rack/urlmap.rb\", \"lib/rack/utils.rb\", \"test/cgi/lighttpd.conf\", \"test/cgi/test\", \"test/cgi/test.fcgi\", \"test/cgi/test.ru\", \"test/multipart/binary\", \"test/multipart/empty\", \"test/multipart/ie\", \"test/multipart/nested\", \"test/multipart/none\", \"test/multipart/semicolon\", \"test/multipart/text\", \"test/spec_rack_auth_basic.rb\", \"test/spec_rack_auth_digest.rb\", \"test/spec_rack_auth_openid.rb\", \"test/spec_rack_builder.rb\", \"test/spec_rack_camping.rb\", \"test/spec_rack_cascade.rb\", \"test/spec_rack_cgi.rb\", \"test/spec_rack_chunked.rb\", \"test/spec_rack_commonlogger.rb\", \"test/spec_rack_conditionalget.rb\", \"test/spec_rack_content_length.rb\", \"test/spec_rack_content_type.rb\", \"test/spec_rack_deflater.rb\", \"test/spec_rack_directory.rb\", \"test/spec_rack_fastcgi.rb\", \"test/spec_rack_file.rb\", \"test/spec_rack_handler.rb\", \"test/spec_rack_head.rb\", \"test/spec_rack_lint.rb\", \"test/spec_rack_lobster.rb\", \"test/spec_rack_lock.rb\", \"test/spec_rack_methodoverride.rb\", \"test/spec_rack_mock.rb\", \"test/spec_rack_mongrel.rb\", \"test/spec_rack_recursive.rb\", \"test/spec_rack_request.rb\", \"test/spec_rack_response.rb\", \"test/spec_rack_rewindable_input.rb\", \"test/spec_rack_session_cookie.rb\", \"test/spec_rack_session_memcache.rb\", \"test/spec_rack_session_pool.rb\", \"test/spec_rack_showexceptions.rb\", \"test/spec_rack_showstatus.rb\", \"test/spec_rack_static.rb\", \"test/spec_rack_thin.rb\", \"test/spec_rack_urlmap.rb\", \"test/spec_rack_utils.rb\", \"test/spec_rack_webrick.rb\", \"test/testrequest.rb\", \"test/unregistered_handler/rack/handler/unregistered.rb\", \"test/unregistered_handler/rack/handler/unregistered_long_one.rb\", \"SPEC\", \"RDOX\", \"rack.gemspec\"]\n  s.homepag"..., 4096) = 4096
read(3, " s.rubygems_version = %q{1.3.5}\n  s.summary = %q{a modular Ruby webserver interface}\n  s.test_files = [\"test/spec_rack_auth_basic.rb\", \"test/spec_rack_auth_digest.rb\", \"test/spec_rack_auth_openid.rb\", \"test/spec_rack_builder.rb\", \"test/spec_rack_camping.rb\", \"test/spec_rack_cascade.rb\", \"test/spec_rack_cgi.rb\", \"test/spec_rack_chunked.rb\", \"test/spec_rack_commonlogger.rb\", \"test/spec_rack_conditionalget.rb\", \"test/spec_rack_content_length.rb\", \"test/spec_rack_content_type.rb\", \"test/spec_rack_deflater.rb\", \"test/spec_rack_directory.rb\", \"test/spec_rack_fastcgi.rb\", \"test/spec_rack_file.rb\", \"test/spec_rack_handler.rb\", \"test/spec_rack_head.rb\", \"test/spec_rack_lint.rb\", \"test/spec_rack_lobster.rb\", \"test/spec_rack_lock.rb\", \"test/spec_rack_methodoverride.rb\", \"test/spec_rack_mock.rb\", \"test/spec_rack_mongrel.rb\", \"test/spec_rack_recursive.rb\", \"test/spec_rack_request.rb\", \"test/spec_rack_response.rb\", \"test/spec_rack_rewindable_input.rb\", \"test/spec_rack_session_cookie.rb\", \"test/spec_rack_session_memcache.rb\", \"test/spec_rack_session_pool.rb\", \"test/spec_rack_showexceptions.rb\", \"test/spec_rack_showstatus.rb\", \"test/spec_rack_static.rb\", \"test/spec_rack_thin.rb\", \"test/spec_rack_urlmap.rb\", \"test/spec_rack_utils.rb\", \"test/spec_rack_webrick.rb\"]\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 2\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n      s.add_development_dependency(%q<test-spec>, [\">= 0\"])\n      s.add_development_dependency(%q<camping>, [\">= 0\"])\n      s.add_development_dependency(%q<fcgi>, [\">= 0\"])\n      s.add_development_dependency(%q<memcache-client>, [\">= 0\"])\n      s.add_development_dependency(%q<mongrel>, [\">= 0\"])\n      s.add_development_dependency(%q<ruby-openid>, [\"~> 2.0.0\"])\n      s.add_development_dependency(%q<thin>, [\">= 0\"])\n    else\n      s.add_dependency(%q<test-spec>, [\">= 0\"])\n      s.add_dependency(%q<camping>, [\">= 0\"])\n      s.add_dependency(%q<fcgi>, [\">= 0\"])\n      s.add_dependency(%q<memcache-client>, [\">= 0\"])\n      s.add_dependency(%q<mongrel>, [\">= 0\"])\n      s.add_dependency(%q<ruby-openid>, [\"~> 2.0.0\"])\n      s.add_dependency(%q<thin>, [\">= 0\"])\n    end\n  else\n    s.add_dependency(%q<test-spec>, [\">= 0\"])\n    s.add_dependency(%q<camping>, [\">= 0\"])\n    s.add_dependency(%q<fcgi>, [\">= 0\"])\n    s.add_dependency(%q<memcache-client>, [\">= 0\"])\n    s.add_dependency(%q<mongrel>, [\">= 0\"])\n    s.add_dependency(%q<ruby-openid>, [\"~> 2.0.0\"])\n    s.add_dependency(%q<thin>, [\">= 0\"])\n  end\nend\n", 4096) = 2606
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/rc-rest-2.2.1.gemspec", {st_mode=S_IFREG|0644, st_size=1459, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/rc-rest-2.2.1.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=1459, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=1459, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{rc-rest}\n  s.version = \"2.2.1\"\n\n  s.required_rubygems_version = nil if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Eric Hodel\"]\n  s.cert_chain = nil\n  s.date = %q{2007-01-31}\n  s.description = %q{This library makes it easy to implement REST-like web services APIs.}\n  s.email = %q{drbrain@segment7.net}\n  s.files = [\"History.txt\", \"LICENSE.txt\", \"Manifest.txt\", \"README.txt\", \"Rakefile\", \"lib/rc_rest.rb\", \"lib/rc_rest/net_http_stub.rb\", \"lib/rc_rest/uri_stub.rb\", \"test/test_rc_rest.rb\"]\n  s.homepage = %q{http://seattlerb.rubyforge.org/rc-rest}\n  s.require_paths = [\"lib\"]\n  s.required_ruby_version = Gem::Requirement.new(\"> 0.0.0\")\n  s.rubyforge_project = %q{seattlerb}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Robot Co-op REST web services base class}\n  s.test_files = [\"test/test_rc_rest.rb\"]\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 1\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<ZenTest>, [\">= 3.4.2\"])\n      s.add_runtime_dependency(%q<hoe>, [\">= 1.1.7\"])\n    else\n      s.add_dependency(%q<ZenTest>, [\">= 3.4.2\"])\n      s.add_dependency(%q<hoe>, [\">= 1.1.7\"])\n    end\n  else\n    s.add_dependency(%q<ZenTest>, [\">= 3.4.2\"])\n    s.add_dependency(%q<hoe>, [\">= 1.1.7\"])\n  end\nend\n", 4096) = 1459
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/gemcutter-0.3.0.gemspec", {st_mode=S_IFREG|0644, st_size=2555, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/gemcutter-0.3.0.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=2555, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=2555, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{gemcutter}\n  s.version = \"0.3.0\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 1.3.5\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Nick Quaranto\"]\n  s.date = %q{2010-01-05}\n  s.description = %q{Adds several commands to RubyGems for managing gems and more on Gemcutter.org.}\n  s.email = %q{nick@quaran.to}\n  s.files = [\"MIT-LICENSE\", \"Rakefile\", \"lib/commands/abstract_command.rb\", \"lib/commands/migrate.rb\", \"lib/commands/owner.rb\", \"lib/commands/push.rb\", \"lib/commands/tumble.rb\", \"lib/commands/webhook.rb\", \"lib/rubygems_plugin.rb\", \"test/abstract_command_test.rb\", \"test/command_helper.rb\", \"test/push_command_test.rb\", \"test/webhook_command_test.rb\"]\n  s.homepage = %q{http://gemcutter.org}\n  s.post_install_message = %q{\n========================================================================\n\n           Thanks for installing Gemcutter! You can now run:\n\n    gem push          publish your gems for the world to use and enjoy\n    gem owner         allow/disallow others to push to your gems\n    gem webhook       register urls to be pinged when gems are pushed\n\n========================================================================\n\n}\n  s.rdoc_options = [\"--charset=UTF-8\"]\n  s.require_paths = [\"lib\"]\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Commands to interact with gemcutter.org}\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 3\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<json_pure>, [\">= 0\"])\n      s.add_development_dependency(%q<rake>, [\">= 0\"])\n      s.add_development_dependency(%q<shoulda>, [\">= 0\"])\n      s.add_development_dependency(%q<activesupport>, [\">= 0\"])\n      s.add_development_dependency(%q<webmock>, [\">= 0\"])\n      s.add_development_dependency(%q<rr>, [\">= 0\"])\n    else\n      s.add_dependency(%q<json_pure>, [\">= 0\"])\n      s.add_dependency(%q<rake>, [\">= 0\"])\n      s.add_dependency(%q<shoulda>, [\">= 0\"])\n      s.add_dependency(%q<activesupport>, [\">= 0\"])\n      s.add_dependency(%q<webmock>, [\">= 0\"])\n      s.add_dependency(%q<rr>, [\">= 0\"])\n    end\n  else\n    s.add_dependency(%q<json_pure>, [\">= 0\"])\n    s.add_dependency(%q<rake>, [\">= 0\"])\n    s.add_dependency(%q<shoulda>, [\">= 0\"])\n    s.add_dependency(%q<activesupport>, [\">= 0\"])\n    s.add_dependency(%q<webmock>, [\">= 0\"])\n    s.add_dependency(%q<rr>, [\">= 0\"])\n  end\nend\n", 4096) = 2555
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/actionmailer-2.3.5.gemspec", {st_mode=S_IFREG|0644, st_size=6031, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/actionmailer-2.3.5.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=6031, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=6031, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{actionmailer}\n  s.version = \"2.3.5\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"David Heinemeier Hansson\"]\n  s.autorequire = %q{action_mailer}\n  s.date = %q{2009-11-26}\n  s.description = %q{Makes it trivial to test and deliver emails sent from a single service layer.}\n  s.email = %q{david@loudthinking.com}\n  s.files = [\"Rakefile\", \"install.rb\", \"README\", \"CHANGELOG\", \"MIT-LICENSE\", \"lib/action_mailer/adv_attr_accessor.rb\", \"lib/action_mailer/base.rb\", \"lib/action_mailer/helpers.rb\", \"lib/action_mailer/mail_helper.rb\", \"lib/action_mailer/part.rb\", \"lib/action_mailer/part_container.rb\", \"lib/action_mailer/quoting.rb\", \"lib/action_mailer/test_case.rb\", \"lib/action_mailer/test_helper.rb\", \"lib/action_mailer/utils.rb\", \"lib/action_mailer/vendor/text-format-0.6.3/text/format.rb\", \"lib/action_mailer/vendor/text_format.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/address.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/attachments.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/base64.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/compat.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/config.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/core_extensions.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/encode.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/header.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/index.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/interface.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/loader.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/mail.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/mailbox.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/main.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/mbox.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/net.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/obsolete.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/parser.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/port.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/quoting.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/require_arch.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/scanner.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/scanner_r.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/stringio.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/utils.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail/version.rb\", \"lib/action_mailer/vendor/tmail-1.2.3/tmail.rb\", \"lib/action_mailer/vendor/tmail.rb\", \"lib/action_mailer/version.rb\", \"lib/action_mailer.rb\", \"lib/actionmailer.rb\", \"test/abstract_unit.rb\", \"test/asset_host_test.rb\", \"test/delivery_method_test.rb\", \"test/fixtures/asset_host_mailer/email_with_asset.html.erb\", \"test/fixtures/auto_layout_mailer/hello.html.erb\", \"test/fixtures/auto_layout_mailer/multipart.text.html.erb\", \"test/fixtures/auto_layout_mailer/multipart.text.plain.erb\", \"test/fixtures/explicit_layout_mailer/logout.html.erb\", \"test/fixtures/explicit_layout_mailer/signup.html.erb\", \"test/fixtures/first_mailer/share.erb\", \"test/fixtures/helper_mailer/use_example_helper.erb\", \"test/fixtures/helper_mailer/use_helper.erb\", \"test/fixtures/helper_mailer/use_helper_method.erb\", \"test/fixtures/helper_mailer/use_mail_helper.erb\", \"test/fixtures/helpers/example_helper.rb\", \"test/fixtures/layouts/auto_layout_mailer.html.erb\", \"test/fixtures/layouts/auto_layout_mailer.text.erb\", \"test/fixtures/layouts/spam.html.erb\", \"test/fixtures/path.with.dots/funky_path_mailer/multipart_with_template_path_with_dots.erb\", \"test/fixtures/raw_email\", \"test/fixtures/raw_email10\", \"test/fixtures/raw_email12\", \"test/fixtures/raw_email13\", \"test/fixtures/raw_email2\", \"test/fixtures/raw_email3\", \"test/fixtures/raw_email4\", \"test/fixtures/raw_email5\", \"test/fixtures/raw_email6\", \"test/fixtures/raw_email7\", \"test/fixtures/raw_email8\", \"test/fixtures/raw_email9\", \"test/fixtures/raw_email_quoted_with_0d0a\", \"test/fixtures/raw_email_with_invalid_chara"..., 4096) = 4096
read(3, "il_with_partially_quoted_subject\", \"test/fixtures/second_mailer/share.erb\", \"test/fixtures/templates/signed_up.erb\", \"test/fixtures/test_mailer/_subtemplate.text.plain.erb\", \"test/fixtures/test_mailer/body_ivar.erb\", \"test/fixtures/test_mailer/custom_templating_extension.text.html.haml\", \"test/fixtures/test_mailer/custom_templating_extension.text.plain.haml\", \"test/fixtures/test_mailer/implicitly_multipart_example.ignored.erb\", \"test/fixtures/test_mailer/implicitly_multipart_example.rhtml.bak\", \"test/fixtures/test_mailer/implicitly_multipart_example.text.html.erb\", \"test/fixtures/test_mailer/implicitly_multipart_example.text.html.erb~\", \"test/fixtures/test_mailer/implicitly_multipart_example.text.plain.erb\", \"test/fixtures/test_mailer/implicitly_multipart_example.text.yaml.erb\", \"test/fixtures/test_mailer/included_subtemplate.text.plain.erb\", \"test/fixtures/test_mailer/rxml_template.builder\", \"test/fixtures/test_mailer/rxml_template.rxml\", \"test/fixtures/test_mailer/signed_up.html.erb\", \"test/fixtures/test_mailer/signed_up_with_url.erb\", \"test/mail_helper_test.rb\", \"test/mail_layout_test.rb\", \"test/mail_render_test.rb\", \"test/mail_service_test.rb\", \"test/quoting_test.rb\", \"test/test_helper_test.rb\", \"test/tmail_test.rb\", \"test/url_test.rb\"]\n  s.homepage = %q{http://www.rubyonrails.org}\n  s.require_paths = [\"lib\"]\n  s.requirements = [\"none\"]\n  s.rubyforge_project = %q{actionmailer}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{Service layer for easy email delivery and testing.}\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 3\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<actionpack>, [\"= 2.3.5\"])\n    else\n      s.add_dependency(%q<actionpack>, [\"= 2.3.5\"])\n    end\n  else\n    s.add_dependency(%q<actionpack>, [\"= 2.3.5\"])\n  end\nend\n", 4096) = 1935
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/mongrel-1.1.5.gemspec", {st_mode=S_IFREG|0644, st_size=6992, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/mongrel-1.1.5.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=6992, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=6992, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{mongrel}\n  s.version = \"1.1.5\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Zed A. Shaw\"]\n  s.cert_chain = [\"-----BEGIN CERTIFICATE-----\\nMIIDUDCCAjigAwIBAgIBADANBgkqhkiG9w0BAQUFADBOMRwwGgYDVQQDDBNtb25n\\ncmVsLWRldmVsb3BtZW50MRkwFwYKCZImiZPyLGQBGRYJcnVieWZvcmdlMRMwEQYK\\nCZImiZPyLGQBGRYDb3JnMB4XDTA3MDkxNjEwMzI0OVoXDTA4MDkxNTEwMzI0OVow\\nTjEcMBoGA1UEAwwTbW9uZ3JlbC1kZXZlbG9wbWVudDEZMBcGCgmSJomT8ixkARkW\\nCXJ1Ynlmb3JnZTETMBEGCgmSJomT8ixkARkWA29yZzCCASIwDQYJKoZIhvcNAQEB\\nBQADggEPADCCAQoCggEBAMb9v3B01eOHk3FyypbQgKXzJplUE5P6dXoG+xpPm0Lv\\nP7BQmeMncOwqQ7zXpVQU+lTpXtQFTsOE3vL7KnhQFJKGvUAkbh24VFyopu1I0yqF\\nmGu4nRqNXGXVj8TvLSj4S1WpSRLAa0acLPNyKhGmoV9+crqQypSjM6XKjBeppifo\\n4eBmWGjiJEYMIJBvJZPJ4rAVDDA8C6CM1m3gMBGNh8ELDhU8HI9AP3dMIkTI2Wx9\\n9xkJwHdroAaS0IFFtYChrwee4FbCF1FHDgoTosMwa47DrLHg4hZ6ojaKwK5QVWEV\\nXGb6ju5UqpktnSWF2W+Lvl/K0tI42OH2CAhebT1gEVUCAwEAAaM5MDcwCQYDVR0T\\nBAIwADALBgNVHQ8EBAMCBLAwHQYDVR0OBBYEFGHChyMSZ16u9WOzKhgJSQ9lqDc5\\nMA0GCSqGSIb3DQEBBQUAA4IBAQA/lfeN2WdB1xN+82tT7vNS4HOjRQw6MUh5yktu\\nGQjaGqm0UB+aX0Z9y0B0qpfv9rj7nmIvEGiwBmDepNWYCGuW15JyqpN7QVVnG2xS\\nMrame7VqgjM7A+VGDD5In5LtWbM/CHAATvvFlQ5Ph13YE1EdnVbZ65c+KQv+5sFY\\nQ+zEop74d878uaC/SAHHXS46TiXneocaLSYw1CEZs/MAIy+9c4Q5ESbGpgnfg1Ad\\n6lwl7k3hsNHO/+tZzx4HJtOXDI1yAl3+q6T9J0yI3z97EinwvAKhS1eyOI2Y5eeT\\ntbQaNYkU127B3l/VNpd8fQm3Jkl/PqCCmDBQjUszFrJEODug\\n-----END CERTIFICATE-----\\n\", \"-----BEGIN CERTIFICATE-----\\nMIIDPzCCAiegAwIBAgIBADANBgkqhkiG9w0BAQUFADBOMRwwGgYDVQQDDBNtb25n\\ncmVsLWRldmVsb3BtZW50MRkwFwYKCZImiZPyLGQBGRYJcnVieWZvcmdlMRMwEQYK\\nCZImiZPyLGQBGRYDb3JnMB4XDTA3MDkxNjEwMzMwMFoXDTA4MDkxNTEwMzMwMFow\\nPTENMAsGA1UEAwwEZXZhbjEYMBYGCgmSJomT8ixkARkWCGNsb3VkYnVyMRIwEAYK\\nCZImiZPyLGQBGRYCc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDk\\nLQijz2fICmev4+9s0WB71WzJFYCUYFQQxqGlenbxWut9dlPSsBbskGjg+UITeOXi\\ncTh3MTqAB0i1LJyNOiyvDsAivn7GjKXhVvflp2/npMhBBe83P4HOWqeQBjkk3QJI\\nFFNBvqbFLeEXIP+HiqAOiyNHZEVXMepLEJLzGrg3Ly7M7A6L5fK7jDrt8jkm+c+8\\nzGquVHV5ohAebGd/vpHMLjpA7lCG5+MBgYZd33rRfNtCxDJMNRgnOu9PsB05+LJn\\nMpDKQq3x0SkOf5A+MVOcadNCaAkFflYk3SUcXaXWxu/eCHgqfW1m76RNSp5djpKE\\nCgNPK9lGIWpB3CHzDaVNAgMBAAGjOTA3MAkGA1UdEwQCMAAwCwYDVR0PBAQDAgSw\\nMB0GA1UdDgQWBBT5aonPfFBdJ5rWFG+8dZwgyB54LjANBgkqhkiG9w0BAQUFAAOC\\nAQEAiKbzWgMcvZs/TPwJxr8tJ+7mSGz7+zDkWcbBl8FpQq1DtRcATh1oyTkQT7t+\\nrFEBYMmb0FxbbUnojQp8hIFgFkUwFpStwWBL/okLSehntzI2iwjuEtfj4ac9Q3Y2\\nuSdbmZqsQTuu+lEUc5C4qLK7YKwToaul+cx7vWxyk1YendcVwRlFLIBqA5cPrwo3\\nyyGLTHlRYn2c9PSbM1B63Yg+LqSSAa4QSU3Wv9pNdffVpvwHPVEQpO7ZDo5slQFL\\nGf6+gbD/eZAvhpvmn8JlXb+LxKaFVMs2Yvrk1xOuT76SsPjEGWxkr7jZCIpsYfgQ\\nALN3mi/9z0Mf1YroliUgF0v5Yw==\\n-----END CERTIFICATE-----\\n\"]\n  s.date = %q{2008-05-22}\n  s.default_executable = %q{mongrel_rails}\n  s.description = %q{A small fast HTTP library and server that runs Rails, Camping, Nitro and Iowa apps.}\n  s.email = %q{}\n  s.executables = [\"mongrel_rails\"]\n  s.extensions = [\"ext/http11/extconf.rb\"]\n  s.extra_rdoc_files = [\"CHANGELOG\", \"COPYING\", \"lib/mongrel/camping.rb\", \"lib/mongrel/cgi.rb\", \"lib/mongrel/command.rb\", \"lib/mongrel/configurator.rb\", \"lib/mongrel/const.rb\", \"lib/mongrel/debug.rb\", \"lib/mongrel/gems.rb\", \"lib/mongrel/handlers.rb\", \"lib/mongrel/header_out.rb\", \"lib/mongrel/http_request.rb\", \"lib/mongrel/http_response.rb\", \"lib/mongrel/init.rb\", \"lib/mongrel/rails.rb\", \"lib/mongrel/stats.rb\", \"lib/mongrel/tcphack.rb\", \"lib/mongrel/uri_classifier.rb\", \"lib/mongrel.rb\", \"LICENSE\", \"README\"]\n  s.files = [\"bin/mongrel_rails\", \"CHANGELOG\", \"COPYING\", \"examples/builder.rb\", \"examples/camping/blog.rb\", \"examples/camping/README\", \"examples/camping/tepee.rb\", \"examples/httpd.conf\", \"examples/mime.yaml\", \"examples/mongrel.conf\", \"examples/mongrel_simple_ctrl.rb\", \"examples/mongrel_simple_service.rb\", \"examples/monitrc\", \"examples/random_thrash.rb\", \"examples/simpletest.rb\", \"examples/webrick_compare.rb\", \"ext/http11/ext_help.h\", \"ext/http11/extconf.rb\", \"ext/http11/http11.c\", \"ext/http11/http11_parser.c\","..., 4096) = 4096
read(3, ", \"ext/http11/http11_parser_common.rl\", \"ext/http11_java/Http11Service.java\", \"ext/http11_java/org/jruby/mongrel/Http11.java\", \"ext/http11_java/org/jruby/mongrel/Http11Parser.java\", \"lib/mongrel/camping.rb\", \"lib/mongrel/cgi.rb\", \"lib/mongrel/command.rb\", \"lib/mongrel/configurator.rb\", \"lib/mongrel/const.rb\", \"lib/mongrel/debug.rb\", \"lib/mongrel/gems.rb\", \"lib/mongrel/handlers.rb\", \"lib/mongrel/header_out.rb\", \"lib/mongrel/http_request.rb\", \"lib/mongrel/http_response.rb\", \"lib/mongrel/init.rb\", \"lib/mongrel/mime_types.yml\", \"lib/mongrel/rails.rb\", \"lib/mongrel/stats.rb\", \"lib/mongrel/tcphack.rb\", \"lib/mongrel/uri_classifier.rb\", \"lib/mongrel.rb\", \"LICENSE\", \"Manifest\", \"mongrel-public_cert.pem\", \"mongrel.gemspec\", \"README\", \"setup.rb\", \"test/mime.yaml\", \"test/mongrel.conf\", \"test/test_cgi_wrapper.rb\", \"test/test_command.rb\", \"test/test_conditional.rb\", \"test/test_configurator.rb\", \"test/test_debug.rb\", \"test/test_handlers.rb\", \"test/test_http11.rb\", \"test/test_redirect_handler.rb\", \"test/test_request_progress.rb\", \"test/test_response.rb\", \"test/test_stats.rb\", \"test/test_uriclassifier.rb\", \"test/test_ws.rb\", \"test/testhelp.rb\", \"TODO\", \"tools/trickletest.rb\"]\n  s.homepage = %q{http://mongrel.rubyforge.org}\n  s.rdoc_options = [\"--line-numbers\", \"--inline-source\", \"--title\", \"Mongrel\", \"--main\", \"README\"]\n  s.require_paths = [\"lib\", \"ext\"]\n  s.required_ruby_version = Gem::Requirement.new(\">= 1.8.4\")\n  s.rubyforge_project = %q{mongrel}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{A small fast HTTP library and server that runs Rails, Camping, Nitro and Iowa apps.}\n  s.test_files = [\"test/test_cgi_wrapper.rb\", \"test/test_command.rb\", \"test/test_conditional.rb\", \"test/test_configurator.rb\", \"test/test_debug.rb\", \"test/test_handlers.rb\", \"test/test_http11.rb\", \"test/test_redirect_handler.rb\", \"test/test_request_progress.rb\", \"test/test_response.rb\", \"test/test_stats.rb\", \"test/test_uriclassifier.rb\", \"test/test_ws.rb\"]\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 2\n\n    if Gem::Version.new(Gem::RubyGemsVersion) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<gem_plugin>, [\">= 0.2.3\"])\n      s.add_runtime_dependency(%q<daemons>, [\">= 1.0.3\"])\n      s.add_runtime_dependency(%q<fastthread>, [\">= 1.0.1\"])\n      s.add_runtime_dependency(%q<cgi_multipart_eof_fix>, [\">= 2.4\"])\n    else\n      s.add_dependency(%q<gem_plugin>, [\">= 0.2.3\"])\n      s.add_dependency(%q<daemons>, [\">= 1.0.3\"])\n      s.add_dependency(%q<fastthread>, [\">= 1.0.1\"])\n      s.add_dependency(%q<cgi_multipart_eof_fix>, [\">= 2.4\"])\n    end\n  else\n    s.add_dependency(%q<gem_plugin>, [\">= 0.2.3\"])\n    s.add_dependency(%q<daemons>, [\">= 1.0.3\"])\n    s.add_dependency(%q<fastthread>, [\">= 1.0.1\"])\n    s.add_dependency(%q<cgi_multipart_eof_fix>, [\">= 2.4\"])\n  end\nend\n", 4096) = 2896
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/specifications/ZenTest-4.2.1.gemspec", {st_mode=S_IFREG|0644, st_size=4244, ...}) = 0
open("/usr/lib/ruby/gems/1.8/specifications/ZenTest-4.2.1.gemspec", O_RDONLY|O_LARGEFILE) = 3
sigprocmask(SIG_BLOCK, NULL, [])        = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=4244, ...}) = 0
fstat64(3, {st_mode=S_IFREG|0644, st_size=4244, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
_llseek(3, 0, [0], SEEK_CUR)            = 0
read(3, "# -*- encoding: utf-8 -*-\n\nGem::Specification.new do |s|\n  s.name = %q{ZenTest}\n  s.version = \"4.2.1\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\") if s.respond_to? :required_rubygems_version=\n  s.authors = [\"Ryan Davis\", \"Eric Hodel\"]\n  s.cert_chain = [\"-----BEGIN CERTIFICATE-----\\nMIIDPjCCAiagAwIBAgIBADANBgkqhkiG9w0BAQUFADBFMRMwEQYDVQQDDApyeWFu\\nZC1ydWJ5MRkwFwYKCZImiZPyLGQBGRYJemVuc3BpZGVyMRMwEQYKCZImiZPyLGQB\\nGRYDY29tMB4XDTA5MDMwNjE4NTMxNVoXDTEwMDMwNjE4NTMxNVowRTETMBEGA1UE\\nAwwKcnlhbmQtcnVieTEZMBcGCgmSJomT8ixkARkWCXplbnNwaWRlcjETMBEGCgmS\\nJomT8ixkARkWA2NvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALda\\nb9DCgK+627gPJkB6XfjZ1itoOQvpqH1EXScSaba9/S2VF22VYQbXU1xQXL/WzCkx\\ntaCPaLmfYIaFcHHCSY4hYDJijRQkLxPeB3xbOfzfLoBDbjvx5JxgJxUjmGa7xhcT\\noOvjtt5P8+GSK9zLzxQP0gVLS/D0FmoE44XuDr3iQkVS2ujU5zZL84mMNqNB1znh\\nGiadM9GHRaDiaxuX0cIUBj19T01mVE2iymf9I6bEsiayK/n6QujtyCbTWsAS9Rqt\\nqhtV7HJxNKuPj/JFH0D2cswvzznE/a5FOYO68g+YCuFi5L8wZuuM8zzdwjrWHqSV\\ngBEfoTEGr7Zii72cx+sCAwEAAaM5MDcwCQYDVR0TBAIwADALBgNVHQ8EBAMCBLAw\\nHQYDVR0OBBYEFEfFe9md/r/tj/Wmwpy+MI8d9k/hMA0GCSqGSIb3DQEBBQUAA4IB\\nAQAY59gYvDxqSqgC92nAP9P8dnGgfZgLxP237xS6XxFGJSghdz/nI6pusfCWKM8m\\nvzjjH2wUMSSf3tNudQ3rCGLf2epkcU13/rguI88wO6MrE0wi4ZqLQX+eZQFskJb/\\nw6x9W1ur8eR01s397LSMexySDBrJOh34cm2AlfKr/jokKCTwcM0OvVZnAutaovC0\\nl1SVZ0ecg88bsWHA0Yhh7NFxK1utWoIhtB6AFC/+trM0FQEB/jZkIS8SaNzn96Rl\\nn0sZEf77FLf5peR8TP/PtmIg7Cyqz23sLM4mCOoTGIy5OcZ8TdyiyINUHtb5ej/T\\nFBHgymkyj/AOSqKRIpXPhjC6\\n-----END CERTIFICATE-----\\n\"]\n  s.date = %q{2009-12-09}\n  s.description = %q{ZenTest provides 4 different tools: zentest, unit_diff, autotest, and\nmultiruby.\n\nZenTest scans your target and unit-test code and writes your missing\ncode based on simple naming rules, enabling XP at a much quicker\npace. ZenTest only works with Ruby and Test::Unit. Nobody uses this\ntool anymore but it is the package namesake, so it stays.\n\nunit_diff is a command-line filter to diff expected results from\nactual results and allow you to quickly see exactly what is wrong.\n\nautotest is a continous testing facility meant to be used during\ndevelopment. As soon as you save a file, autotest will run the\ncorresponding dependent tests.\n\nmultiruby runs anything you want on multiple versions of ruby. Great\nfor compatibility checking! Use multiruby_setup to manage your\ninstalled versions.}\n  s.email = [\"ryand-ruby@zenspider.com\", \"drbrain@segment7.net\"]\n  s.executables = [\"autotest\", \"multigem\", \"multiruby\", \"multiruby_setup\", \"unit_diff\", \"zentest\"]\n  s.extra_rdoc_files = [\"History.txt\", \"Manifest.txt\", \"README.txt\", \"articles/how_to_use_zentest.txt\", \"example.txt\"]\n  s.files = [\".autotest\", \"History.txt\", \"Manifest.txt\", \"README.txt\", \"Rakefile\", \"articles/Article.css\", \"articles/getting_started_with_autotest.html\", \"articles/how_to_use_zentest.txt\", \"bin/autotest\", \"bin/multigem\", \"bin/multiruby\", \"bin/multiruby_setup\", \"bin/unit_diff\", \"bin/zentest\", \"example.txt\", \"example1.rb\", \"example2.rb\", \"example_dot_autotest.rb\", \"lib/autotest.rb\", \"lib/autotest/autoupdate.rb\", \"lib/autotest/once.rb\", \"lib/autotest/rcov.rb\", \"lib/autotest/restart.rb\", \"lib/autotest/timestamp.rb\", \"lib/focus.rb\", \"lib/functional_test_matrix.rb\", \"lib/multiruby.rb\", \"lib/unit_diff.rb\", \"lib/zentest.rb\", \"lib/zentest_mapping.rb\", \"test/test_autotest.rb\", \"test/test_focus.rb\", \"test/test_unit_diff.rb\", \"test/test_zentest.rb\", \"test/test_zentest_mapping.rb\"]\n  s.homepage = %q{http://www.zenspider.com/ZSS/Products/ZenTest/}\n  s.rdoc_options = [\"--main\", \"README.txt\"]\n  s.require_paths = [\"lib\"]\n  s.rubyforge_project = %q{zentest}\n  s.rubygems_version = %q{1.3.5}\n  s.summary = %q{ZenTest provides 4 different tools: zentest, unit_diff, autotest, and multiruby}\n  s.test_files = [\"test/test_autotest.rb\", \"test/test_focus.rb\", \"test/test_unit_diff.rb\", \"test/test_zentest.rb\", \"test/test_zentest_mapping.rb\"]\n\n  if s.respond_to? :specification_version then\n    current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n    s.specification_version = 3\n\n    if Gem::Versio"..., 4096) = 4096
read(3, "(%q<hoe>, [\">= 2.4.0\"])\n    else\n      s.add_dependency(%q<hoe>, [\">= 2.4.0\"])\n    end\n  else\n    s.add_dependency(%q<hoe>, [\">= 2.4.0\"])\n  end\nend\n", 4096) = 148
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=1799, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/home/davidw/.gem/ruby/1.8/specifications", O_RDONLY|O_NONBLOCK|O_LARGEFILE|O_DIRECTORY|O_CLOEXEC) = 3
getdents64(3, /* 2 entries */, 32768)   = 48
getdents64(3, /* 0 entries */, 32768)   = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/ZenTest-4.2.1", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/actionmailer-2.3.5", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/actionpack-2.3.5", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/activerecord-2.3.5", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/activeresource-2.3.5", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/activesupport-2.3.5", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/cgi_multipart_eof_fix-2.5.0", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/daemons-1.0.10", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/fastthread-1.0.7", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gem_plugin-0.2.3", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/hoe-2.5.0", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/hpricot-0.8.2", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/json_pure-1.2.0", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/maruku-0.6.0", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/minitest-1.5.0", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/mongrel-1.1.5", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/mongrel_cluster-1.0.5", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/nokogiri-1.4.1", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/passenger-2.2.8", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/rack-1.0.1", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/rails-2.3.5", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/rake-0.8.7", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/rc-rest-3.0.0", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/rc-rest-2.2.1", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/rubyforge-2.0.3", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/syntax-1.0.0", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/will_paginate-2.3.11", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/xml-simple-1.0.12", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/yahoo-1.1.1", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/yahoo-search-1.1.1", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/ZenTest-4.2.1/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/ZenTest-4.2.1/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/ZenTest-4.2.1/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/ZenTest-4.2.1/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/ZenTest-4.2.1/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/ZenTest-4.2.1/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/ZenTest-4.2.1/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/ZenTest-4.2.1/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/actionmailer-2.3.5/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/actionmailer-2.3.5/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/actionmailer-2.3.5/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/actionmailer-2.3.5/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/actionmailer-2.3.5/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/actionmailer-2.3.5/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/actionmailer-2.3.5/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/actionmailer-2.3.5/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/actionpack-2.3.5/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/actionpack-2.3.5/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/actionpack-2.3.5/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/actionpack-2.3.5/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/actionpack-2.3.5/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/actionpack-2.3.5/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/actionpack-2.3.5/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/actionpack-2.3.5/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/activerecord-2.3.5/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activerecord-2.3.5/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activerecord-2.3.5/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activerecord-2.3.5/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activerecord-2.3.5/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activerecord-2.3.5/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activerecord-2.3.5/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activerecord-2.3.5/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/activeresource-2.3.5/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activeresource-2.3.5/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activeresource-2.3.5/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activeresource-2.3.5/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activeresource-2.3.5/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activeresource-2.3.5/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activeresource-2.3.5/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activeresource-2.3.5/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/activesupport-2.3.5/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activesupport-2.3.5/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activesupport-2.3.5/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activesupport-2.3.5/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activesupport-2.3.5/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activesupport-2.3.5/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activesupport-2.3.5/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/activesupport-2.3.5/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/cgi_multipart_eof_fix-2.5.0/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/cgi_multipart_eof_fix-2.5.0/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/cgi_multipart_eof_fix-2.5.0/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/cgi_multipart_eof_fix-2.5.0/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/cgi_multipart_eof_fix-2.5.0/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/cgi_multipart_eof_fix-2.5.0/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/cgi_multipart_eof_fix-2.5.0/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/cgi_multipart_eof_fix-2.5.0/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/daemons-1.0.10/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/daemons-1.0.10/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/daemons-1.0.10/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/daemons-1.0.10/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/daemons-1.0.10/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/daemons-1.0.10/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/daemons-1.0.10/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/daemons-1.0.10/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/fastthread-1.0.7/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/fastthread-1.0.7/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/fastthread-1.0.7/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/fastthread-1.0.7/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/fastthread-1.0.7/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/fastthread-1.0.7/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/fastthread-1.0.7/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/fastthread-1.0.7/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/fastthread-1.0.7/ext/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/fastthread-1.0.7/ext/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/fastthread-1.0.7/ext/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/fastthread-1.0.7/ext/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/fastthread-1.0.7/ext/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/fastthread-1.0.7/ext/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/fastthread-1.0.7/ext/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/fastthread-1.0.7/ext/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/gem_plugin-0.2.3/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/gem_plugin-0.2.3/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/gem_plugin-0.2.3/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/gem_plugin-0.2.3/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/gem_plugin-0.2.3/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/gem_plugin-0.2.3/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/gem_plugin-0.2.3/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/gem_plugin-0.2.3/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin.rb", {st_mode=S_IFREG|0644, st_size=309, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin.rb", {st_mode=S_IFREG|0644, st_size=309, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/hoe-2.5.0/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/hoe-2.5.0/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/hoe-2.5.0/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/hoe-2.5.0/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/hoe-2.5.0/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/hoe-2.5.0/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/hoe-2.5.0/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/hoe-2.5.0/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/hpricot-0.8.2/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/hpricot-0.8.2/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/hpricot-0.8.2/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/hpricot-0.8.2/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/hpricot-0.8.2/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/hpricot-0.8.2/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/hpricot-0.8.2/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/hpricot-0.8.2/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/ext/json/ext/rubygems_plugin", 0xbfe4f170) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/ext/json/ext/rubygems_plugin.rb", 0xbfe4f170) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/ext/json/ext/rubygems_plugin.rbw", 0xbfe4f170) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/ext/json/ext/rubygems_plugin.so", 0xbfe4f170) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/ext/json/ext/rubygems_plugin.bundle", 0xbfe4f170) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/ext/json/ext/rubygems_plugin.dll", 0xbfe4f170) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/ext/json/ext/rubygems_plugin.sl", 0xbfe4f170) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/ext/json/ext/rubygems_plugin.jar", 0xbfe4f170) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/ext/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/ext/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/ext/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/ext/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/ext/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/ext/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/ext/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/ext/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json-1.2.0/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/json_pure-1.2.0/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json_pure-1.2.0/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json_pure-1.2.0/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json_pure-1.2.0/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json_pure-1.2.0/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json_pure-1.2.0/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json_pure-1.2.0/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/json_pure-1.2.0/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/maruku-0.6.0/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/maruku-0.6.0/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/maruku-0.6.0/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/maruku-0.6.0/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/maruku-0.6.0/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/maruku-0.6.0/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/maruku-0.6.0/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/maruku-0.6.0/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/minitest-1.5.0/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/minitest-1.5.0/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/minitest-1.5.0/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/minitest-1.5.0/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/minitest-1.5.0/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/minitest-1.5.0/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/minitest-1.5.0/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/minitest-1.5.0/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel-1.1.5/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel-1.1.5/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel-1.1.5/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel-1.1.5/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel-1.1.5/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel-1.1.5/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel-1.1.5/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel-1.1.5/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel-1.1.5/ext/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel-1.1.5/ext/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel-1.1.5/ext/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel-1.1.5/ext/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel-1.1.5/ext/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel-1.1.5/ext/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel-1.1.5/ext/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel-1.1.5/ext/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel_cluster-1.0.5/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel_cluster-1.0.5/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel_cluster-1.0.5/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel_cluster-1.0.5/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel_cluster-1.0.5/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel_cluster-1.0.5/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel_cluster-1.0.5/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/mongrel_cluster-1.0.5/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/nokogiri-1.4.1/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/nokogiri-1.4.1/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/nokogiri-1.4.1/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/nokogiri-1.4.1/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/nokogiri-1.4.1/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/nokogiri-1.4.1/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/nokogiri-1.4.1/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/nokogiri-1.4.1/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/nokogiri-1.4.1/ext/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/nokogiri-1.4.1/ext/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/nokogiri-1.4.1/ext/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/nokogiri-1.4.1/ext/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/nokogiri-1.4.1/ext/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/nokogiri-1.4.1/ext/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/nokogiri-1.4.1/ext/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/nokogiri-1.4.1/ext/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/passenger-2.2.8/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/passenger-2.2.8/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/passenger-2.2.8/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/passenger-2.2.8/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/passenger-2.2.8/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/passenger-2.2.8/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/passenger-2.2.8/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/passenger-2.2.8/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/passenger-2.2.8/ext/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/passenger-2.2.8/ext/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/passenger-2.2.8/ext/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/passenger-2.2.8/ext/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/passenger-2.2.8/ext/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/passenger-2.2.8/ext/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/passenger-2.2.8/ext/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/passenger-2.2.8/ext/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/rack-1.0.1/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rack-1.0.1/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rack-1.0.1/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rack-1.0.1/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rack-1.0.1/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rack-1.0.1/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rack-1.0.1/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rack-1.0.1/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/rails-2.3.5/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rails-2.3.5/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rails-2.3.5/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rails-2.3.5/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rails-2.3.5/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rails-2.3.5/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rails-2.3.5/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rails-2.3.5/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/rake-0.8.7/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rake-0.8.7/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rake-0.8.7/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rake-0.8.7/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rake-0.8.7/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rake-0.8.7/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rake-0.8.7/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rake-0.8.7/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/rc-rest-3.0.0/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rc-rest-3.0.0/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rc-rest-3.0.0/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rc-rest-3.0.0/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rc-rest-3.0.0/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rc-rest-3.0.0/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rc-rest-3.0.0/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rc-rest-3.0.0/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/rc-rest-2.2.1/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rc-rest-2.2.1/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rc-rest-2.2.1/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rc-rest-2.2.1/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rc-rest-2.2.1/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rc-rest-2.2.1/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rc-rest-2.2.1/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rc-rest-2.2.1/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/rubyforge-2.0.3/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rubyforge-2.0.3/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rubyforge-2.0.3/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rubyforge-2.0.3/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rubyforge-2.0.3/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rubyforge-2.0.3/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rubyforge-2.0.3/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/rubyforge-2.0.3/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/syntax-1.0.0/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/syntax-1.0.0/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/syntax-1.0.0/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/syntax-1.0.0/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/syntax-1.0.0/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/syntax-1.0.0/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/syntax-1.0.0/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/syntax-1.0.0/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/will_paginate-2.3.11/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/will_paginate-2.3.11/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/will_paginate-2.3.11/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/will_paginate-2.3.11/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/will_paginate-2.3.11/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/will_paginate-2.3.11/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/will_paginate-2.3.11/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/will_paginate-2.3.11/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/xml-simple-1.0.12/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/xml-simple-1.0.12/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/xml-simple-1.0.12/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/xml-simple-1.0.12/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/xml-simple-1.0.12/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/xml-simple-1.0.12/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/xml-simple-1.0.12/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/xml-simple-1.0.12/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/yahoo-1.1.1/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/yahoo-1.1.1/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/yahoo-1.1.1/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/yahoo-1.1.1/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/yahoo-1.1.1/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/yahoo-1.1.1/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/yahoo-1.1.1/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/yahoo-1.1.1/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/yahoo-search-1.1.1/lib/rubygems_plugin", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/yahoo-search-1.1.1/lib/rubygems_plugin.rb", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/yahoo-search-1.1.1/lib/rubygems_plugin.rbw", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/yahoo-search-1.1.1/lib/rubygems_plugin.so", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/yahoo-search-1.1.1/lib/rubygems_plugin.bundle", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/yahoo-search-1.1.1/lib/rubygems_plugin.dll", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/yahoo-search-1.1.1/lib/rubygems_plugin.sl", 0xbfe4f350) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/yahoo-search-1.1.1/lib/rubygems_plugin.jar", 0xbfe4f350) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin", 0xbfe504e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin.rb", {st_mode=S_IFREG|0644, st_size=309, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
lstat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin.rbw", 0xbfe504e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin.so", 0xbfe504e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin.bundle", 0xbfe504e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin.dll", 0xbfe504e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin.sl", 0xbfe504e0) = -1 ENOENT (No such file or directory)
lstat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin.jar", 0xbfe504e0) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin.rb", {st_mode=S_IFREG|0644, st_size=309, ...}) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=309, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems_plugin.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=309, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "$:.unshift File.dirname(__FILE__)     # For use/testing when no gem is installed\n\nrequire 'rubygems/command_manager'\nrequire 'commands/abstract_command'\n\n%w[migrate owner push tumble webhook].each do |command|\n  require \"commands/#{command}\"\n  Gem::CommandManager.instance.register_command command.to_sym\nend\n", 4096) = 309
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/command_manager.rb", 0xbfe515d0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/command_manager.so", 0xbfe515d0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/command_manager.rb", {st_mode=S_IFREG|0644, st_size=4292, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/command_manager.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=4292, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/command_manager.rb", 0xbfe515e0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/command_manager.rb", {st_mode=S_IFREG|0644, st_size=4292, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/command_manager.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=4292, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/command_manager.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=4292, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/command_manager.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/command_manager.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=4292, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\nrequire 'timeout'\nrequire 'rubygems/command'\nrequire 'rubygems/user_interaction'\n\n##\n# The command manager registers and installs all the individual sub-commands\n# supported by the gem command.\n#\n# Extra commands can be provided by writing a rubygems_plugin.rb\n# file in an installed gem.  You should register your command against the\n# Gem::CommandManager instance, like this:\n#\n#   # file rubygems_plugin.rb\n#   require 'rubygems/command_manager'\n#\n#   class Gem::Commands::EditCommand < Gem::Command\n#     # ...\n#   end\n#\n#   Gem::CommandManager.instance.register_command :edit\n#\n# See Gem::Command for instructions on writing gem commands.\n\nclass Gem::CommandManager\n\n  include Gem::UserInteraction\n\n  ##\n  # Return the authoritative instance of the command manager.\n\n  def self.instance\n    @command_manager ||= new\n  end\n\n  ##\n  # Register all the subcommands supported by the gem command.\n\n  def initialize\n    @commands = {}\n    register_command :build\n    register_command :cert\n    register_command :check\n    register_command :cleanup\n    register_command :contents\n    register_command :dependency\n    register_command :environment\n    register_command :fetch\n    register_command :generate_index\n    register_command :help\n    register_command :install\n    register_command :list\n    register_command :lock\n    register_command :mirror\n    register_command :outdated\n    register_command :pristine\n    register_command :query\n    register_command :rdoc\n    register_command :search\n    register_command :server\n    register_command :sources\n    register_command :specification\n    register_command :stale\n    register_command :uninstall\n    register_command :unpack\n    register_command :update\n    register_command :which\n  end\n\n  ##\n  # Register the command object.\n\n  def register_command(command_obj)\n    @commands[command_obj] = false\n  end\n\n  ##\n  # Return the registered command from the command name.\n\n  def [](command_name)\n    command_name = command_name.intern\n    return nil if @commands[command_name].nil?\n    @commands[command_name] ||= load_and_instantiate(command_name)\n  end\n\n  ##\n  # Return a sorted list of all command names (as strings).\n\n  def command_names\n    @commands.keys.collect {|key| key.to_s}.sort\n  end\n\n  ##\n  # Run the config specified by +args+.\n\n  def run(args)\n    process_args(args)\n  rescue StandardError, Timeout::Error => ex\n    alert_error \"While executing gem ... (#{ex.class})\\n    #{ex.to_s}\"\n    ui.errs.puts \"\\t#{ex.backtrace.join \"\\n\\t\"}\" if\n      Gem.configuration.backtrace\n    terminate_interaction(1)\n  rescue Interrupt\n    alert_error \"Interrupted\"\n    terminate_interaction(1)\n  end\n\n  def process_args(args)\n    args = args.to_str.split(/\\s+/) if args.respond_to?(:to_str)\n    if args.size == 0\n      say Gem::Command::HELP\n      terminate_interaction(1)\n    end\n    case args[0]\n    when '-h', '--help'\n      say Gem::Command::HELP\n      terminate_interaction(0)\n    when '-v', '--version'\n      say Gem::RubyGemsVersion\n      terminate_interaction(0)\n    when /^-/\n      alert_error \"Invalid option: #{args[0]}.  See 'gem --help'.\"\n      terminate_interaction(1)\n    else\n      cmd_name = args.shift.downcase\n      cmd = find_command(cmd_name)\n      cmd.invoke(*args)\n    end\n  end\n\n  def find_command(cmd_name)\n    possibilities = find_command_possibilities cmd_name\n    if possibilities.size > 1 then\n      raise \"Ambiguous command #{cmd_name} matches [#{possibilities.join(', ')}]\"\n    elsif possibilities.size < 1 then\n      raise \"Unknown command #{cmd_name}\"\n    end\n\n    self[possibilities.first]\n  end\n\n  def find_command_possibilities(cmd_name)\n    len = cmd_name.length\n\n    command_names.select { |n| cmd_name == n[0, len] }\n  end\n\n  private\n\n  def load_and_instantiate(command_name)\n    command_name = command_name.to_s\n    retried = false\n\n    begin\n      const_name = command_name"..., 4096) = 4096
brk(0x9f92000)                          = 0x9f92000
read(3, "\n    rescue NameError\n      if retried then\n        raise\n      else\n        retried = true\n        require \"rubygems/commands/#{command_name}_command\"\n        retry\n      end\n    end\n  end\n\nend\n\n", 4096) = 196
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/timeout.rb", 0xbfe4ffa0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/timeout.so", 0xbfe4ffa0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/timeout.rb", 0xbfe4ffa0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/timeout.so", 0xbfe4ffa0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/timeout.rb", 0xbfe4ffa0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/timeout.so", 0xbfe4ffa0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/timeout.rb", 0xbfe4ffa0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/timeout.so", 0xbfe4ffa0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/timeout.rb", 0xbfe4ffa0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/timeout.so", 0xbfe4ffa0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/timeout.rb", 0xbfe4ffa0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/timeout.so", 0xbfe4ffa0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/timeout.rb", 0xbfe4ffa0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/timeout.so", 0xbfe4ffa0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/timeout.rb", 0xbfe4ffa0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/timeout.so", 0xbfe4ffa0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/timeout.rb", {st_mode=S_IFREG|0644, st_size=2938, ...}) = 0
open("/usr/lib/ruby/1.8/timeout.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2938, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/timeout.rb", 0xbfe4ffb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/timeout.rb", 0xbfe4ffb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/timeout.rb", 0xbfe4ffb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/timeout.rb", 0xbfe4ffb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/timeout.rb", 0xbfe4ffb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/timeout.rb", 0xbfe4ffb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/timeout.rb", 0xbfe4ffb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/timeout.rb", 0xbfe4ffb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/timeout.rb", {st_mode=S_IFREG|0644, st_size=2938, ...}) = 0
open("/usr/lib/ruby/1.8/timeout.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2938, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/timeout.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2938, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/timeout.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/timeout.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2938, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "#--\n# = timeout.rb\n#\n# execution timeout\n#\n# = Copyright\n#\n# Copyright:: (C) 2000  Network Applied Communication Laboratory, Inc.\n# Copyright:: (C) 2000  Information-technology Promotion Agency, Japan\n#\n#++\n#\n# = Description\n#\n# A way of performing a potentially long-running operation in a thread, and\n# terminating it's execution if it hasn't finished within fixed amount of\n# time.\n#\n# Previous versions of timeout didn't use a module for namespace. This version\n# provides both Timeout.timeout, and a backwards-compatible #timeout.\n#\n# = Synopsis\n#\n#   require 'timeout'\n#   status = Timeout::timeout(5) {\n#     # Something that should be interrupted if it takes too much time...\n#   }\n#\n\nmodule Timeout\n\n  ##\n  # Raised by Timeout#timeout when the block times out.\n\n  class Error < Interrupt\n  end\n  class ExitException < ::Exception # :nodoc:\n  end\n\n  THIS_FILE = /\\A#{Regexp.quote(__FILE__)}:/o\n  CALLER_OFFSET = ((c = caller[0]) && THIS_FILE =~ c) ? 1 : 0\n\n  ##\n  # Executes the method's block. If the block execution terminates before +sec+\n  # seconds has passed, it returns true. If not, it terminates the execution\n  # and raises +exception+ (which defaults to Timeout::Error).\n  #\n  # Note that this is both a method of module Timeout, so you can 'include\n  # Timeout' into your classes so they have a #timeout method, as well as a\n  # module method, so you can call it directly as Timeout.timeout().\n\n  def timeout(sec, klass = nil)\n    return yield if sec == nil or sec.zero?\n    raise ThreadError, \"timeout within critical session\" if Thread.critical\n    exception = klass || Class.new(ExitException)\n    begin\n      x = Thread.current\n      y = Thread.start {\n        sleep sec\n        x.raise exception, \"execution expired\" if x.alive?\n      }\n      yield sec\n      #    return true\n    rescue exception => e\n      rej = /\\A#{Regexp.quote(__FILE__)}:#{__LINE__-4}\\z/o\n      (bt = e.backtrace).reject! {|m| rej =~ m}\n      level = -caller(CALLER_OFFSET).size\n      while THIS_FILE =~ bt[level]\n        bt.delete_at(level)\n        level += 1\n      end\n      raise if klass            # if exception class is specified, it\n                                # would be expected outside.\n      raise Error, e.message, e.backtrace\n    ensure\n      y.kill if y and y.alive?\n    end\n  end\n\n  module_function :timeout\n\nend\n\n##\n# Identical to:\n#\n#   Timeout::timeout(n, e, &block).\n#\n# Defined for backwards compatibility with earlier versions of timeout.rb, see\n# Timeout#timeout.\n\ndef timeout(n, e = nil, &block) # :nodoc:\n  Timeout::timeout(n, e, &block)\nend\n\n##\n# Another name for Timeout::Error, defined for backwards compatibility with\n# earlier versions of timeout.rb.\n\nTimeoutError = Timeout::Error # :nodoc:\n\nif __FILE__ == $0\n  p timeout(5) {\n    45\n  }\n  p timeout(5, TimeoutError) {\n    45\n  }\n  p timeout(nil) {\n    54\n  }\n  p timeout(0) {\n    54\n  }\n  p timeout(5) {\n    loop {\n      p 10\n      sleep 1\n    }\n  }\nend\n\n", 4096) = 2938
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/command.rb", 0xbfe4ff80) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/command.so", 0xbfe4ff80) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/command.rb", {st_mode=S_IFREG|0644, st_size=12126, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/command.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=12126, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/command.rb", 0xbfe4ff90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/command.rb", {st_mode=S_IFREG|0644, st_size=12126, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/command.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=12126, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/command.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=12126, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/command.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/command.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=12126, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\nrequire 'optparse'\nrequire 'rubygems/user_interaction'\n\n##\n# Base class for all Gem commands.  When creating a new gem command, define\n# #new, #execute, #arguments, #defaults_str, #description and #usage\n# (as appropriate).  See the above mentioned methods for details.\n#\n# A very good example to look at is Gem::Commands::ContentsCommand\n\nclass Gem::Command\n\n  include Gem::UserInteraction\n\n  ##\n  # The name of the command.\n\n  attr_reader :command\n\n  ##\n  # The options for the command.\n\n  attr_reader :options\n\n  ##\n  # The default options for the command.\n\n  attr_accessor :defaults\n\n  ##\n  # The name of the command for command-line invocation.\n\n  attr_accessor :program_name\n\n  ##\n  # A short description of the command.\n\n  attr_accessor :summary\n\n  ##\n  # Arguments used when building gems\n\n  def self.build_args\n    @build_args ||= []\n  end\n  \n  def self.build_args=(value)\n    @build_args = value\n  end\n\n  def self.common_options\n    @common_options ||= []\n  end\n\n  def self.add_common_option(*args, &handler)\n    Gem::Command.common_options << [args, handler]\n  end\n\n  def self.extra_args\n    @extra_args ||= []\n  end\n\n  def self.extra_args=(value)\n    case value\n    when Array\n      @extra_args = value\n    when String\n      @extra_args = value.split\n    end\n  end\n\n  ##\n  # Return an array of extra arguments for the command.  The extra arguments\n  # come from the gem configuration file read at program startup.\n\n  def self.specific_extra_args(cmd)\n    specific_extra_args_hash[cmd]\n  end\n\n  ##\n  # Add a list of extra arguments for the given command.  +args+ may be an\n  # array or a string to be split on white space.\n\n  def self.add_specific_extra_args(cmd,args)\n    args = args.split(/\\s+/) if args.kind_of? String\n    specific_extra_args_hash[cmd] = args\n  end\n\n  ##\n  # Accessor for the specific extra args hash (self initializing).\n\n  def self.specific_extra_args_hash\n    @specific_extra_args_hash ||= Hash.new do |h,k|\n      h[k] = Array.new\n    end\n  end\n\n  ##\n  # Initializes a generic gem command named +command+.  +summary+ is a short\n  # description displayed in `gem help commands`.  +defaults+ are the default\n  # options.  Defaults should be mirrored in #defaults_str, unless there are\n  # none.\n  #\n  # When defining a new command subclass, use add_option to add command-line\n  # switches.\n  #\n  # Unhandled arguments (gem names, files, etc.) are left in\n  # <tt>options[:args]</tt>.\n\n  def initialize(command, summary=nil, defaults={})\n    @command = command\n    @summary = summary\n    @program_name = \"gem #{command}\"\n    @defaults = defaults\n    @options = defaults.dup\n    @option_groups = Hash.new { |h,k| h[k] = [] }\n    @parser = nil\n    @when_invoked = nil\n  end\n\n  ##\n  # True if +long+ begins with the characters from +short+.\n\n  def begins?(long, short)\n    return false if short.nil?\n    long[0, short.length] == short\n  end\n\n  ##\n  # Override to provide command handling.\n  #\n  # #options will be filled in with your parsed options, unparsed options will\n  # be left in <tt>options[:args]</tt>.\n  #\n  # See also: #get_all_gem_names, #get_one_gem_name,\n  # #get_one_optional_argument\n\n  def execute\n    raise Gem::Exception, \"generic command has no actions\"\n  end\n\n  ##\n  # Get all gem names from the command line.\n\n  def get_all_gem_names\n    args = options[:args]\n\n    if args.nil? or args.empty? then\n      raise Gem::CommandLineError,\n            \"Please specify at least one gem name (e.g. gem build GEMNAME)\"\n    end\n\n    gem_names = args.select { |arg| arg !~ /^-/ }\n  end\n\n  ##\n  # Get the single gem name from the command line.  Fail if there is no gem\n  # name or if there is more than one gem name given.\n\n  def get_one_gem_name\n    args = options[:args]\n\n    if args.nil? or args.empty? then\n      raise Gem::CommandLineError,\n            \"Please specify a gem name on the command line (e.g. gem build GEMNA"..., 4096) = 4096
read(3, " gem names (#{args.join(', ')}); please specify only one\"\n    end\n\n    args.first\n  end\n\n  ##\n  # Get a single optional argument from the command line.  If more than one\n  # argument is given, return only the first. Return nil if none are given.\n\n  def get_one_optional_argument\n    args = options[:args] || []\n    args.first\n  end\n\n  ##\n  # Override to provide details of the arguments a command takes.  It should\n  # return a left-justified string, one argument per line.\n  #\n  # For example:\n  #\n  #   def usage\n  #     \"#{program_name} FILE [FILE ...]\"\n  #   end\n  #   \n  #   def arguments\n  #     \"FILE          name of file to find\"\n  #   end\n\n  def arguments\n    \"\"\n  end\n\n  ##\n  # Override to display the default values of the command options. (similar to\n  # +arguments+, but displays the default values).\n  #\n  # For example:\n  #\n  #   def defaults_str\n  #     --no-gems-first --no-all\n  #   end\n\n  def defaults_str\n    \"\"\n  end\n\n  ##\n  # Override to display a longer description of what this command does.\n\n  def description\n    nil\n  end\n\n  ##\n  # Override to display the usage for an individual gem command.\n  #\n  # The text \"[options]\" is automatically appended to the usage text.\n\n  def usage\n    program_name\n  end\n\n  ##\n  # Display the help message for the command.\n\n  def show_help\n    parser.program_name = usage\n    say parser\n  end\n\n  ##\n  # Invoke the command with the given list of arguments.\n\n  def invoke(*args)\n    handle_options(args)\n    if options[:help]\n      show_help\n    elsif @when_invoked\n      @when_invoked.call(options)\n    else\n      execute\n    end\n  end\n\n  ##\n  # Call the given block when invoked.\n  #\n  # Normal command invocations just executes the +execute+ method of the\n  # command.  Specifying an invocation block allows the test methods to\n  # override the normal action of a command to determine that it has been\n  # invoked correctly.\n\n  def when_invoked(&block)\n    @when_invoked = block\n  end\n\n  ##\n  # Add a command-line option and handler to the command.\n  #\n  # See OptionParser#make_switch for an explanation of +opts+.\n  #\n  # +handler+ will be called with two values, the value of the argument and\n  # the options hash.\n  #\n  # If the first argument of add_option is a Symbol, it's used to group\n  # options in output.  See `gem help list` for an example.\n\n  def add_option(*opts, &handler) # :yields: value, options\n    group_name = Symbol === opts.first ? opts.shift : :options\n\n    @option_groups[group_name] << [opts, handler]\n  end\n\n  ##\n  # Remove previously defined command-line argument +name+.\n\n  def remove_option(name)\n    @option_groups.each do |_, option_list|\n      option_list.reject! { |args, _| args.any? { |x| x =~ /^#{name}/ } }\n    end\n  end\n\n  ##\n  # Merge a set of command options with the set of default options (without\n  # modifying the default option hash).\n\n  def merge_options(new_options)\n    @options = @defaults.clone\n    new_options.each do |k,v| @options[k] = v end\n  end\n\n  ##\n  # True if the command handles the given argument list.\n\n  def handles?(args)\n    begin\n      parser.parse!(args.dup)\n      return true\n    rescue\n      return false\n    end\n  end\n\n  ##\n  # Handle the given list of arguments by parsing them and recording the\n  # results.\n\n  def handle_options(args)\n    args = add_extra_args(args)\n    @options = @defaults.clone\n    parser.parse!(args)\n    @options[:args] = args\n  end\n\n  ##\n  # Adds extra args from ~/.gemrc\n\n  def add_extra_args(args)\n    result = []\n\n    s_extra = Gem::Command.specific_extra_args(@command)\n    extra = Gem::Command.extra_args + s_extra\n\n    until extra.empty? do\n      ex = []\n      ex << extra.shift\n      ex << extra.shift if extra.first.to_s =~ /^[^-]/\n      result << ex if handles?(ex)\n    end\n\n    result.flatten!\n    result.concat(args)\n    result\n  end\n\n  private\n\n  ##\n  # Create on demand parser.\n\n  def parser\n    create_option_parser if @parser.nil?\n    @parser\n  end\n\n  def create_option_parser\n    @parser = OptionParser.new\n\n    @parser.separ"..., 4096) = 4096
read(3, "_options\n\n    @option_groups.sort_by { |n,_| n.to_s }.each do |group_name, option_list|\n      configure_options group_name, option_list\n    end\n\n    configure_options \"Common\", Gem::Command.common_options\n\n    @parser.separator(\"\")\n    unless arguments.empty?\n      @parser.separator(\"  Arguments:\")\n      arguments.split(/\\n/).each do |arg_desc|\n        @parser.separator(\"    #{arg_desc}\")\n      end\n      @parser.separator(\"\")\n    end\n\n    @parser.separator(\"  Summary:\")\n    wrap(@summary, 80 - 4).split(\"\\n\").each do |line|\n      @parser.separator(\"    #{line.strip}\")\n    end\n\n    if description then\n      formatted = description.split(\"\\n\\n\").map do |chunk|\n        wrap(chunk, 80 - 4)\n      end.join(\"\\n\")\n\n      @parser.separator \"\"\n      @parser.separator \"  Description:\"\n      formatted.split(\"\\n\").each do |line|\n        @parser.separator \"    #{line.rstrip}\"\n      end\n    end\n\n    unless defaults_str.empty?\n      @parser.separator(\"\")\n      @parser.separator(\"  Defaults:\")\n      defaults_str.split(/\\n/).each do |line|\n        @parser.separator(\"    #{line}\")\n      end\n    end\n  end\n\n  def configure_options(header, option_list)\n    return if option_list.nil? or option_list.empty?\n\n    header = header.to_s.empty? ? '' : \"#{header} \"\n    @parser.separator \"  #{header}Options:\"\n\n    option_list.each do |args, handler|\n      dashes = args.select { |arg| arg =~ /^-/ }\n      @parser.on(*args) do |value|\n        handler.call(value, @options)\n      end\n    end\n\n    @parser.separator ''\n  end\n\n  ##\n  # Wraps +text+ to +width+\n\n  def wrap(text, width) # :doc:\n    text.gsub(/(.{1,#{width}})( +|$\\n?)|(.{1,#{width}})/, \"\\\\1\\\\3\\n\")\n  end\n\n  # ----------------------------------------------------------------\n  # Add the options common to all commands.\n\n  add_common_option('-h', '--help',\n                    'Get help on this command') do |value, options|\n    options[:help] = true\n  end\n\n  add_common_option('-V', '--[no-]verbose',\n                    'Set the verbose level of output') do |value, options|\n    # Set us to \"really verbose\" so the progress meter works\n    if Gem.configuration.verbose and value then\n      Gem.configuration.verbose = 1\n    else\n      Gem.configuration.verbose = value\n    end\n  end\n\n  add_common_option('-q', '--quiet', 'Silence commands') do |value, options|\n    Gem.configuration.verbose = false\n  end\n\n  # Backtrace and config-file are added so they show up in the help\n  # commands.  Both options are actually handled before the other\n  # options get parsed.\n\n  add_common_option('--config-file FILE',\n                    'Use this config file instead of default') do\n  end\n\n  add_common_option('--backtrace',\n                    'Show stack backtrace on errors') do\n  end\n\n  add_common_option('--debug',\n                    'Turn on Ruby debugging') do\n  end\n\n  # :stopdoc:\n\n  HELP = %{\n    RubyGems is a sophisticated package manager for Ruby.  This is a\n    basic help message containing pointers to more information.\n\n      Usage:\n        gem -h/--help\n        gem -v/--version\n        gem command [arguments...] [options...]\n\n      Examples:\n        gem install rake\n        gem list --local\n        gem build package.gemspec\n        gem help install\n\n      Further help:\n        gem help commands            list all 'gem' commands\n        gem help examples            show some examples of usage\n        gem help platforms           show information about platforms\n        gem help <COMMAND>           show help on COMMAND\n                                       (e.g. 'gem help install')\n        gem server                   present a web page at\n                                     http://localhost:8808/\n                                     with info about installed gems\n      Further information:\n        http://rubygems.rubyforge.org\n  }.gsub(/^    /, '')\n\n  # :startdoc:\n\nend\n\n##\n# This is where Commands will be placed in the namespace\n\nmodule Gem::Commands\nend\n\n", 4096) = 3934
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/optparse.rb", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/optparse.so", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/optparse.rb", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/optparse.so", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/optparse.rb", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/optparse.so", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/optparse.rb", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/optparse.so", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/optparse.rb", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/optparse.so", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/optparse.rb", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/optparse.so", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/optparse.rb", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/optparse.so", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/optparse.rb", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/optparse.so", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/optparse.rb", {st_mode=S_IFREG|0644, st_size=48252, ...}) = 0
open("/usr/lib/ruby/1.8/optparse.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=48252, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/optparse.rb", 0xbfe4e960) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/optparse.rb", 0xbfe4e960) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/optparse.rb", 0xbfe4e960) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/optparse.rb", 0xbfe4e960) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/optparse.rb", 0xbfe4e960) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/optparse.rb", 0xbfe4e960) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/optparse.rb", 0xbfe4e960) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/optparse.rb", 0xbfe4e960) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/optparse.rb", {st_mode=S_IFREG|0644, st_size=48252, ...}) = 0
open("/usr/lib/ruby/1.8/optparse.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=48252, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/optparse.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=48252, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/optparse.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/optparse.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=48252, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "#\n# optparse.rb - command-line option analysis with the OptionParser class.\n# \n# Author:: Nobu Nakada\n# Documentation:: Nobu Nakada and Gavin Sinclair.\n#\n# See OptionParser for documentation. \n#\n\n\n# == Developer Documentation (not for RDoc output) \n# \n# === Class tree\n#\n# - OptionParser:: front end\n# - OptionParser::Switch:: each switches\n# - OptionParser::List:: options list\n# - OptionParser::ParseError:: errors on parsing\n#   - OptionParser::AmbiguousOption\n#   - OptionParser::NeedlessArgument\n#   - OptionParser::MissingArgument\n#   - OptionParser::InvalidOption\n#   - OptionParser::InvalidArgument\n#     - OptionParser::AmbiguousArgument\n#\n# === Object relationship diagram\n#\n#   +--------------+\n#   | OptionParser |<>-----+\n#   +--------------+       |                      +--------+\n#                          |                    ,-| Switch |\n#        on_head -------->+---------------+    /  +--------+\n#        accept/reject -->| List          |<|>-\n#                         |               |<|>-  +----------+\n#        on ------------->+---------------+    `-| argument |\n#                           :           :        |  class   |\n#                         +---------------+      |==========|\n#        on_tail -------->|               |      |pattern   |\n#                         +---------------+      |----------|\n#   OptionParser.accept ->| DefaultList   |      |converter |\n#                reject   |(shared between|      +----------+\n#                         | all instances)|\n#                         +---------------+\n#\n# == OptionParser\n#\n# === Introduction\n#\n# OptionParser is a class for command-line option analysis.  It is much more\n# advanced, yet also easier to use, than GetoptLong, and is a more Ruby-oriented\n# solution.\n#\n# === Features\n# \n# 1. The argument specification and the code to handle it are written in the\n#    same place.\n# 2. It can output an option summary; you don't need to maintain this string\n#    separately.\n# 3. Optional and mandatory arguments are specified very gracefully.\n# 4. Arguments can be automatically converted to a specified class.\n# 5. Arguments can be restricted to a certain set.\n#\n# All of these features are demonstrated in the examples below.\n#\n# === Minimal example\n#\n#   require 'optparse'\n#\n#   options = {}\n#   OptionParser.new do |opts|\n#     opts.banner = \"Usage: example.rb [options]\"\n#\n#     opts.on(\"-v\", \"--[no-]verbose\", \"Run verbosely\") do |v|\n#       options[:verbose] = v\n#     end\n#   end.parse!\n#\n#   p options\n#   p ARGV\n#\n# === Complete example\n#\n# The following example is a complete Ruby program.  You can run it and see the\n# effect of specifying various options.  This is probably the best way to learn\n# the features of +optparse+.\n#\n#   require 'optparse'\n#   require 'optparse/time'\n#   require 'ostruct'\n#   require 'pp'\n#   \n#   class OptparseExample\n#   \n#     CODES = %w[iso-2022-jp shift_jis euc-jp utf8 binary]\n#     CODE_ALIASES = { \"jis\" => \"iso-2022-jp\", \"sjis\" => \"shift_jis\" }\n#   \n#     #\n#     # Return a structure describing the options.\n#     #\n#     def self.parse(args)\n#       # The options specified on the command line will be collected in *options*.\n#       # We set default values here.\n#       options = OpenStruct.new\n#       options.library = []\n#       options.inplace = false\n#       options.encoding = \"utf8\"\n#       options.transfer_type = :auto\n#       options.verbose = false\n#       \n#       opts = OptionParser.new do |opts|\n#         opts.banner = \"Usage: example.rb [options]\"\n#       \n#         opts.separator \"\"\n#         opts.separator \"Specific options:\"\n#       \n#         # Mandatory argument.\n#         opts.on(\"-r\", \"--require LIBRARY\",\n#                 \"Require the LIBRARY before executing your script\") do |lib|\n#           options.library << lib\n#         end\n#       \n#         # Optional argument; multi-line description.\n#         opts.on(\"-i\", \"--inplace [EXTENSION]\",\n#                 \"Edit ARGV files in place\",\n#                 \"  (make"..., 4096) = 4096
brk(0x9fb3000)                          = 0x9fb3000
read(3, ".extension = ext || ''\n#           options.extension.sub!(/\\A\\.?(?=.)/, \".\")  # Ensure extension begins with dot.\n#         end\n#       \n#         # Cast 'delay' argument to a Float.\n#         opts.on(\"--delay N\", Float, \"Delay N seconds before executing\") do |n|\n#           options.delay = n\n#         end\n#       \n#         # Cast 'time' argument to a Time object.\n#         opts.on(\"-t\", \"--time [TIME]\", Time, \"Begin execution at given time\") do |time|\n#           options.time = time\n#         end\n#       \n#         # Cast to octal integer.\n#         opts.on(\"-F\", \"--irs [OCTAL]\", OptionParser::OctalInteger,\n#                 \"Specify record separator (default \\\\0)\") do |rs|\n#           options.record_separator = rs\n#         end\n#       \n#         # List of arguments.\n#         opts.on(\"--list x,y,z\", Array, \"Example 'list' of arguments\") do |list|\n#           options.list = list\n#         end\n#       \n#         # Keyword completion.  We are specifying a specific set of arguments (CODES\n#         # and CODE_ALIASES - notice the latter is a Hash), and the user may provide\n#         # the shortest unambiguous text.\n#         code_list = (CODE_ALIASES.keys + CODES).join(',')\n#         opts.on(\"--code CODE\", CODES, CODE_ALIASES, \"Select encoding\",\n#                 \"  (#{code_list})\") do |encoding|\n#           options.encoding = encoding\n#         end\n#       \n#         # Optional argument with keyword completion.\n#         opts.on(\"--type [TYPE]\", [:text, :binary, :auto],\n#                 \"Select transfer type (text, binary, auto)\") do |t|\n#           options.transfer_type = t\n#         end\n#       \n#         # Boolean switch.\n#         opts.on(\"-v\", \"--[no-]verbose\", \"Run verbosely\") do |v|\n#           options.verbose = v\n#         end\n#       \n#         opts.separator \"\"\n#         opts.separator \"Common options:\"\n#       \n#         # No argument, shows at tail.  This will print an options summary.\n#         # Try it and see!\n#         opts.on_tail(\"-h\", \"--help\", \"Show this message\") do\n#           puts opts\n#           exit\n#         end\n#       \n#         # Another typical switch to print the version.\n#         opts.on_tail(\"--version\", \"Show version\") do\n#           puts OptionParser::Version.join('.')\n#           exit\n#         end\n#       end\n#       \n#       opts.parse!(args)\n#       options\n#     end  # parse()\n#   \n#   end  # class OptparseExample\n#   \n#   options = OptparseExample.parse(ARGV)\n#   pp options\n#\n# === Further documentation\n#\n# The above examples should be enough to learn how to use this class.  If you\n# have any questions, email me (gsinclair@soyabean.com.au) and I will update\n# this document.\n#\nclass OptionParser\n  # :stopdoc:\n  RCSID = %w$Id: optparse.rb 22469 2009-02-20 11:43:35Z shyouhei $[1..-1].each {|s| s.freeze}.freeze\n  Version = (RCSID[1].split('.').collect {|s| s.to_i}.extend(Comparable).freeze if RCSID[1])\n  LastModified = (Time.gm(*RCSID[2, 2].join('-').scan(/\\d+/).collect {|s| s.to_i}) if RCSID[2])\n  Release = RCSID[2]\n\n  NoArgument = [NO_ARGUMENT = :NONE, nil].freeze\n  RequiredArgument = [REQUIRED_ARGUMENT = :REQUIRED, true].freeze\n  OptionalArgument = [OPTIONAL_ARGUMENT = :OPTIONAL, false].freeze\n  # :startdoc:\n\n  #\n  # Keyword completion module.  This allows partial arguments to be specified\n  # and resolved against a list of acceptable values.\n  #\n  module Completion\n    def complete(key, icase = false, pat = nil)\n      pat ||= Regexp.new('\\A' + Regexp.quote(key).gsub(/\\w+\\b/, '\\&\\w*'),\n                         icase)\n      canon, sw, k, v, cn = nil\n      candidates = []\n      each do |k, *v|\n        (if Regexp === k\n           kn = nil\n           k === key\n         else\n           kn = defined?(k.id2name) ? k.id2name : k\n           pat === kn\n         end) or next\n        v << k if v.empty?\n        candidates << [k, v, kn]\n      end\n      candidates = candidates.sort_by {|k, v, kn| kn.size}\n      if candidates.size == 1\n        canon, sw, * = candidates[0]\n      elsif candidates.size"..., 4096) = 4096
read(3, "xt if sw == v\n          if String === cn and String === kn\n            if cn.rindex(kn, 0)\n              canon, sw, cn = k, v, kn\n              next\n            elsif kn.rindex(cn, 0)\n              next\n            end\n          end\n          throw :ambiguous, key\n        end\n      end\n      if canon\n        block_given? or return key, *sw\n        yield(key, *sw)\n      end\n    end\n\n    def convert(opt = nil, val = nil, *)\n      val\n    end\n  end\n\n\n  #\n  # Map from option/keyword string to object with completion.\n  #\n  class OptionMap < Hash\n    include Completion\n  end\n\n\n  #\n  # Individual switch class.  Not important to the user.\n  #\n  # Defined within Switch are several Switch-derived classes: NoArgument,\n  # RequiredArgument, etc. \n  #\n  class Switch\n    attr_reader :pattern, :conv, :short, :long, :arg, :desc, :block\n\n    #\n    # Guesses argument style from +arg+.  Returns corresponding\n    # OptionParser::Switch class (OptionalArgument, etc.).\n    #\n    def self.guess(arg)\n      case arg\n      when \"\"\n        t = self\n      when /\\A=?\\[/\n        t = Switch::OptionalArgument\n      when /\\A\\s+\\[/\n        t = Switch::PlacedArgument\n      else\n        t = Switch::RequiredArgument\n      end\n      self >= t or incompatible_argument_styles(arg, t)\n      t\n    end\n\n    def self.incompatible_argument_styles(arg, t)\n      raise ArgumentError, \"#{arg}: incompatible argument styles\\n  #{self}, #{t}\"\n    end\n\n    def self.pattern\n      NilClass\n    end\n\n    def initialize(pattern = nil, conv = nil,\n                   short = nil, long = nil, arg = nil,\n                   desc = ([] if short or long), block = Proc.new)\n      raise if Array === pattern\n      @pattern, @conv, @short, @long, @arg, @desc, @block =\n        pattern, conv, short, long, arg, desc, block\n    end\n\n    #\n    # Parses +arg+ and returns rest of +arg+ and matched portion to the\n    # argument pattern. Yields when the pattern doesn't match substring.\n    #\n    def parse_arg(arg)\n      pattern or return nil, arg\n      unless m = pattern.match(arg)\n        yield(InvalidArgument, arg)\n        return arg, nil\n      end\n      if String === m\n        m = [s = m]\n      else\n        m = m.to_a\n        s = m[0]\n        return nil, m unless String === s\n      end\n      raise InvalidArgument, arg unless arg.rindex(s, 0)\n      return nil, m if s.length == arg.length\n      yield(InvalidArgument, arg) # didn't match whole arg\n      return arg[s.length..-1], m\n    end\n    private :parse_arg\n\n    #\n    # Parses argument, converts and returns +arg+, +block+ and result of\n    # conversion. Yields at semi-error condition instead of raising an\n    # exception.\n    #\n    def conv_arg(arg, val = nil)\n      if conv\n        val = conv.call(*val)\n      else\n        val = proc {|val| val}.call(*val)\n      end\n      return arg, block, val\n    end\n    private :conv_arg\n\n    #\n    # Produces the summary text. Each line of the summary is yielded to the\n    # block (without newline).\n    #\n    # +sdone+::  Already summarized short style options keyed hash.\n    # +ldone+::  Already summarized long style options keyed hash.\n    # +width+::  Width of left side (option part). In other words, the right\n    #            side (description part) starts after +width+ columns.\n    # +max+::    Maximum width of left side -> the options are filled within\n    #            +max+ columns.\n    # +indent+:: Prefix string indents all summarized lines.\n    #\n    def summarize(sdone = [], ldone = [], width = 1, max = width - 1, indent = \"\")\n      sopts, lopts, s = [], [], nil\n      @short.each {|s| sdone.fetch(s) {sopts << s}; sdone[s] = true} if @short\n      @long.each {|s| ldone.fetch(s) {lopts << s}; ldone[s] = true} if @long\n      return if sopts.empty? and lopts.empty? # completely hidden\n\n      left = [sopts.join(', ')]\n      right = desc.dup\n\n      while s = lopts.shift\n        l = left[-1].length + s.length\n        l += arg.length if left.size == 1 && arg\n        l < max or sopts.empty? or left << ''\n        l"..., 4096) = 4096
read(3, " arg\n      mlen = left.collect {|s| s.length}.max.to_i\n      while mlen > width and l = left.shift\n        mlen = left.collect {|s| s.length}.max.to_i if l.length == mlen\n        yield(indent + l)\n      end\n\n      while begin l = left.shift; r = right.shift; l or r end\n        l = l.to_s.ljust(width) + ' ' + r if r and !r.empty?\n        yield(indent + l)\n      end\n\n      self\n    end\n\n    def add_banner(to)  # :nodoc:\n      unless @short or @long\n        s = desc.join\n        to << \" [\" + s + \"]...\" unless s.empty?\n      end\n      to\n    end\n\n    def match_nonswitch?(str) # :nodoc:\n      @pattern =~ str unless @short or @long\n    end\n\n    #\n    # Main name of the switch.\n    #\n    def switch_name\n      (long.first || short.first).sub(/\\A-+(?:\\[no-\\])?/, '')\n    end\n\n    #\n    # Switch that takes no arguments.\n    #\n    class NoArgument < self\n\n      #\n      # Raises an exception if any arguments given.\n      #\n      def parse(arg, argv)\n        yield(NeedlessArgument, arg) if arg\n        conv_arg(arg)\n      end\n\n      def self.incompatible_argument_styles(*)\n      end\n\n      def self.pattern\n        Object\n      end\n    end\n\n    #\n    # Switch that takes an argument.\n    #\n    class RequiredArgument < self\n\n      #\n      # Raises an exception if argument is not present.\n      #\n      def parse(arg, argv)\n        unless arg\n          raise MissingArgument if argv.empty?\n          arg = argv.shift\n        end\n        conv_arg(*parse_arg(arg) {|*exc| raise(*exc)})\n      end\n    end\n\n    #\n    # Switch that can omit argument.\n    #\n    class OptionalArgument < self\n\n      #\n      # Parses argument if given, or uses default value.\n      #\n      def parse(arg, argv, &error)\n        if arg\n          conv_arg(*parse_arg(arg, &error))\n        else\n          conv_arg(arg)\n        end\n      end\n    end\n\n    #\n    # Switch that takes an argument, which does not begin with '-'.\n    #\n    class PlacedArgument < self\n\n      #\n      # Returns nil if argument is not present or begins with '-'.\n      #\n      def parse(arg, argv, &error)\n        if !(val = arg) and (argv.empty? or /\\A-/ =~ (val = argv[0]))\n          return nil, block, nil\n        end\n        opt = (val = parse_arg(val, &error))[1]\n        val = conv_arg(*val)\n        if opt and !arg\n          argv.shift\n        else\n          val[0] = nil\n        end\n        val\n      end\n    end\n  end\n\n  #\n  # Simple option list providing mapping from short and/or long option\n  # string to OptionParser::Switch and mapping from acceptable argument to\n  # matching pattern and converter pair. Also provides summary feature.\n  #\n  class List\n    # Map from acceptable argument types to pattern and converter pairs.\n    attr_reader :atype\n    \n    # Map from short style option switches to actual switch objects.\n    attr_reader :short\n    \n    # Map from long style option switches to actual switch objects.\n    attr_reader :long\n    \n    # List of all switches and summary string.\n    attr_reader :list\n\n    #\n    # Just initializes all instance variables.\n    #\n    def initialize\n      @atype = {}\n      @short = OptionMap.new\n      @long = OptionMap.new\n      @list = []\n    end\n\n    #\n    # See OptionParser.accept.\n    #\n    def accept(t, pat = /.*/nm, &block)\n      if pat\n        pat.respond_to?(:match) or raise TypeError, \"has no `match'\"\n      else\n        pat = t if t.respond_to?(:match)\n      end\n      unless block\n        block = pat.method(:convert).to_proc if pat.respond_to?(:convert)\n      end\n      @atype[t] = [pat, block]\n    end\n\n    #\n    # See OptionParser.reject.\n    #\n    def reject(t)\n      @atype.delete(t)\n    end\n\n    #\n    # Adds +sw+ according to +sopts+, +lopts+ and +nlopts+.\n    #\n    # +sw+::     OptionParser::Switch instance to be added.\n    # +sopts+::  Short style option list.\n    # +lopts+::  Long style option list.\n    # +nlopts+:: Negated long style options list.\n    #\n    def update(sw, sopts, lopts, nsw = nil, nlopts = nil)\n      o = nil\n      sopts.each {|o| @short[o] = sw"..., 4096) = 4096
read(3, "if nsw and nlopts\n      used = @short.invert.update(@long.invert)\n      @list.delete_if {|o| Switch === o and !used[o]}\n    end\n    private :update\n\n    #\n    # Inserts +switch+ at the head of the list, and associates short, long\n    # and negated long options. Arguments are:\n    # \n    # +switch+::      OptionParser::Switch instance to be inserted.\n    # +short_opts+::  List of short style options.\n    # +long_opts+::   List of long style options.\n    # +nolong_opts+:: List of long style options with \"no-\" prefix.\n    #\n    #   prepend(switch, short_opts, long_opts, nolong_opts)\n    #\n    def prepend(*args)\n      update(*args)\n      @list.unshift(args[0])\n    end\n\n    #\n    # Appends +switch+ at the tail of the list, and associates short, long\n    # and negated long options. Arguments are:\n    # \n    # +switch+::      OptionParser::Switch instance to be inserted.\n    # +short_opts+::  List of short style options.\n    # +long_opts+::   List of long style options.\n    # +nolong_opts+:: List of long style options with \"no-\" prefix.\n    #\n    #   append(switch, short_opts, long_opts, nolong_opts)\n    #\n    def append(*args)\n      update(*args)\n      @list.push(args[0])\n    end\n\n    #\n    # Searches +key+ in +id+ list. The result is returned or yielded if a\n    # block is given. If it isn't found, nil is returned.\n    #\n    def search(id, key)\n      if list = __send__(id)\n        val = list.fetch(key) {return nil}\n        block_given? ? yield(val) : val\n      end\n    end\n\n    #\n    # Searches list +id+ for +opt+ and the optional patterns for completion\n    # +pat+. If +icase+ is true, the search is case insensitive. The result\n    # is returned or yielded if a block is given. If it isn't found, nil is\n    # returned.\n    #\n    def complete(id, opt, icase = false, *pat, &block)\n      __send__(id).complete(opt, icase, *pat, &block)\n    end\n\n    #\n    # Iterates over each option, passing the option to the +block+.\n    #\n    def each_option(&block)\n      list.each(&block)\n    end\n\n    #\n    # Creates the summary table, passing each line to the +block+ (without\n    # newline). The arguments +args+ are passed along to the summarize\n    # method which is called on every option.\n    #\n    def summarize(*args, &block)\n      sum = []\n      list.reverse_each do |opt|\n        if opt.respond_to?(:summarize) # perhaps OptionParser::Switch\n          s = []\n          opt.summarize(*args) {|l| s << l}\n          sum.concat(s.reverse)\n        elsif !opt or opt.empty?\n          sum << \"\"\n        elsif opt.respond_to?(:each_line)\n          sum.concat([*opt.each_line].reverse)\n        else\n          sum.concat([*opt.each].reverse)\n        end\n      end\n      sum.reverse_each(&block)\n    end\n\n    def add_banner(to)  # :nodoc:\n      list.each do |opt|\n        if opt.respond_to?(:add_banner)\n          opt.add_banner(to)\n        end\n      end\n      to\n    end\n  end\n\n  #\n  # Hash with completion search feature. See OptionParser::Completion.\n  #\n  class CompletingHash < Hash\n    include Completion\n\n    #\n    # Completion for hash key.\n    #\n    def match(key)\n      return key, *fetch(key) {\n        raise AmbiguousArgument, catch(:ambiguous) {return complete(key)}\n      }\n    end\n  end\n\n  # :stopdoc:\n\n  #\n  # Enumeration of acceptable argument styles. Possible values are:\n  #\n  # NO_ARGUMENT::       The switch takes no arguments. (:NONE)\n  # REQUIRED_ARGUMENT:: The switch requires an argument. (:REQUIRED)\n  # OPTIONAL_ARGUMENT:: The switch requires an optional argument. (:OPTIONAL)\n  #\n  # Use like --switch=argument (long style) or -Xargument (short style). For\n  # short style, only portion matched to argument pattern is dealed as\n  # argument.\n  #\n  ArgumentStyle = {}\n  NoArgument.each {|el| ArgumentStyle[el] = Switch::NoArgument}\n  RequiredArgument.each {|el| ArgumentStyle[el] = Switch::RequiredArgument}\n  OptionalArgument.each {|el| ArgumentStyle[el] = Switch::OptionalArgument}\n  ArgumentStyle.freeze\n\n  #\n  # Switches common used such as '--', and also pro"..., 4096) = 4096
read(3, "h::NoArgument.new {}\n  DefaultList.long[''] = Switch::NoArgument.new {throw :terminate}\n\n  #\n  # Default options for ARGV, which never appear in option summary.\n  #\n  Officious = {}\n\n  #\n  # --help\n  # Shows option summary.\n  #\n  Officious['help'] = proc do |parser|\n    Switch::NoArgument.new do\n      puts parser.help\n      exit\n    end\n  end\n\n  #\n  # --version\n  # Shows version string if Version is defined.\n  #\n  Officious['version'] = proc do |parser|\n    Switch::OptionalArgument.new do |pkg|\n      if pkg\n        begin\n          require 'optparse/version'\n        rescue LoadError\n        else\n          show_version(*pkg.split(/,/)) or\n            abort(\"#{parser.program_name}: no version found in package #{pkg}\")\n          exit\n        end\n      end\n      v = parser.ver or abort(\"#{parser.program_name}: version unknown\")\n      puts v\n      exit\n    end\n  end\n\n  # :startdoc:\n\n  #\n  # Class methods\n  #\n\n  #\n  # Initializes a new instance and evaluates the optional block in context\n  # of the instance. Arguments +args+ are passed to #new, see there for\n  # description of parameters.\n  # \n  # This method is *deprecated*, its behavior corresponds to the older #new\n  # method.\n  #\n  def self.with(*args, &block)\n    opts = new(*args)\n    opts.instance_eval(&block)\n    opts\n  end\n\n  #\n  # Returns an incremented value of +default+ according to +arg+.\n  #\n  def self.inc(arg, default = nil)\n    case arg\n    when Integer\n      arg.nonzero?\n    when nil\n      default.to_i + 1\n    end\n  end\n  def inc(*args)\n    self.class.inc(*args)\n  end\n\n  #\n  # Initializes the instance and yields itself if called with a block.\n  #\n  # +banner+:: Banner message.\n  # +width+::  Summary width.\n  # +indent+:: Summary indent.\n  #\n  def initialize(banner = nil, width = 32, indent = ' ' * 4)\n    @stack = [DefaultList, List.new, List.new]\n    @program_name = nil\n    @banner = banner\n    @summary_width = width\n    @summary_indent = indent\n    @default_argv = ARGV\n    add_officious\n    yield self if block_given?\n  end\n\n  def add_officious  # :nodoc:\n    list = base()\n    Officious.each do |opt, block|\n      list.long[opt] ||= block.call(self)\n    end\n  end\n\n  #\n  # Terminates option parsing. Optional parameter +arg+ is a string pushed\n  # back to be the first non-option argument.\n  #\n  def terminate(arg = nil)\n    self.class.terminate(arg)\n  end\n  def self.terminate(arg = nil)\n    throw :terminate, arg\n  end\n\n  @stack = [DefaultList]\n  def self.top() DefaultList end\n\n  #\n  # Directs to accept specified class +t+. The argument string is passed to\n  # the block in which it should be converted to the desired class.\n  #\n  # +t+::   Argument class specifier, any object including Class.\n  # +pat+:: Pattern for argument, defaults to +t+ if it responds to match.\n  #\n  #   accept(t, pat, &block)\n  #\n  def accept(*args, &blk) top.accept(*args, &blk) end\n  #\n  # See #accept.\n  #\n  def self.accept(*args, &blk) top.accept(*args, &blk) end\n\n  #\n  # Directs to reject specified class argument.\n  #\n  # +t+:: Argument class specifier, any object including Class.\n  #\n  #   reject(t)\n  #\n  def reject(*args, &blk) top.reject(*args, &blk) end\n  #\n  # See #reject.\n  #\n  def self.reject(*args, &blk) top.reject(*args, &blk) end\n\n  #\n  # Instance methods\n  #\n\n  # Heading banner preceding summary.\n  attr_writer :banner\n\n  # Program name to be emitted in error message and default banner,\n  # defaults to $0.\n  attr_writer :program_name\n\n  # Width for option list portion of summary. Must be Numeric.\n  attr_accessor :summary_width\n\n  # Indentation for summary. Must be String (or have + String method).\n  attr_accessor :summary_indent\n\n  # Strings to be parsed in default.\n  attr_accessor :default_argv\n\n  #\n  # Heading banner preceding summary.\n  #\n  def banner\n    unless @banner\n      @banner = \"Usage: #{program_name} [options]\"\n      visit(:add_banner, @banner)\n    end\n    @banner\n  end\n\n  #\n  # Program name to be emitted in error message and default banner, defaults\n  # to $0.\n  #\n  def progr"..., 4096) = 4096
read(3, " alias set_banner banner=\n  alias set_program_name program_name=\n  alias set_summary_width summary_width=\n  alias set_summary_indent summary_indent=\n\n  # Version\n  attr_writer :version\n  # Release code\n  attr_writer :release\n\n  #\n  # Version\n  #\n  def version\n    @version || (defined?(::Version) && ::Version)\n  end\n\n  #\n  # Release code\n  #\n  def release\n    @release || (defined?(::Release) && ::Release) || (defined?(::RELEASE) && ::RELEASE)\n  end\n\n  #\n  # Returns version string from program_name, version and release.\n  #\n  def ver\n    if v = version\n      str = \"#{program_name} #{[v].join('.')}\"\n      str << \" (#{v})\" if v = release\n      str\n    end\n  end\n\n  def warn(mesg = $!)\n    super(\"#{program_name}: #{mesg}\")\n  end\n\n  def abort(mesg = $!)\n    super(\"#{program_name}: #{mesg}\")\n  end\n\n  #\n  # Subject of #on / #on_head, #accept / #reject\n  #\n  def top\n    @stack[-1]\n  end\n\n  #\n  # Subject of #on_tail.\n  #\n  def base\n    @stack[1]\n  end\n\n  #\n  # Pushes a new List.\n  #\n  def new\n    @stack.push(List.new)\n    if block_given?\n      yield self\n    else\n      self\n    end\n  end\n\n  #\n  # Removes the last List.\n  #\n  def remove\n    @stack.pop\n  end\n\n  #\n  # Puts option summary into +to+ and returns +to+. Yields each line if\n  # a block is given.\n  #\n  # +to+:: Output destination, which must have method <<. Defaults to [].\n  # +width+:: Width of left side, defaults to @summary_width.\n  # +max+:: Maximum length allowed for left side, defaults to +width+ - 1.\n  # +indent+:: Indentation, defaults to @summary_indent.\n  #\n  def summarize(to = [], width = @summary_width, max = width - 1, indent = @summary_indent, &blk)\n    blk ||= proc {|l| to << (l.index($/, -1) ? l : l + $/)}\n    visit(:summarize, {}, {}, width, max, indent, &blk)\n    to\n  end\n\n  #\n  # Returns option summary string.\n  #\n  def help; summarize(banner.to_s.sub(/\\n?\\z/, \"\\n\")) end\n  alias to_s help\n\n  #\n  # Returns option summary list.\n  #\n  def to_a; summarize(banner.to_a.dup) end\n\n  #\n  # Checks if an argument is given twice, in which case an ArgumentError is\n  # raised. Called from OptionParser#switch only.\n  #\n  # +obj+:: New argument.\n  # +prv+:: Previously specified argument.\n  # +msg+:: Exception message.\n  #\n  def notwice(obj, prv, msg)\n    unless !prv or prv == obj\n      begin\n        raise ArgumentError, \"argument #{msg} given twice: #{obj}\"\n      rescue\n        $@[0, 2] = nil\n        raise\n      end\n    end\n    obj\n  end\n  private :notwice\n\n  #\n  # Creates an OptionParser::Switch from the parameters. The parsed argument\n  # value is passed to the given block, where it can be processed.\n  #\n  # See at the beginning of OptionParser for some full examples.\n  #\n  # +opts+ can include the following elements:\n  #\n  # [Argument style:]\n  #   One of the following:\n  #     :NONE, :REQUIRED, :OPTIONAL\n  #\n  # [Argument pattern:]\n  #   Acceptable option argument format, must be pre-defined with\n  #   OptionParser.accept or OptionParser#accept, or Regexp. This can appear\n  #   once or assigned as String if not present, otherwise causes an\n  #   ArgumentError. Examples:\n  #     Float, Time, Array\n  #\n  # [Possible argument values:]\n  #   Hash or Array.\n  #     [:text, :binary, :auto]\n  #     %w[iso-2022-jp shift_jis euc-jp utf8 binary]\n  #     { \"jis\" => \"iso-2022-jp\", \"sjis\" => \"shift_jis\" }\n  #\n  # [Long style switch:]\n  #   Specifies a long style switch which takes a mandatory, optional or no\n  #   argument. It's a string of the following form:\n  #     \"--switch=MANDATORY\" or \"--switch MANDATORY\"\n  #     \"--switch[=OPTIONAL]\"\n  #     \"--switch\"\n  #\n  # [Short style switch:]\n  #   Specifies short style switch which takes a mandatory, optional or no\n  #   argument. It's a string of the following form:\n  #     \"-xMANDATORY\"\n  #     \"-x[OPTIONAL]\"\n  #     \"-x\"\n  #   There is also a special form which matches character range (not full\n  #   set of regular expression):\n  #     \"-[a-z]MANDATORY\"\n  #     \"-[a-z][OPTIONAL]\" \n  #     \"-[a-z]\"\n  #\n  # [Argument style and descriptio"..., 4096) = 4096
brk(0x9fd4000)                          = 0x9fd4000
read(3, "ameter, this separate parameter can be used.\n  #     \"=MANDATORY\"\n  #     \"=[OPTIONAL]\"\n  #\n  # [Description:]\n  #   Description string for the option.\n  #     \"Run verbosely\"\n  # \n  # [Handler:]\n  #   Handler for the parsed argument value. Either give a block or pass a\n  #   Proc or Method as an argument.\n  #\n  def make_switch(opts, block = nil)\n    short, long, nolong, style, pattern, conv, not_pattern, not_conv, not_style = [], [], []\n    ldesc, sdesc, desc, arg = [], [], []\n    default_style = Switch::NoArgument\n    default_pattern = nil\n    klass = nil\n    o = nil\n    n, q, a = nil\n\n    opts.each do |o|\n      # argument class\n      next if search(:atype, o) do |pat, c|\n        klass = notwice(o, klass, 'type')\n        if not_style and not_style != Switch::NoArgument\n          not_pattern, not_conv = pat, c\n        else\n          default_pattern, conv = pat, c\n        end\n      end\n\n      # directly specified pattern(any object possible to match)\n      if !(String === o) and o.respond_to?(:match)\n        pattern = notwice(o, pattern, 'pattern')\n        conv = pattern.method(:convert).to_proc if pattern.respond_to?(:convert)\n        next\n      end\n\n      # anything others\n      case o\n      when Proc, Method\n        block = notwice(o, block, 'block')\n      when Array, Hash\n        case pattern\n        when CompletingHash\n        when nil\n          pattern = CompletingHash.new\n          conv = pattern.method(:convert).to_proc if pattern.respond_to?(:convert)\n        else\n          raise ArgumentError, \"argument pattern given twice\"\n        end\n        o.each {|(o, *v)| pattern[o] = v.fetch(0) {o}}\n      when Module\n        raise ArgumentError, \"unsupported argument type: #{o}\"\n      when *ArgumentStyle.keys\n        style = notwice(ArgumentStyle[o], style, 'style')\n      when /^--no-([^\\[\\]=\\s]*)(.+)?/\n        q, a = $1, $2\n        o = notwice(a ? Object : TrueClass, klass, 'type')\n        not_pattern, not_conv = search(:atype, o) unless not_style\n        not_style = (not_style || default_style).guess(arg = a) if a\n        default_style = Switch::NoArgument\n        default_pattern, conv = search(:atype, FalseClass) unless default_pattern\n        ldesc << \"--no-#{q}\"\n        long << 'no-' + (q = q.downcase)\n        nolong << q\n      when /^--\\[no-\\]([^\\[\\]=\\s]*)(.+)?/\n        q, a = $1, $2\n        o = notwice(a ? Object : TrueClass, klass, 'type')\n        if a\n          default_style = default_style.guess(arg = a)\n          default_pattern, conv = search(:atype, o) unless default_pattern\n        end\n        ldesc << \"--[no-]#{q}\"\n        long << (o = q.downcase)\n        not_pattern, not_conv = search(:atype, FalseClass) unless not_style\n        not_style = Switch::NoArgument\n        nolong << 'no-' + o\n      when /^--([^\\[\\]=\\s]*)(.+)?/\n        q, a = $1, $2\n        if a\n          o = notwice(NilClass, klass, 'type')\n          default_style = default_style.guess(arg = a)\n          default_pattern, conv = search(:atype, o) unless default_pattern\n        end\n        ldesc << \"--#{q}\"\n        long << (o = q.downcase)\n      when /^-(\\[\\^?\\]?(?:[^\\\\\\]]|\\\\.)*\\])(.+)?/\n        q, a = $1, $2\n        o = notwice(Object, klass, 'type')\n        if a\n          default_style = default_style.guess(arg = a)\n          default_pattern, conv = search(:atype, o) unless default_pattern\n        end\n        sdesc << \"-#{q}\"\n        short << Regexp.new(q)\n      when /^-(.)(.+)?/\n        q, a = $1, $2\n        if a\n          o = notwice(NilClass, klass, 'type')\n          default_style = default_style.guess(arg = a)\n          default_pattern, conv = search(:atype, o) unless default_pattern\n        end\n        sdesc << \"-#{q}\"\n        short << q\n      when /^=/\n        style = notwice(default_style.guess(arg = o), style, 'style')\n        default_pattern, conv = search(:atype, Object) unless default_pattern\n      else\n        desc.push(o)\n      end\n    end\n\n    default_pattern, conv = search(:atype, default_style.pattern) unless default_pattern\n    if !("..., 4096) = 4096
read(3, "\n                                       conv, sdesc, ldesc, arg, desc, block)\n    elsif !block\n      raise ArgumentError, \"no switch given\" if style or pattern\n      s = desc\n    else\n      short << pattern\n      s = (style || default_style).new(pattern,\n                                       conv, nil, nil, arg, desc, block)\n    end\n    return s, short, long,\n      (not_style.new(not_pattern, not_conv, sdesc, ldesc, nil, desc, block) if not_style),\n      nolong\n  end\n\n  def define(*opts, &block)\n    top.append(*(sw = make_switch(opts, block)))\n    sw[0]\n  end\n\n  #\n  # Add option switch and handler. See #make_switch for an explanation of\n  # parameters.\n  #\n  def on(*opts, &block)\n    define(*opts, &block)\n    self\n  end\n  alias def_option define\n\n  def define_head(*opts, &block)\n    top.prepend(*(sw = make_switch(opts, block)))\n    sw[0]\n  end\n\n  #\n  # Add option switch like with #on, but at head of summary.\n  #\n  def on_head(*opts, &block)\n    define_head(*opts, &block)\n    self\n  end\n  alias def_head_option define_head\n\n  def define_tail(*opts, &block)\n    base.append(*(sw = make_switch(opts, block)))\n    sw[0]\n  end\n\n  #\n  # Add option switch like with #on, but at tail of summary.\n  #\n  def on_tail(*opts, &block)\n    define_tail(*opts, &block)\n    self\n  end\n  alias def_tail_option define_tail\n\n  #\n  # Add separator in summary.\n  #\n  def separator(string)\n    top.append(string, nil, nil)\n  end\n\n  #\n  # Parses command line arguments +argv+ in order. When a block is given,\n  # each non-option argument is yielded.\n  #\n  # Returns the rest of +argv+ left unparsed.\n  #\n  def order(*argv, &block)\n    argv = argv[0].dup if argv.size == 1 and Array === argv[0]\n    order!(argv, &block)\n  end\n\n  #\n  # Same as #order, but removes switches destructively.\n  #\n  def order!(argv = default_argv, &nonopt)\n    parse_in_order(argv, &nonopt)\n  end\n\n  def parse_in_order(argv = default_argv, setter = nil, &nonopt)  # :nodoc:\n    opt, arg, sw, val, rest = nil\n    nonopt ||= proc {|arg| throw :terminate, arg}\n    argv.unshift(arg) if arg = catch(:terminate) {\n      while arg = argv.shift\n        case arg\n        # long option\n        when /\\A--([^=]*)(?:=(.*))?/nm\n          opt, rest = $1, $2\n          begin\n            sw, = complete(:long, opt, true)\n          rescue ParseError\n            raise $!.set_option(arg, true)\n          end\n          begin\n            opt, cb, val = sw.parse(rest, argv) {|*exc| raise(*exc)}\n            val = cb.call(val) if cb\n            setter.call(sw.switch_name, val) if setter\n          rescue ParseError\n            raise $!.set_option(arg, rest)\n          end\n\n        # short option\n        when /\\A-(.)((=).*|.+)?/nm\n          opt, has_arg, eq, val, rest = $1, $3, $3, $2, $2\n          begin\n            sw, = search(:short, opt)\n            unless sw\n              begin\n                sw, = complete(:short, opt)\n                # short option matched.\n                val = arg.sub(/\\A-/, '')\n                has_arg = true\n              rescue InvalidOption\n                # if no short options match, try completion with long\n                # options.\n                sw, = complete(:long, opt)\n                eq ||= !rest\n              end\n            end\n          rescue ParseError\n            raise $!.set_option(arg, true)\n          end\n          begin\n            opt, cb, val = sw.parse(val, argv) {|*exc| raise(*exc) if eq}\n            raise InvalidOption, arg if has_arg and !eq and arg == \"-#{opt}\"\n            argv.unshift(opt) if opt and (opt = opt.sub(/\\A-*/, '-')) != '-'\n            val = cb.call(val) if cb\n            setter.call(sw.switch_name, val) if setter\n          rescue ParseError\n            raise $!.set_option(arg, arg.length > 2)\n          end\n\n        # non-option argument\n        else\n          catch(:prune) do\n            visit(:each_option) do |sw|\n              sw.block.call(arg) if Switch === sw and sw.match_nonswitch?(arg)\n            end\n            nonopt.call(arg)\n          end\n       "..., 4096) = 4096
read(3, "sw.pattern}\n\n    argv\n  end\n  private :parse_in_order\n\n  #\n  # Parses command line arguments +argv+ in permutation mode and returns\n  # list of non-option arguments.\n  #\n  def permute(*argv)\n    argv = argv[0].dup if argv.size == 1 and Array === argv[0]\n    permute!(argv)\n  end\n\n  #\n  # Same as #permute, but removes switches destructively.\n  #\n  def permute!(argv = default_argv)\n    nonopts = []\n    arg = nil\n    order!(argv) {|arg| nonopts << arg}\n    argv[0, 0] = nonopts\n    argv\n  end\n\n  #\n  # Parses command line arguments +argv+ in order when environment variable\n  # POSIXLY_CORRECT is set, and in permutation mode otherwise.\n  #\n  def parse(*argv)\n    argv = argv[0].dup if argv.size == 1 and Array === argv[0]\n    parse!(argv)\n  end\n\n  #\n  # Same as #parse, but removes switches destructively.\n  #\n  def parse!(argv = default_argv)\n    if ENV.include?('POSIXLY_CORRECT')\n      order!(argv)\n    else\n      permute!(argv)\n    end\n  end\n\n  #\n  # Wrapper method for getopts.rb.\n  #\n  #   params = ARGV.getopts(\"ab:\", \"foo\", \"bar:\")\n  #   # params[:a] = true   # -a\n  #   # params[:b] = \"1\"    # -b1\n  #   # params[:foo] = \"1\"  # --foo\n  #   # params[:bar] = \"x\"  # --bar x\n  #\n  def getopts(*args)\n    argv = Array === args.first ? args.shift : default_argv\n    single_options, *long_options = *args\n\n    result = {}\n\n    single_options.scan(/(.)(:)?/) do |opt, val|\n      if val\n        result[opt] = nil\n        define(\"-#{opt} VAL\")\n      else\n        result[opt] = false\n        define(\"-#{opt}\")\n      end\n    end if single_options\n\n    long_options.each do |arg|\n      opt, val = arg.split(':', 2)\n      if val\n        result[opt] = val.empty? ? nil : val\n        define(\"--#{opt} VAL\")\n      else\n        result[opt] = false\n        define(\"--#{opt}\")\n      end\n    end\n\n    parse_in_order(argv, result.method(:[]=))\n    result\n  end\n\n  #\n  # See #getopts.\n  #\n  def self.getopts(*args)\n    new.getopts(*args)\n  end\n\n  #\n  # Traverses @stack, sending each element method +id+ with +args+ and\n  # +block+.\n  #\n  def visit(id, *args, &block)\n    el = nil\n    @stack.reverse_each do |el|\n      el.send(id, *args, &block)\n    end\n    nil\n  end\n  private :visit\n\n  #\n  # Searches +key+ in @stack for +id+ hash and returns or yields the result.\n  #\n  def search(id, key)\n    block_given = block_given?\n    visit(:search, id, key) do |k|\n      return block_given ? yield(k) : k\n    end\n  end\n  private :search\n\n  #\n  # Completes shortened long style option switch and returns pair of\n  # canonical switch and switch descriptor OptionParser::Switch.\n  #\n  # +id+::    Searching table.\n  # +opt+::   Searching key.\n  # +icase+:: Search case insensitive if true.\n  # +pat+::   Optional pattern for completion.\n  #\n  def complete(typ, opt, icase = false, *pat)\n    if pat.empty?\n      search(typ, opt) {|sw| return [sw, opt]} # exact match or...\n    end\n    raise AmbiguousOption, catch(:ambiguous) {\n      visit(:complete, typ, opt, icase, *pat) {|opt, *sw| return sw}\n      raise InvalidOption, opt\n    }\n  end\n  private :complete\n\n  #\n  # Loads options from file names as +filename+. Does nothing when the file\n  # is not present. Returns whether successfully loaded.\n  #\n  # +filename+ defaults to basename of the program without suffix in a\n  # directory ~/.options.\n  #\n  def load(filename = nil)\n    begin\n      filename ||= File.expand_path(File.basename($0, '.*'), '~/.options')\n    rescue\n      return false\n    end\n    begin\n      parse(*IO.readlines(filename).each {|s| s.chomp!})\n      true\n    rescue Errno::ENOENT, Errno::ENOTDIR\n      false\n    end\n  end\n\n  #\n  # Parses environment variable +env+ or its uppercase with splitting like a\n  # shell.\n  #\n  # +env+ defaults to the basename of the program.\n  #\n  def environment(env = File.basename($0, '.*'))\n    env = ENV[env] || ENV[env.upcase] or return\n    require 'shellwords'\n    parse(*Shellwords.shellwords(env))\n  end\n\n  #\n  # Acceptable argument classes\n  #\n\n  #\n  # Any string and no conversion. This is fall-back.\n  #\n  "..., 4096) = 4096
read(3, "no conversion.\n  #\n  accept(String, /.+/nm) {|s,*|s}\n\n  #\n  # Ruby/C-like integer, octal for 0-7 sequence, binary for 0b, hexadecimal\n  # for 0x, and decimal for others; with optional sign prefix. Converts to\n  # Integer.\n  #\n  decimal = '\\d+(?:_\\d+)*'\n  binary = 'b[01]+(?:_[01]+)*'\n  hex = 'x[\\da-f]+(?:_[\\da-f]+)*'\n  octal = \"0(?:[0-7]*(?:_[0-7]+)*|#{binary}|#{hex})\"\n  integer = \"#{octal}|#{decimal}\"\n  accept(Integer, %r\"\\A[-+]?(?:#{integer})\"io) {|s,| Integer(s) if s}\n\n  #\n  # Float number format, and converts to Float.\n  #\n  float = \"(?:#{decimal}(?:\\\\.(?:#{decimal})?)?|\\\\.#{decimal})(?:E[-+]?#{decimal})?\"\n  floatpat = %r\"\\A[-+]?#{float}\"io\n  accept(Float, floatpat) {|s,| s.to_f if s}\n\n  #\n  # Generic numeric format, converts to Integer for integer format, Float\n  # for float format.\n  #\n  accept(Numeric, %r\"\\A[-+]?(?:#{octal}|#{float})\"io) {|s,| eval(s) if s}\n\n  #\n  # Decimal integer format, to be converted to Integer.\n  #\n  DecimalInteger = /\\A[-+]?#{decimal}/io\n  accept(DecimalInteger) {|s,| s.to_i if s}\n\n  #\n  # Ruby/C like octal/hexadecimal/binary integer format, to be converted to\n  # Integer.\n  #\n  OctalInteger = /\\A[-+]?(?:[0-7]+(?:_[0-7]+)*|0(?:#{binary}|#{hex}))/io\n  accept(OctalInteger) {|s,| s.oct if s}\n\n  #\n  # Decimal integer/float number format, to be converted to Integer for\n  # integer format, Float for float format.\n  #\n  DecimalNumeric = floatpat     # decimal integer is allowed as float also.\n  accept(DecimalNumeric) {|s,| eval(s) if s}\n\n  #\n  # Boolean switch, which means whether it is present or not, whether it is\n  # absent or not with prefix no-, or it takes an argument\n  # yes/no/true/false/+/-.\n  #\n  yesno = CompletingHash.new\n  %w[- no false].each {|el| yesno[el] = false}\n  %w[+ yes true].each {|el| yesno[el] = true}\n  yesno['nil'] = false          # shoud be nil?\n  accept(TrueClass, yesno) {|arg, val| val == nil or val}\n  #\n  # Similar to TrueClass, but defaults to false.\n  #\n  accept(FalseClass, yesno) {|arg, val| val != nil and val}\n\n  #\n  # List of strings separated by \",\".\n  #\n  accept(Array) do |s,|\n    if s\n      s = s.split(',').collect {|s| s unless s.empty?}\n    end\n    s\n  end\n\n  #\n  # Regular expression with options.\n  #\n  accept(Regexp, %r\"\\A/((?:\\\\.|[^\\\\])*)/([[:alpha:]]+)?\\z|.*\") do |all, s, o|\n    f = 0\n    if o\n      f |= Regexp::IGNORECASE if /i/ =~ o\n      f |= Regexp::MULTILINE if /m/ =~ o\n      f |= Regexp::EXTENDED if /x/ =~ o\n      k = o.delete(\"^imx\")\n    end\n    Regexp.new(s || all, f, k)\n  end\n\n  #\n  # Exceptions\n  #\n\n  #\n  # Base class of exceptions from OptionParser.\n  #\n  class ParseError < RuntimeError\n    # Reason which caused the error.\n    Reason = 'parse error'.freeze\n\n    def initialize(*args)\n      @args = args\n      @reason = nil\n    end\n\n    attr_reader :args\n    attr_writer :reason\n\n    #\n    # Pushes back erred argument(s) to +argv+.\n    #\n    def recover(argv)\n      argv[0, 0] = @args\n      argv\n    end\n\n    def set_option(opt, eq)\n      if eq\n        @args[0] = opt\n      else\n        @args.unshift(opt)\n      end\n      self\n    end\n\n    #\n    # Returns error reason. Override this for I18N.\n    #\n    def reason\n      @reason || self.class::Reason\n    end\n\n    def inspect\n      \"#<#{self.class.to_s}: #{args.join(' ')}>\"\n    end\n\n    #\n    # Default stringizing method to emit standard error message.\n    #\n    def message\n      reason + ': ' + args.join(' ')\n    end\n\n    alias to_s message\n  end\n\n  #\n  # Raises when ambiguously completable string is encountered.\n  #\n  class AmbiguousOption < ParseError\n    const_set(:Reason, 'ambiguous option'.freeze)\n  end\n\n  #\n  # Raises when there is an argument for a switch which takes no argument.\n  #\n  class NeedlessArgument < ParseError\n    const_set(:Reason, 'needless argument'.freeze)\n  end\n\n  #\n  # Raises when a switch with mandatory argument has no argument.\n  #\n  class MissingArgument < ParseError\n    const_set(:Reason, 'missing argument'.freeze)\n  end\n\n  #\n  # Raises when switch is undefined.\n  #\n  class InvalidOpt"..., 4096) = 4096
read(3, "given argument does not match required format.\n  #\n  class InvalidArgument < ParseError\n    const_set(:Reason, 'invalid argument'.freeze)\n  end\n\n  #\n  # Raises when the given argument word can't be completed uniquely.\n  #\n  class AmbiguousArgument < InvalidArgument\n    const_set(:Reason, 'ambiguous argument'.freeze)\n  end\n\n  #\n  # Miscellaneous\n  #\n\n  #\n  # Extends command line arguments array (ARGV) to parse itself.\n  #\n  module Arguable\n\n    #\n    # Sets OptionParser object, when +opt+ is +false+ or +nil+, methods\n    # OptionParser::Arguable#options and OptionParser::Arguable#options= are\n    # undefined. Thus, there is no ways to access the OptionParser object\n    # via the receiver object.\n    #\n    def options=(opt)\n      unless @optparse = opt\n        class << self\n          undef_method(:options)\n          undef_method(:options=)\n        end\n      end\n    end\n\n    #\n    # Actual OptionParser object, automatically created if nonexistent.\n    #\n    # If called with a block, yields the OptionParser object and returns the\n    # result of the block. If an OptionParser::ParseError exception occurs\n    # in the block, it is rescued, a error message printed to STDERR and\n    # +nil+ returned.\n    #\n    def options\n      @optparse ||= OptionParser.new\n      @optparse.default_argv = self\n      block_given? or return @optparse\n      begin\n        yield @optparse\n      rescue ParseError\n        @optparse.warn $!\n        nil\n      end\n    end\n\n    #\n    # Parses +self+ destructively in order and returns +self+ containing the\n    # rest arguments left unparsed.\n    #\n    def order!(&blk) options.order!(self, &blk) end\n\n    #\n    # Parses +self+ destructively in permutation mode and returns +self+\n    # containing the rest arguments left unparsed.\n    #\n    def permute!() options.permute!(self) end\n\n    #\n    # Parses +self+ destructively and returns +self+ containing the\n    # rest arguments left unparsed.\n    #\n    def parse!() options.parse!(self) end\n\n    #\n    # Substitution of getopts is possible as follows. Also see\n    # OptionParser#getopts.\n    #\n    #   def getopts(*args)\n    #     ($OPT = ARGV.getopts(*args)).each do |opt, val|\n    #       eval \"$OPT_#{opt.gsub(/[^A-Za-z0-9_]/, '_')} = val\"\n    #     end\n    #   rescue OptionParser::ParseError\n    #   end\n    #\n    def getopts(*args)\n      options.getopts(self, *args)\n    end\n\n    #\n    # Initializes instance variable.\n    #\n    def self.extend_object(obj)\n      super\n      obj.instance_eval {@optparse = nil}\n    end\n    def initialize(*args)\n      super\n      @optparse = nil\n    end\n  end\n\n  #\n  # Acceptable argument classes. Now contains DecimalInteger, OctalInteger\n  # and DecimalNumeric. See Acceptable argument classes (in source code).\n  #\n  module Acceptables\n    const_set(:DecimalInteger, OptionParser::DecimalInteger)\n    const_set(:OctalInteger, OptionParser::OctalInteger)\n    const_set(:DecimalNumeric, OptionParser::DecimalNumeric)\n  end\nend\n\n# ARGV is arguable by OptionParser\nARGV.extend(OptionParser::Arguable)\n\nif $0 == __FILE__\n  Version = OptionParser::Version\n  ARGV.options {|q|\n    q.parse!.empty? or puts \"what's #{ARGV.join(' ')}?\"\n  } or abort(ARGV.options.to_s)\nend\n", 4096) = 3196
brk(0x9ff5000)                          = 0x9ff5000
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/user_interaction.rb", 0xbfe4e930) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/user_interaction.so", 0xbfe4e930) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/user_interaction.rb", {st_mode=S_IFREG|0644, st_size=7438, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/user_interaction.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=7438, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/user_interaction.rb", 0xbfe4ff60) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/user_interaction.so", 0xbfe4ff60) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/user_interaction.rb", {st_mode=S_IFREG|0644, st_size=7438, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/user_interaction.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=7438, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/abstract_command.rb", {st_mode=S_IFREG|0644, st_size=2658, ...}) = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/abstract_command.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2658, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/abstract_command.rb", {st_mode=S_IFREG|0644, st_size=2658, ...}) = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/abstract_command.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2658, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/abstract_command.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2658, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/abstract_command.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/abstract_command.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2658, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "require 'rubygems/local_remote_options'\n\nclass Gem::AbstractCommand < Gem::Command\n  include Gem::LocalRemoteOptions\n\n  def gemcutter_url\n    ENV['GEMCUTTER_URL'] || 'https://gemcutter.org'\n  end\n\n  def setup\n    use_proxy! if http_proxy\n    sign_in unless api_key\n  end\n\n  def sign_in\n    say \"Enter your Gemcutter credentials. Don't have an account yet? Create one at http://gemcutter.org/sign_up\"\n\n    email = ask(\"Email: \")\n    password = ask_for_password(\"Password: \")\n\n    response = make_request(:get, \"api_key\") do |request|\n      request.basic_auth email, password\n    end\n\n    case response\n    when Net::HTTPSuccess\n      self.api_key = response.body\n      say \"Signed in. Your api key has been stored in ~/.gem/credentials\"\n    else\n      say response.body\n      terminate_interaction\n    end\n  end\n\n  def credentials_path\n    File.join(Gem.user_home, '.gem', 'credentials')\n  end\n\n  def api_key\n    Gem.configuration.load_file(credentials_path)[:rubygems_api_key]\n  end\n\n  def api_key=(api_key)\n    config = Gem.configuration.load_file(credentials_path).merge(:rubygems_api_key => api_key)\n\n    dirname = File.dirname(credentials_path)\n    Dir.mkdir(dirname) unless File.exists?(dirname)\n\n    File.open(credentials_path, 'w') do |f|\n      f.write config.to_yaml\n    end\n\n    @rubygems_api_key = api_key\n  end\n\n  def make_request(method, path)\n    require 'net/http'\n    require 'net/https'\n\n    url = URI.parse(\"#{gemcutter_url}/api/v1/#{path}\")\n\n    http = proxy_class.new(url.host, url.port)\n\n    if url.scheme == 'https'\n      http.verify_mode = OpenSSL::SSL::VERIFY_NONE\n      http.use_ssl = true\n    end\n\n    request_method =\n      case method\n      when :get\n        proxy_class::Get\n      when :post\n        proxy_class::Post\n      when :put\n        proxy_class::Put\n      when :delete\n        proxy_class::Delete\n      else\n        raise ArgumentError\n      end\n\n    request = request_method.new(url.path)\n    request.add_field \"User-Agent\", \"Gemcutter/0.2.0\"\n\n    yield request if block_given?\n    http.request(request)\n  end\n\n  def use_proxy!\n    proxy_uri = http_proxy\n    @proxy_class = Net::HTTP::Proxy(proxy_uri.host, proxy_uri.port, proxy_uri.user, proxy_uri.password)\n  end\n\n  def proxy_class\n    @proxy_class || Net::HTTP\n  end\n\n  # @return [URI, nil] the HTTP-proxy as a URI if set; +nil+ otherwise\n  def http_proxy\n    proxy = Gem.configuration[:http_proxy] || ENV['http_proxy'] || ENV['HTTP_PROXY']\n    return nil if proxy.nil? || proxy == :no_proxy\n    URI.parse(proxy)\n  end\n\n  def ask_for_password(message)\n    system \"stty -echo\"\n    password = ask(message)\n    system \"stty echo\"\n    ui.say(\"\\n\")\n    password\n  end\nend\n", 4096) = 2658
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/local_remote_options.rb", 0xbfe4ff80) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/local_remote_options.so", 0xbfe4ff80) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/local_remote_options.rb", {st_mode=S_IFREG|0644, st_size=3188, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/local_remote_options.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3188, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/local_remote_options.rb", 0xbfe4ff90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/local_remote_options.rb", {st_mode=S_IFREG|0644, st_size=3188, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/local_remote_options.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3188, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/local_remote_options.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3188, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/local_remote_options.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/local_remote_options.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3188, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\nrequire 'uri'\nrequire 'rubygems'\n\n##\n# Mixin methods for local and remote Gem::Command options.\n\nmodule Gem::LocalRemoteOptions\n\n  ##\n  # Allows OptionParser to handle HTTP URIs.\n\n  def accept_uri_http\n    OptionParser.accept URI::HTTP do |value|\n      begin\n        uri = URI.parse value\n      rescue URI::InvalidURIError\n        raise OptionParser::InvalidArgument, value\n      end\n\n      unless ['http', 'https', 'file'].include?(uri.scheme)\n         raise OptionParser::InvalidArgument, value\n      end\n\n      value\n    end\n  end\n\n  ##\n  # Add local/remote options to the command line parser.\n\n  def add_local_remote_options\n    add_option(:\"Local/Remote\", '-l', '--local',\n               'Restrict operations to the LOCAL domain') do |value, options|\n      options[:domain] = :local\n    end\n\n    add_option(:\"Local/Remote\", '-r', '--remote',\n      'Restrict operations to the REMOTE domain') do |value, options|\n      options[:domain] = :remote\n    end\n\n    add_option(:\"Local/Remote\", '-b', '--both',\n               'Allow LOCAL and REMOTE operations') do |value, options|\n      options[:domain] = :both\n    end\n\n    add_bulk_threshold_option\n    add_source_option\n    add_proxy_option\n    add_update_sources_option\n  end\n\n  ##\n  # Add the --bulk-threshold option\n\n  def add_bulk_threshold_option\n    add_option(:\"Local/Remote\", '-B', '--bulk-threshold COUNT',\n               \"Threshold for switching to bulk\",\n               \"synchronization (default #{Gem.configuration.bulk_threshold})\") do\n      |value, options|\n      Gem.configuration.bulk_threshold = value.to_i\n    end\n  end\n\n  ##\n  # Add the --http-proxy option\n\n  def add_proxy_option\n    accept_uri_http\n\n    add_option(:\"Local/Remote\", '-p', '--[no-]http-proxy [URL]', URI::HTTP,\n               'Use HTTP proxy for remote operations') do |value, options|\n      options[:http_proxy] = (value == false) ? :no_proxy : value\n      Gem.configuration[:http_proxy] = options[:http_proxy]\n    end\n  end\n\n  ##\n  # Add the --source option\n\n  def add_source_option\n    accept_uri_http\n\n    add_option(:\"Local/Remote\", '--source URL', URI::HTTP,\n               'Use URL as the remote source for gems') do |source, options|\n      source << '/' if source !~ /\\/\\z/\n\n      if options[:added_source] then\n        Gem.sources << source unless Gem.sources.include?(source)\n      else\n        options[:added_source] = true\n        Gem.sources.replace [source]\n      end\n    end\n  end\n\n  ##\n  # Add the --update-source option\n\n  def add_update_sources_option\n\n    add_option(:\"Local/Remote\", '-u', '--[no-]update-sources',\n               'Update local source cache') do |value, options|\n      Gem.configuration.update_sources = value\n    end\n  end\n\n  ##\n  # Is fetching of local and remote information enabled?\n\n  def both?\n    options[:domain] == :both\n  end\n\n  ##\n  # Is local fetching enabled?\n\n  def local?\n    options[:domain] == :local || options[:domain] == :both\n  end\n\n  ##\n  # Is remote fetching enabled?\n\n  def remote?\n    options[:domain] == :remote || options[:domain] == :both\n  end\n\nend\n\n", 4096) = 3188
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri.rb", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri.so", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri.rb", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri.so", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri.rb", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri.so", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri.rb", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri.so", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri.rb", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri.so", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri.rb", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri.so", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri.rb", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri.so", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri.rb", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri.so", 0xbfe4e950) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri.rb", {st_mode=S_IFREG|0644, st_size=710, ...}) = 0
open("/usr/lib/ruby/1.8/uri.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=710, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri.rb", 0xbfe4e960) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri.rb", 0xbfe4e960) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri.rb", 0xbfe4e960) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri.rb", 0xbfe4e960) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri.rb", 0xbfe4e960) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri.rb", 0xbfe4e960) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri.rb", 0xbfe4e960) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri.rb", 0xbfe4e960) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri.rb", {st_mode=S_IFREG|0644, st_size=710, ...}) = 0
open("/usr/lib/ruby/1.8/uri.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=710, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/uri.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=710, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/uri.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/uri.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=710, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "#\n# URI support for Ruby\n#\n# Author:: Akira Yamada <akira@ruby-lang.org>\n# Documentation:: Akira Yamada <akira@ruby-lang.org>, Dmitry V. Sabanin <sdmitry@lrn.ru>\n# License:: \n#  Copyright (c) 2001 akira yamada <akira@ruby-lang.org>\n#  You can redistribute it and/or modify it under the same term as Ruby.\n# Revision:: $Id: uri.rb 16038 2008-04-15 09:41:47Z kazu $\n# \n# See URI for documentation\n#\n\nmodule URI\n  # :stopdoc:\n  VERSION_CODE = '000911'.freeze\n  VERSION = VERSION_CODE.scan(/../).collect{|n| n.to_i}.join('.').freeze\n  # :startdoc:\n\nend\n\nrequire 'uri/common'\nrequire 'uri/generic'\nrequire 'uri/ftp'\nrequire 'uri/http'\nrequire 'uri/https'\nrequire 'uri/ldap'\nrequire 'uri/ldaps'\nrequire 'uri/mailto'\n", 4096) = 710
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/common.rb", 0xbfe4d320) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/common.so", 0xbfe4d320) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/common.rb", 0xbfe4d320) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/common.so", 0xbfe4d320) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/common.rb", 0xbfe4d320) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/common.so", 0xbfe4d320) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/common.rb", 0xbfe4d320) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/common.so", 0xbfe4d320) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/common.rb", 0xbfe4d320) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/common.so", 0xbfe4d320) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/common.rb", 0xbfe4d320) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/common.so", 0xbfe4d320) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/common.rb", 0xbfe4d320) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/common.so", 0xbfe4d320) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/common.rb", 0xbfe4d320) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/common.so", 0xbfe4d320) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/common.rb", {st_mode=S_IFREG|0644, st_size=17568, ...}) = 0
open("/usr/lib/ruby/1.8/uri/common.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=17568, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/common.rb", 0xbfe4d330) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/common.rb", 0xbfe4d330) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/common.rb", 0xbfe4d330) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/common.rb", 0xbfe4d330) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/common.rb", 0xbfe4d330) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/common.rb", 0xbfe4d330) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/common.rb", 0xbfe4d330) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/common.rb", 0xbfe4d330) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/common.rb", {st_mode=S_IFREG|0644, st_size=17568, ...}) = 0
open("/usr/lib/ruby/1.8/uri/common.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=17568, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/uri/common.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=17568, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/uri/common.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/uri/common.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=17568, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "# = uri/common.rb\n#\n# Author:: Akira Yamada <akira@ruby-lang.org>\n# Revision:: $Id: common.rb 14178 2007-12-10 09:31:55Z matz $\n# License:: \n#   You can redistribute it and/or modify it under the same term as Ruby.\n#\n\nmodule URI\n  module REGEXP\n    #\n    # Patterns used to parse URI's\n    #\n    module PATTERN\n      # :stopdoc:\n\n      # RFC 2396 (URI Generic Syntax)\n      # RFC 2732 (IPv6 Literal Addresses in URL's)\n      # RFC 2373 (IPv6 Addressing Architecture)\n\n      # alpha         = lowalpha | upalpha\n      ALPHA = \"a-zA-Z\"\n      # alphanum      = alpha | digit\n      ALNUM = \"#{ALPHA}\\\\d\"\n\n      # hex           = digit | \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" |\n      #                         \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\"\n      HEX     = \"a-fA-F\\\\d\"\n      # escaped       = \"%\" hex hex\n      ESCAPED = \"%[#{HEX}]{2}\"\n      # mark          = \"-\" | \"_\" | \".\" | \"!\" | \"~\" | \"*\" | \"'\" |\n      #                 \"(\" | \")\"\n      # unreserved    = alphanum | mark\n      UNRESERVED = \"-_.!~*'()#{ALNUM}\"\n      # reserved      = \";\" | \"/\" | \"?\" | \":\" | \"@\" | \"&\" | \"=\" | \"+\" |\n      #                 \"$\" | \",\"\n      # reserved      = \";\" | \"/\" | \"?\" | \":\" | \"@\" | \"&\" | \"=\" | \"+\" | \n      #                 \"$\" | \",\" | \"[\" | \"]\" (RFC 2732)\n      RESERVED = \";/?:@&=+$,\\\\[\\\\]\"\n\n      # uric          = reserved | unreserved | escaped\n      URIC = \"(?:[#{UNRESERVED}#{RESERVED}]|#{ESCAPED})\"\n      # uric_no_slash = unreserved | escaped | \";\" | \"?\" | \":\" | \"@\" |\n      #                 \"&\" | \"=\" | \"+\" | \"$\" | \",\"\n      URIC_NO_SLASH = \"(?:[#{UNRESERVED};?:@&=+$,]|#{ESCAPED})\"\n      # query         = *uric\n      QUERY = \"#{URIC}*\"\n      # fragment      = *uric\n      FRAGMENT = \"#{URIC}*\"\n\n      # domainlabel   = alphanum | alphanum *( alphanum | \"-\" ) alphanum\n      DOMLABEL = \"(?:[#{ALNUM}](?:[-#{ALNUM}]*[#{ALNUM}])?)\"\n      # toplabel      = alpha | alpha *( alphanum | \"-\" ) alphanum\n      TOPLABEL = \"(?:[#{ALPHA}](?:[-#{ALNUM}]*[#{ALNUM}])?)\"\n      # hostname      = *( domainlabel \".\" ) toplabel [ \".\" ]\n      HOSTNAME = \"(?:#{DOMLABEL}\\\\.)*#{TOPLABEL}\\\\.?\"\n\n      # RFC 2373, APPENDIX B:\n      # IPv6address = hexpart [ \":\" IPv4address ]\n      # IPv4address   = 1*3DIGIT \".\" 1*3DIGIT \".\" 1*3DIGIT \".\" 1*3DIGIT\n      # hexpart = hexseq | hexseq \"::\" [ hexseq ] | \"::\" [ hexseq ]\n      # hexseq  = hex4 *( \":\" hex4)\n      # hex4    = 1*4HEXDIG\n      #\n      # XXX: This definition has a flaw. \"::\" + IPv4address must be\n      # allowed too.  Here is a replacement.\n      #\n      # IPv4address = 1*3DIGIT \".\" 1*3DIGIT \".\" 1*3DIGIT \".\" 1*3DIGIT\n      IPV4ADDR = \"\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\\\\.\\\\d{1,3}\"\n      # hex4     = 1*4HEXDIG\n      HEX4 = \"[#{HEX}]{1,4}\"\n      # lastpart = hex4 | IPv4address\n      LASTPART = \"(?:#{HEX4}|#{IPV4ADDR})\"\n      # hexseq1  = *( hex4 \":\" ) hex4\n      HEXSEQ1 = \"(?:#{HEX4}:)*#{HEX4}\"\n      # hexseq2  = *( hex4 \":\" ) lastpart\n      HEXSEQ2 = \"(?:#{HEX4}:)*#{LASTPART}\"\n      # IPv6address = hexseq2 | [ hexseq1 ] \"::\" [ hexseq2 ]\n      IPV6ADDR = \"(?:#{HEXSEQ2}|(?:#{HEXSEQ1})?::(?:#{HEXSEQ2})?)\"\n\n      # IPv6prefix  = ( hexseq1 | [ hexseq1 ] \"::\" [ hexseq1 ] ) \"/\" 1*2DIGIT\n      # unused\n\n      # ipv6reference = \"[\" IPv6address \"]\" (RFC 2732)\n      IPV6REF = \"\\\\[#{IPV6ADDR}\\\\]\"\n\n      # host          = hostname | IPv4address\n      # host          = hostname | IPv4address | IPv6reference (RFC 2732)\n      HOST = \"(?:#{HOSTNAME}|#{IPV4ADDR}|#{IPV6REF})\"\n      # port          = *digit\n      PORT = '\\d*'\n      # hostport      = host [ \":\" port ]\n      HOSTPORT = \"#{HOST}(?::#{PORT})?\"\n\n      # userinfo      = *( unreserved | escaped |\n      #                    \";\" | \":\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\" )\n      USERINFO = \"(?:[#{UNRESERVED};:&=+$,]|#{ESCAPED})*\"\n\n      # pchar         = unreserved | escaped |\n      #                 \":\" | \"@\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\"\n      PCHAR = \"(?:[#{UNRESERVED}:@&=+$,]|#{ESCAPED})\"\n      # param         = *pchar\n      PARAM = \"#{PCHAR}*\"\n      # segment       = *pchar *( \";\" param )\n      SEGME"..., 4096) = 4096
read(3, "NTS = \"#{SEGMENT}(?:/#{SEGMENT})*\"\n\n      # server        = [ [ userinfo \"@\" ] hostport ]\n      SERVER = \"(?:#{USERINFO}@)?#{HOSTPORT}\"\n      # reg_name      = 1*( unreserved | escaped | \"$\" | \",\" |\n      #                     \";\" | \":\" | \"@\" | \"&\" | \"=\" | \"+\" )\n      REG_NAME = \"(?:[#{UNRESERVED}$,;:@&=+]|#{ESCAPED})+\"\n      # authority     = server | reg_name\n      AUTHORITY = \"(?:#{SERVER}|#{REG_NAME})\"\n\n      # rel_segment   = 1*( unreserved | escaped |\n      #                     \";\" | \"@\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\" )\n      REL_SEGMENT = \"(?:[#{UNRESERVED};@&=+$,]|#{ESCAPED})+\"\n\n      # scheme        = alpha *( alpha | digit | \"+\" | \"-\" | \".\" )\n      SCHEME = \"[#{ALPHA}][-+.#{ALPHA}\\\\d]*\"\n\n      # abs_path      = \"/\"  path_segments\n      ABS_PATH = \"/#{PATH_SEGMENTS}\"\n      # rel_path      = rel_segment [ abs_path ]\n      REL_PATH = \"#{REL_SEGMENT}(?:#{ABS_PATH})?\"\n      # net_path      = \"//\" authority [ abs_path ]\n      NET_PATH   = \"//#{AUTHORITY}(?:#{ABS_PATH})?\"\n\n      # hier_part     = ( net_path | abs_path ) [ \"?\" query ]\n      HIER_PART   = \"(?:#{NET_PATH}|#{ABS_PATH})(?:\\\\?(?:#{QUERY}))?\"\n      # opaque_part   = uric_no_slash *uric\n      OPAQUE_PART = \"#{URIC_NO_SLASH}#{URIC}*\"\n\n      # absoluteURI   = scheme \":\" ( hier_part | opaque_part )\n      ABS_URI   = \"#{SCHEME}:(?:#{HIER_PART}|#{OPAQUE_PART})\"\n      # relativeURI   = ( net_path | abs_path | rel_path ) [ \"?\" query ]\n      REL_URI = \"(?:#{NET_PATH}|#{ABS_PATH}|#{REL_PATH})(?:\\\\?#{QUERY})?\"\n\n      # URI-reference = [ absoluteURI | relativeURI ] [ \"#\" fragment ]\n      URI_REF = \"(?:#{ABS_URI}|#{REL_URI})?(?:##{FRAGMENT})?\"\n\n      # XXX:\n      X_ABS_URI = \"\n        (#{PATTERN::SCHEME}):                     (?# 1: scheme)\n        (?:\n           (#{PATTERN::OPAQUE_PART})              (?# 2: opaque)\n        |\n           (?:(?:\n             //(?:\n                 (?:(?:(#{PATTERN::USERINFO})@)?  (?# 3: userinfo)\n                   (?:(#{PATTERN::HOST})(?::(\\\\d*))?))?(?# 4: host, 5: port)\n               |\n                 (#{PATTERN::REG_NAME})           (?# 6: registry)\n               )\n             |\n             (?!//))                              (?# XXX: '//' is the mark for hostport)\n             (#{PATTERN::ABS_PATH})?              (?# 7: path)\n           )(?:\\\\?(#{PATTERN::QUERY}))?           (?# 8: query)\n        )\n        (?:\\\\#(#{PATTERN::FRAGMENT}))?            (?# 9: fragment)\n      \"\n      X_REL_URI = \"\n        (?:\n          (?:\n            //\n            (?:\n              (?:(#{PATTERN::USERINFO})@)?       (?# 1: userinfo)\n                (#{PATTERN::HOST})?(?::(\\\\d*))?  (?# 2: host, 3: port)\n            |\n              (#{PATTERN::REG_NAME})             (?# 4: registry)\n            )\n          )\n        |\n          (#{PATTERN::REL_SEGMENT})              (?# 5: rel_segment)\n        )?\n        (#{PATTERN::ABS_PATH})?                  (?# 6: abs_path)\n        (?:\\\\?(#{PATTERN::QUERY}))?              (?# 7: query)\n        (?:\\\\#(#{PATTERN::FRAGMENT}))?           (?# 8: fragment)\n      \"\n      # :startdoc:\n    end # PATTERN\n\n    # :stopdoc:\n\n    # for URI::split\n    ABS_URI = Regexp.new('^' + PATTERN::X_ABS_URI + '$', #'\n                         Regexp::EXTENDED, 'N').freeze\n    REL_URI = Regexp.new('^' + PATTERN::X_REL_URI + '$', #'\n                         Regexp::EXTENDED, 'N').freeze\n\n    # for URI::extract\n    URI_REF     = Regexp.new(PATTERN::URI_REF, false, 'N').freeze\n    ABS_URI_REF = Regexp.new(PATTERN::X_ABS_URI, Regexp::EXTENDED, 'N').freeze\n    REL_URI_REF = Regexp.new(PATTERN::X_REL_URI, Regexp::EXTENDED, 'N').freeze\n\n    # for URI::escape/unescape\n    ESCAPED = Regexp.new(PATTERN::ESCAPED, false, 'N').freeze\n    UNSAFE  = Regexp.new(\"[^#{PATTERN::UNRESERVED}#{PATTERN::RESERVED}]\",\n                         false, 'N').freeze\n\n    # for Generic#initialize\n    SCHEME   = Regexp.new(\"^#{PATTERN::SCHEME}$\", false, 'N').freeze #\"\n    USERINFO = Regexp.new(\"^#{PATTERN::USERINFO}$\", false, 'N').freeze #\"\n    HOST     = Regexp.new(\"^#{PATTERN::"..., 4096) = 4096
brk(0xa016000)                          = 0xa016000
read(3, "e #\"\n    OPAQUE   = Regexp.new(\"^#{PATTERN::OPAQUE_PART}$\", false, 'N').freeze #\"\n    REGISTRY = Regexp.new(\"^#{PATTERN::REG_NAME}$\", false, 'N').freeze #\"\n    ABS_PATH = Regexp.new(\"^#{PATTERN::ABS_PATH}$\", false, 'N').freeze #\"\n    REL_PATH = Regexp.new(\"^#{PATTERN::REL_PATH}$\", false, 'N').freeze #\"\n    QUERY    = Regexp.new(\"^#{PATTERN::QUERY}$\", false, 'N').freeze #\"\n    FRAGMENT = Regexp.new(\"^#{PATTERN::FRAGMENT}$\", false, 'N').freeze #\"\n    # :startdoc:\n  end # REGEXP\n\n  module Util # :nodoc:\n    def make_components_hash(klass, array_hash)\n      tmp = {}\n      if array_hash.kind_of?(Array) &&\n          array_hash.size == klass.component.size - 1\n        klass.component[1..-1].each_index do |i|\n          begin\n            tmp[klass.component[i + 1]] = array_hash[i].clone\n          rescue TypeError\n            tmp[klass.component[i + 1]] = array_hash[i]\n          end\n        end\n\n      elsif array_hash.kind_of?(Hash)\n        array_hash.each do |key, value|\n          begin\n            tmp[key] = value.clone\n          rescue TypeError\n            tmp[key] = value\n          end\n        end\n      else\n        raise ArgumentError, \n          \"expected Array of or Hash of components of #{klass.to_s} (#{klass.component[1..-1].join(', ')})\"\n      end\n      tmp[:scheme] = klass.to_s.sub(/\\A.*::/, '').downcase\n\n      return tmp\n    end\n    module_function :make_components_hash\n  end\n\n  module Escape\n    include REGEXP\n\n    #\n    # == Synopsis\n    #\n    #   URI.escape(str [, unsafe])\n    #\n    # == Args\n    #\n    # +str+::\n    #   String to replaces in.\n    # +unsafe+::\n    #   Regexp that matches all symbols that must be replaced with codes.\n    #   By default uses <tt>REGEXP::UNSAFE</tt>.\n    #   When this argument is a String, it represents a character set.\n    #\n    # == Description\n    #\n    # Escapes the string, replacing all unsafe characters with codes.\n    #\n    # == Usage\n    #\n    #   require 'uri'\n    #\n    #   enc_uri = URI.escape(\"http://example.com/?a=\\11\\15\")\n    #   p enc_uri\n    #   # => \"http://example.com/?a=%09%0D\"\n    #\n    #   p URI.unescape(enc_uri)\n    #   # => \"http://example.com/?a=\\t\\r\"\n    #\n    #   p URI.escape(\"@?@!\", \"!?\")\n    #   # => \"@%3F@%21\"\n    #\n    def escape(str, unsafe = UNSAFE)\n      unless unsafe.kind_of?(Regexp)\n        # perhaps unsafe is String object\n        unsafe = Regexp.new(\"[#{Regexp.quote(unsafe)}]\", false, 'N')\n      end\n      str.gsub(unsafe) do |us|\n        tmp = ''\n        us.each_byte do |uc|\n          tmp << sprintf('%%%02X', uc)\n        end\n        tmp\n      end\n    end\n    alias encode escape\n    #\n    # == Synopsis\n    #\n    #   URI.unescape(str)\n    #\n    # == Args\n    #\n    # +str+::\n    #   Unescapes the string.\n    #\n    # == Usage\n    #\n    #   require 'uri'\n    #\n    #   enc_uri = URI.escape(\"http://example.com/?a=\\11\\15\")\n    #   p enc_uri\n    #   # => \"http://example.com/?a=%09%0D\"\n    #\n    #   p URI.unescape(enc_uri)\n    #   # => \"http://example.com/?a=\\t\\r\"\n    #\n    def unescape(str)\n      str.gsub(ESCAPED) do\n        $&[1,2].hex.chr\n      end\n    end\n    alias decode unescape\n  end\n\n  include REGEXP\n  extend Escape\n\n  @@schemes = {}\n  \n  #\n  # Base class for all URI exceptions.\n  #\n  class Error < StandardError; end\n  #\n  # Not a URI.\n  #\n  class InvalidURIError < Error; end\n  #\n  # Not a URI component.\n  #\n  class InvalidComponentError < Error; end\n  #\n  # URI is valid, bad usage is not.\n  #\n  class BadURIError < Error; end\n\n  #\n  # == Synopsis\n  #\n  #   URI::split(uri)\n  #\n  # == Args\n  #\n  # +uri+::\n  #   String with URI.\n  #\n  # == Description\n  #\n  # Splits the string on following parts and returns array with result:\n  #\n  #   * Scheme\n  #   * Userinfo\n  #   * Host\n  #   * Port\n  #   * Registry\n  #   * Path\n  #   * Opaque\n  #   * Query\n  #   * Fragment\n  # \n  # == Usage\n  #\n  #   require 'uri'\n  #\n  #   p URI.split(\"http://www.ruby-lang.org/\")\n  #   # => [\"http\", nil, \"www.ruby-lang.org\", nil, nil, \"/\", nil, nil, nil]\n  #\n  def self.split(uri)\n    case"..., 4096) = 4096
read(3, "\n        registry, path, query, fragment = $~[1..-1]\n\n      # URI-reference = [ absoluteURI | relativeURI ] [ \"#\" fragment ]\n\n      # absoluteURI   = scheme \":\" ( hier_part | opaque_part )\n      # hier_part     = ( net_path | abs_path ) [ \"?\" query ]\n      # opaque_part   = uric_no_slash *uric\n\n      # abs_path      = \"/\"  path_segments\n      # net_path      = \"//\" authority [ abs_path ]\n\n      # authority     = server | reg_name\n      # server        = [ [ userinfo \"@\" ] hostport ]\n\n      if !scheme\n        raise InvalidURIError, \n          \"bad URI(absolute but no scheme): #{uri}\"\n      end\n      if !opaque && (!path && (!host && !registry))\n        raise InvalidURIError,\n          \"bad URI(absolute but no path): #{uri}\" \n      end\n\n    when REL_URI\n      scheme = nil\n      opaque = nil\n\n      userinfo, host, port, registry, \n        rel_segment, abs_path, query, fragment = $~[1..-1]\n      if rel_segment && abs_path\n        path = rel_segment + abs_path\n      elsif rel_segment\n        path = rel_segment\n      elsif abs_path\n        path = abs_path\n      end\n\n      # URI-reference = [ absoluteURI | relativeURI ] [ \"#\" fragment ]\n\n      # relativeURI   = ( net_path | abs_path | rel_path ) [ \"?\" query ]\n\n      # net_path      = \"//\" authority [ abs_path ]\n      # abs_path      = \"/\"  path_segments\n      # rel_path      = rel_segment [ abs_path ]\n\n      # authority     = server | reg_name\n      # server        = [ [ userinfo \"@\" ] hostport ]\n\n    else\n      raise InvalidURIError, \"bad URI(is not URI?): #{uri}\"\n    end\n\n    path = '' if !path && !opaque # (see RFC2396 Section 5.2)\n    ret = [\n      scheme, \n      userinfo, host, port,         # X\n      registry,                        # X\n      path,                         # Y\n      opaque,                        # Y\n      query,\n      fragment\n    ]\n    return ret\n  end\n\n  #\n  # == Synopsis\n  #\n  #   URI::parse(uri_str)\n  #\n  # == Args\n  #\n  # +uri_str+::\n  #   String with URI.\n  #\n  # == Description\n  #\n  # Creates one of the URI's subclasses instance from the string.\n  #  \n  # == Raises\n  #\n  # URI::InvalidURIError\n  #   Raised if URI given is not a correct one.\n  #\n  # == Usage\n  #\n  #   require 'uri'\n  #\n  #   uri = URI.parse(\"http://www.ruby-lang.org/\")\n  #   p uri\n  #   # => #<URI::HTTP:0x202281be URL:http://www.ruby-lang.org/>\n  #   p uri.scheme \n  #   # => \"http\" \n  #   p uri.host \n  #   # => \"www.ruby-lang.org\" \n  # \n  def self.parse(uri)\n    scheme, userinfo, host, port, \n      registry, path, opaque, query, fragment = self.split(uri)\n\n    if scheme && @@schemes.include?(scheme.upcase)\n      @@schemes[scheme.upcase].new(scheme, userinfo, host, port, \n                                   registry, path, opaque, query, \n                                   fragment)\n    else\n      Generic.new(scheme, userinfo, host, port, \n                  registry, path, opaque, query, \n                  fragment)\n    end\n  end\n\n  #\n  # == Synopsis\n  #\n  #   URI::join(str[, str, ...])\n  #\n  # == Args\n  #\n  # +str+::\n  #   String(s) to work with\n  #\n  # == Description\n  #\n  # Joins URIs.\n  #\n  # == Usage\n  #\n  #   require 'uri'\n  #\n  #   p URI.join(\"http://localhost/\",\"main.rbx\")\n  #   # => #<URI::HTTP:0x2022ac02 URL:http://localhost/main.rbx>\n  #\n  def self.join(*str)\n    u = self.parse(str[0])\n    str[1 .. -1].each do |x|\n      u = u.merge(x)\n    end\n    u\n  end\n\n  #\n  # == Synopsis\n  #\n  #   URI::extract(str[, schemes][,&blk])\n  #\n  # == Args\n  #\n  # +str+:: \n  #   String to extract URIs from.\n  # +schemes+::\n  #   Limit URI matching to a specific schemes.\n  #\n  # == Description\n  #\n  # Extracts URIs from a string. If block given, iterates through all matched URIs.\n  # Returns nil if block given or array with matches.\n  #\n  # == Usage\n  #\n  #   require \"uri\"\n  #\n  #   URI.extract(\"text here http://foo.example.org/bla and here mailto:test@example.com and here also.\")\n  #   # => [\"http://foo.example.com/bla\", \"mailto:test@example.com\"]\n  #\n  def self.extract(str, schemes = nil, &block)\n  "..., 4096) = 4096
read(3, " []\n      str.scan(regexp(schemes)) { result.push $& }\n      result\n    end\n  end\n\n  #\n  # == Synopsis\n  #\n  #   URI::regexp([match_schemes])\n  #\n  # == Args\n  #\n  # +match_schemes+:: \n  #   Array of schemes. If given, resulting regexp matches to URIs\n  #   whose scheme is one of the match_schemes.\n  # \n  # == Description\n  # Returns a Regexp object which matches to URI-like strings.\n  # The Regexp object returned by this method includes arbitrary\n  # number of capture group (parentheses).  Never rely on it's number.\n  # \n  # == Usage\n  #\n  #   require 'uri'\n  #\n  #   # extract first URI from html_string\n  #   html_string.slice(URI.regexp)\n  # \n  #   # remove ftp URIs\n  #   html_string.sub(URI.regexp(['ftp'])\n  # \n  #   # You should not rely on the number of parentheses\n  #   html_string.scan(URI.regexp) do |*matches|\n  #     p $&\n  #   end\n  #\n  def self.regexp(schemes = nil)\n    unless schemes\n      ABS_URI_REF\n    else\n      /(?=#{Regexp.union(*schemes)}:)#{PATTERN::X_ABS_URI}/xn\n    end\n  end\n\nend\n\nmodule Kernel\n  # alias for URI.parse.\n  #\n  # This method is introduced at 1.8.2.\n  def URI(uri_str) # :doc:\n    URI.parse(uri_str)\n  end\n  module_function :URI\nend\n", 4096) = 1184
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/generic.rb", 0xbfe4d300) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/generic.so", 0xbfe4d300) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/generic.rb", 0xbfe4d300) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/generic.so", 0xbfe4d300) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/generic.rb", 0xbfe4d300) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/generic.so", 0xbfe4d300) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/generic.rb", 0xbfe4d300) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/generic.so", 0xbfe4d300) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/generic.rb", 0xbfe4d300) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/generic.so", 0xbfe4d300) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/generic.rb", 0xbfe4d300) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/generic.so", 0xbfe4d300) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/generic.rb", 0xbfe4d300) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/generic.so", 0xbfe4d300) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/generic.rb", 0xbfe4d300) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/generic.so", 0xbfe4d300) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/generic.rb", {st_mode=S_IFREG|0644, st_size=24145, ...}) = 0
open("/usr/lib/ruby/1.8/uri/generic.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=24145, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/generic.rb", 0xbfe4d310) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/generic.rb", 0xbfe4d310) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/generic.rb", 0xbfe4d310) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/generic.rb", 0xbfe4d310) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/generic.rb", 0xbfe4d310) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/generic.rb", 0xbfe4d310) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/generic.rb", 0xbfe4d310) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/generic.rb", 0xbfe4d310) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/generic.rb", {st_mode=S_IFREG|0644, st_size=24145, ...}) = 0
open("/usr/lib/ruby/1.8/uri/generic.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=24145, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/uri/generic.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=24145, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/uri/generic.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/uri/generic.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=24145, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "#\n# = uri/generic.rb\n#\n# Author:: Akira Yamada <akira@ruby-lang.org>\n# License:: You can redistribute it and/or modify it under the same term as Ruby.\n# Revision:: $Id: generic.rb 16085 2008-04-19 11:56:22Z knu $\n#\n\nrequire 'uri/common'\n\nmodule URI\n  \n  #\n  # Base class for all URI classes.\n  # Implements generic URI syntax as per RFC 2396.\n  #\n  class Generic\n    include URI\n    include REGEXP\n\n    DEFAULT_PORT = nil\n\n    #\n    # Returns default port\n    #\n    def self.default_port\n      self::DEFAULT_PORT\n    end\n\n    def default_port\n      self.class.default_port\n    end\n\n    COMPONENT = [\n      :scheme, \n      :userinfo, :host, :port, :registry, \n      :path, :opaque, \n      :query, \n      :fragment\n    ].freeze\n\n    #\n    # Components of the URI in the order.\n    #\n    def self.component\n      self::COMPONENT\n    end\n\n    USE_REGISTRY = false\n\n    #\n    # DOC: FIXME!\n    #\n    def self.use_registry\n      self::USE_REGISTRY\n    end\n\n    #\n    # == Synopsis\n    #\n    # See #new\n    #\n    # == Description\n    #\n    # At first, tries to create a new URI::Generic instance using\n    # URI::Generic::build. But, if exception URI::InvalidComponentError is raised, \n    # then it URI::Escape.escape all URI components and tries again.\n    #\n    #\n    def self.build2(args)\n      begin\n        return self.build(args)\n      rescue InvalidComponentError\n        if args.kind_of?(Array)\n          return self.build(args.collect{|x| \n            if x\n              URI.escape(x)\n            else\n              x\n            end\n          })\n        elsif args.kind_of?(Hash)\n          tmp = {}\n          args.each do |key, value|\n            tmp[key] = if value\n                URI.escape(value)\n              else\n                value\n              end\n          end\n          return self.build(tmp)\n        end\n      end\n    end\n\n    #\n    # == Synopsis\n    #\n    # See #new\n    #\n    # == Description\n    #\n    # Creates a new URI::Generic instance from components of URI::Generic\n    # with check.  Components are: scheme, userinfo, host, port, registry, path,\n    # opaque, query and fragment. You can provide arguments either by an Array or a Hash.\n    # See #new for hash keys to use or for order of array items.\n    #\n    def self.build(args)\n      if args.kind_of?(Array) &&\n          args.size == ::URI::Generic::COMPONENT.size\n        tmp = args\n      elsif args.kind_of?(Hash)\n        tmp = ::URI::Generic::COMPONENT.collect do |c|\n          if args.include?(c)\n            args[c]\n          else\n            nil\n          end\n        end\n      else\n        raise ArgumentError, \n        \"expected Array of or Hash of components of #{self.class} (#{self.class.component.join(', ')})\"\n      end\n\n      tmp << true\n      return self.new(*tmp)\n    end\n    #\n    # == Args\n    #\n    # +scheme+::\n    #   Protocol scheme, i.e. 'http','ftp','mailto' and so on.\n    # +userinfo+::\n    #   User name and password, i.e. 'sdmitry:bla'\n    # +host+::\n    #   Server host name\n    # +port+::\n    #   Server port\n    # +registry+::\n    #   DOC: FIXME!\n    # +path+::\n    #   Path on server\n    # +opaque+::\n    #   DOC: FIXME!\n    # +query+::\n    #   Query data\n    # +fragment+::\n    #   A part of URI after '#' sign\n    # +arg_check+::\n    #   Check arguments [false by default]\n    #\n    # == Description\n    #\n    # Creates a new URI::Generic instance from ``generic'' components without check.\n    #\n    def initialize(scheme, \n                   userinfo, host, port, registry, \n                   path, opaque, \n                   query, \n                   fragment,\n                   arg_check = false)\n      @scheme = nil\n      @user = nil\n      @password = nil\n      @host = nil\n      @port = nil\n      @path = nil\n      @query = nil\n      @opaque = nil\n      @registry = nil\n      @fragment = nil\n\n      if arg_check\n        self.scheme = scheme\n        self.userinfo = userinfo\n        self.host = host\n        self.port = port\n        self.path = path\n        self.query = que"..., 4096) = 4096
brk(0xa037000)                          = 0xa037000
read(3, "t\n      else\n        self.set_scheme(scheme)\n        self.set_userinfo(userinfo)\n        self.set_host(host)\n        self.set_port(port)\n        self.set_path(path)\n        self.set_query(query)\n        self.set_opaque(opaque)\n        self.set_registry(registry)\n        self.set_fragment(fragment)\n      end\n      if @registry && !self.class.use_registry\n        raise InvalidURIError, \n          \"the scheme #{@scheme} does not accept registry part: #{@registry} (or bad hostname?)\"\n      end\n      \n      @scheme.freeze if @scheme\n      self.set_path('') if !@path && !@opaque # (see RFC2396 Section 5.2)\n      self.set_port(self.default_port) if self.default_port && !@port\n    end\n    attr_reader :scheme\n    attr_reader :host\n    attr_reader :port\n    attr_reader :registry\n    attr_reader :path\n    attr_reader :query\n    attr_reader :opaque\n    attr_reader :fragment\n\n    # replace self by other URI object\n    def replace!(oth)\n      if self.class != oth.class\n        raise ArgumentError, \"expected #{self.class} object\"\n      end\n\n      component.each do |c|\n        self.__send__(\"#{c}=\", oth.__send__(c))\n      end\n    end\n    private :replace!\n\n    def component\n      self.class.component\n    end\n\n    def check_scheme(v)\n      if v && SCHEME !~ v\n        raise InvalidComponentError,\n          \"bad component(expected scheme component): #{v}\"\n      end\n\n      return true\n    end\n    private :check_scheme\n\n    def set_scheme(v)\n      @scheme = v\n    end\n    protected :set_scheme\n\n    def scheme=(v)\n      check_scheme(v)\n      set_scheme(v)\n      v\n    end\n\n    def check_userinfo(user, password = nil)\n      if !password\n        user, password = split_userinfo(user)\n      end\n      check_user(user)\n      check_password(password, user)\n\n      return true\n    end\n    private :check_userinfo\n\n    def check_user(v)\n      if @registry || @opaque\n        raise InvalidURIError, \n          \"can not set user with registry or opaque\"\n      end\n\n      return v unless v\n\n      if USERINFO !~ v\n        raise InvalidComponentError,\n          \"bad component(expected userinfo component or user component): #{v}\"\n      end\n\n      return true\n    end\n    private :check_user\n\n    def check_password(v, user = @user)\n      if @registry || @opaque\n        raise InvalidURIError, \n          \"can not set password with registry or opaque\"\n      end\n      return v unless v\n\n      if !user\n        raise InvalidURIError,\n          \"password component depends user component\"\n      end\n\n      if USERINFO !~ v\n        raise InvalidComponentError,\n          \"bad component(expected user component): #{v}\"\n      end\n\n      return true\n    end\n    private :check_password\n\n    #\n    # Sets userinfo, argument is string like 'name:pass'\n    #\n    def userinfo=(userinfo)\n      if userinfo.nil?\n        return nil\n      end\n      check_userinfo(*userinfo)\n      set_userinfo(*userinfo)\n      # returns userinfo\n    end\n\n    def user=(user)\n      check_user(user)\n      set_user(user)\n      # returns user\n    end\n    \n    def password=(password)\n      check_password(password)\n      set_password(password)\n      # returns password\n    end\n\n    def set_userinfo(user, password = nil)\n      unless password \n        user, password = split_userinfo(user)\n      end\n      @user     = user\n      @password = password if password\n\n      [@user, @password]\n    end\n    protected :set_userinfo\n\n    def set_user(v)\n      set_userinfo(v, @password)\n      v\n    end\n    protected :set_user\n\n    def set_password(v)\n      @password = v\n      # returns v\n    end\n    protected :set_password\n\n    def split_userinfo(ui)\n      return nil, nil unless ui\n      user, password = ui.split(/:/, 2)\n\n      return user, password\n    end\n    private :split_userinfo\n\n    def escape_userpass(v)\n      v = URI.escape(v, /[@:\\/]/o) # RFC 1738 section 3.1 #/\n    end\n    private :escape_userpass\n\n    def userinfo\n      if @user.nil?\n        nil\n      elsif @password.nil?\n        @user\n      else\n        @user + ':' + @passwo"..., 4096) = 4096
read(3, "\n\n    def check_host(v)\n      return v unless v\n\n      if @registry || @opaque\n        raise InvalidURIError, \n          \"can not set host with registry or opaque\"\n      elsif HOST !~ v\n        raise InvalidComponentError,\n          \"bad component(expected host component): #{v}\"\n      end\n\n      return true\n    end\n    private :check_host\n\n    def set_host(v)\n      @host = v\n    end\n    protected :set_host\n\n    def host=(v)\n      check_host(v)\n      set_host(v)\n      v\n    end\n\n    def check_port(v)\n      return v unless v\n\n      if @registry || @opaque\n        raise InvalidURIError, \n          \"can not set port with registry or opaque\"\n      elsif !v.kind_of?(Fixnum) && PORT !~ v\n        raise InvalidComponentError,\n          \"bad component(expected port component): #{v}\"\n      end\n\n      return true\n    end\n    private :check_port\n\n    def set_port(v)\n      unless !v || v.kind_of?(Fixnum)\n        if v.empty?\n          v = nil\n        else\n          v = v.to_i\n        end\n      end\n      @port = v\n    end\n    protected :set_port\n\n    def port=(v)\n      check_port(v)\n      set_port(v)\n      port\n    end\n\n    def check_registry(v)\n      return v unless v\n\n      # raise if both server and registry are not nil, because:\n      # authority     = server | reg_name\n      # server        = [ [ userinfo \"@\" ] hostport ]\n      if @host || @port || @user # userinfo = @user + ':' + @password\n        raise InvalidURIError, \n          \"can not set registry with host, port, or userinfo\"\n      elsif v && REGISTRY !~ v\n        raise InvalidComponentError,\n          \"bad component(expected registry component): #{v}\"\n      end\n\n      return true\n    end\n    private :check_registry\n\n    def set_registry(v)\n      @registry = v\n    end\n    protected :set_registry\n\n    def registry=(v)\n      check_registry(v)\n      set_registry(v)\n      v\n    end\n\n    def check_path(v)\n      # raise if both hier and opaque are not nil, because:\n      # absoluteURI   = scheme \":\" ( hier_part | opaque_part )\n      # hier_part     = ( net_path | abs_path ) [ \"?\" query ]\n      if v && @opaque\n        raise InvalidURIError, \n          \"path conflicts with opaque\"\n      end\n\n      if @scheme\n        if v && v != '' && ABS_PATH !~ v\n          raise InvalidComponentError, \n            \"bad component(expected absolute path component): #{v}\"\n        end\n      else\n        if v && v != '' && ABS_PATH !~ v && REL_PATH !~ v\n          raise InvalidComponentError, \n            \"bad component(expected relative path component): #{v}\"\n        end\n      end\n\n      return true\n    end\n    private :check_path\n\n    def set_path(v)\n      @path = v\n    end\n    protected :set_path\n\n    def path=(v)\n      check_path(v)\n      set_path(v)\n      v\n    end\n\n    def check_query(v)\n      return v unless v\n\n      # raise if both hier and opaque are not nil, because:\n      # absoluteURI   = scheme \":\" ( hier_part | opaque_part )\n      # hier_part     = ( net_path | abs_path ) [ \"?\" query ]\n      if @opaque\n        raise InvalidURIError, \n          \"query conflicts with opaque\"\n      end\n\n      if v && v != '' && QUERY !~ v\n          raise InvalidComponentError, \n            \"bad component(expected query component): #{v}\"\n        end\n\n      return true\n    end\n    private :check_query\n\n    def set_query(v)\n      @query = v\n    end\n    protected :set_query\n\n    def query=(v)\n      check_query(v)\n      set_query(v)\n      v\n    end\n\n    def check_opaque(v)\n      return v unless v\n\n      # raise if both hier and opaque are not nil, because:\n      # absoluteURI   = scheme \":\" ( hier_part | opaque_part )\n      # hier_part     = ( net_path | abs_path ) [ \"?\" query ]\n      if @host || @port || @user || @path  # userinfo = @user + ':' + @password\n        raise InvalidURIError, \n          \"can not set opaque with host, port, userinfo or path\"\n      elsif v && OPAQUE !~ v\n        raise InvalidComponentError,\n          \"bad component(expected opaque component): #{v}\"\n      end\n\n      return true\n    end\n    priv"..., 4096) = 4096
read(3, "  def opaque=(v)\n      check_opaque(v)\n      set_opaque(v)\n      v\n    end\n\n    def check_fragment(v)\n      return v unless v\n\n      if v && v != '' && FRAGMENT !~ v\n        raise InvalidComponentError, \n          \"bad component(expected fragment component): #{v}\"\n      end\n\n      return true\n    end\n    private :check_fragment\n\n    def set_fragment(v)\n      @fragment = v\n    end\n    protected :set_fragment\n\n    def fragment=(v)\n      check_fragment(v)\n      set_fragment(v)\n      v\n    end\n\n    #\n    # Checks if URI has a path\n    #\n    def hierarchical?\n      if @path\n        true\n      else\n        false\n      end\n    end\n\n    #\n    # Checks if URI is an absolute one\n    #\n    def absolute?\n      if @scheme\n        true\n      else\n        false\n      end\n    end\n    alias absolute absolute?\n\n    #\n    # Checks if URI is relative\n    #\n    def relative?\n      !absolute?\n    end\n\n    def split_path(path)\n      path.split(%r{/+}, -1)\n    end\n    private :split_path\n\n    def merge_path(base, rel)\n\n      # RFC2396, Section 5.2, 5)\n      # RFC2396, Section 5.2, 6)\n      base_path = split_path(base)\n      rel_path  = split_path(rel)\n\n      # RFC2396, Section 5.2, 6), a)\n      base_path << '' if base_path.last == '..'\n      while i = base_path.index('..')\n        base_path.slice!(i - 1, 2)\n      end\n\n      if (first = rel_path.first) and first.empty?\n        base_path.clear\n        rel_path.shift\n      end\n\n      # RFC2396, Section 5.2, 6), c)\n      # RFC2396, Section 5.2, 6), d)\n      rel_path.push('') if rel_path.last == '.' || rel_path.last == '..'\n      rel_path.delete('.')\n\n      # RFC2396, Section 5.2, 6), e)\n      tmp = []\n      rel_path.each do |x|\n        if x == '..' &&\n            !(tmp.empty? || tmp.last == '..')\n          tmp.pop\n        else\n          tmp << x\n        end\n      end\n\n      add_trailer_slash = !tmp.empty?\n      if base_path.empty?\n        base_path = [''] # keep '/' for root directory\n      elsif add_trailer_slash\n        base_path.pop\n      end\n      while x = tmp.shift\n        if x == '..'\n          # RFC2396, Section 4\n          # a .. or . in an absolute path has no special meaning\n          base_path.pop if base_path.size > 1\n        else\n          # if x == '..'\n          #   valid absolute (but abnormal) path \"/../...\"\n          # else\n          #   valid absolute path\n          # end\n          base_path << x\n          tmp.each {|t| base_path << t}\n          add_trailer_slash = false\n          break\n        end\n      end\n      base_path.push('') if add_trailer_slash\n\n      return base_path.join('/')\n    end\n    private :merge_path\n\n    #\n    # == Args\n    #\n    # +oth+::\n    #    URI or String\n    #\n    # == Description\n    #\n    # Destructive form of #merge\n    #\n    # == Usage\n    #\n    #   require 'uri'\n    #\n    #   uri = URI.parse(\"http://my.example.com\")\n    #   uri.merge!(\"/main.rbx?page=1\")\n    #   p uri\n    #   # =>  #<URI::HTTP:0x2021f3b0 URL:http://my.example.com/main.rbx?page=1>\n    #\n    def merge!(oth)\n      t = merge(oth)\n      if self == t\n        nil\n      else\n        replace!(t)\n        self\n      end\n    end\n\n    #\n    # == Args\n    #\n    # +oth+::\n    #    URI or String\n    #\n    # == Description\n    #\n    # Merges two URI's.\n    #\n    # == Usage\n    #\n    #   require 'uri'\n    #\n    #   uri = URI.parse(\"http://my.example.com\")\n    #   p uri.merge(\"/main.rbx?page=1\")\n    #   # =>  #<URI::HTTP:0x2021f3b0 URL:http://my.example.com/main.rbx?page=1>\n    #\n    def merge(oth)\n      begin\n        base, rel = merge0(oth)\n      rescue\n        raise $!.class, $!.message\n      end\n\n      if base == rel\n        return base\n      end\n\n      authority = rel.userinfo || rel.host || rel.port\n\n      # RFC2396, Section 5.2, 2)\n      if (rel.path.nil? || rel.path.empty?) && !authority && !rel.query\n        base.set_fragment(rel.fragment) if rel.fragment\n        return base\n      end\n\n      base.set_query(nil)\n      base.set_fragment(nil)\n\n      # RFC2396, Section 5.2, 4)\n      if !authority\n    "..., 4096) = 4096
read(3, " RFC2396, Section 5.2, 4)\n        base.set_path(rel.path) if rel.path\n      end\n\n      # RFC2396, Section 5.2, 7)\n      base.set_userinfo(rel.userinfo) if rel.userinfo\n      base.set_host(rel.host)         if rel.host\n      base.set_port(rel.port)         if rel.port\n      base.set_query(rel.query)       if rel.query\n      base.set_fragment(rel.fragment) if rel.fragment\n\n      return base\n    end # merge\n    alias + merge\n\n    # return base and rel.\n    # you can modify `base', but can not `rel'.\n    def merge0(oth)\n      case oth\n      when Generic\n      when String\n        oth = URI.parse(oth)\n      else\n        raise ArgumentError,\n          \"bad argument(expected URI object or URI string)\"\n      end\n\n      if self.relative? && oth.relative?\n        raise BadURIError, \n          \"both URI are relative\"\n      end\n\n      if self.absolute? && oth.absolute?\n        #raise BadURIError, \n        #  \"both URI are absolute\"\n        # hmm... should return oth for usability?\n        return oth, oth\n      end\n\n      if self.absolute?\n        return self.dup, oth\n      else\n        return oth, oth\n      end\n    end\n    private :merge0\n\n    def route_from_path(src, dst)\n      # RFC2396, Section 4.2\n      return '' if src == dst\n\n      src_path = split_path(src)\n      dst_path = split_path(dst)\n\n      # hmm... dst has abnormal absolute path, \n      # like \"/./\", \"/../\", \"/x/../\", ...\n      if dst_path.include?('..') ||\n          dst_path.include?('.')\n        return dst.dup\n      end\n\n      src_path.pop\n\n      # discard same parts\n      while dst_path.first == src_path.first\n        break if dst_path.empty?\n\n        src_path.shift\n        dst_path.shift\n      end\n\n      tmp = dst_path.join('/')\n\n      # calculate\n      if src_path.empty?\n        if tmp.empty?\n          return './'\n        elsif dst_path.first.include?(':') # (see RFC2396 Section 5)\n          return './' + tmp\n        else\n          return tmp\n        end\n      end\n\n      return '../' * src_path.size + tmp\n    end\n    private :route_from_path\n\n    def route_from0(oth)\n      case oth\n      when Generic\n      when String\n        oth = URI.parse(oth)\n      else\n        raise ArgumentError,\n          \"bad argument(expected URI object or URI string)\"\n      end\n\n      if self.relative?\n        raise BadURIError, \n          \"relative URI: #{self}\"\n      end\n      if oth.relative?\n        raise BadURIError, \n          \"relative URI: #{oth}\"\n      end\n\n      if self.scheme != oth.scheme\n        return self, self.dup\n      end\n      rel = URI::Generic.new(nil, # it is relative URI\n                             self.userinfo, self.host, self.port, \n                             self.registry, self.path, self.opaque,\n                             self.query, self.fragment)\n\n      if rel.userinfo != oth.userinfo ||\n          rel.host.to_s.downcase != oth.host.to_s.downcase ||\n          rel.port != oth.port\n\tif self.userinfo.nil? && self.host.nil?\n\t  return self, self.dup\n\tend\n        rel.set_port(nil) if rel.port == oth.default_port\n        return rel, rel\n      end\n      rel.set_userinfo(nil)\n      rel.set_host(nil)\n      rel.set_port(nil)\n\n      if rel.path && rel.path == oth.path\n        rel.set_path('')\n        rel.set_query(nil) if rel.query == oth.query\n        return rel, rel\n      elsif rel.opaque && rel.opaque == oth.opaque\n        rel.set_opaque('')\n        rel.set_query(nil) if rel.query == oth.query\n        return rel, rel\n      end\n\n      # you can modify `rel', but can not `oth'.\n      return oth, rel\n    end\n    private :route_from0\n    #\n    # == Args\n    #\n    # +oth+::\n    #    URI or String\n    #\n    # == Description\n    #\n    # Calculates relative path from oth to self\n    #\n    # == Usage\n    #\n    #   require 'uri'\n    #\n    #   uri = URI.parse('http://my.example.com/main.rbx?page=1')\n    #   p uri.route_from('http://my.example.com')\n    #   #=> #<URI::Generic:0x20218858 URL:/main.rbx?page=1>\n    #\n    def route_from(oth)\n      # you can modify `rel', but can not `o"..., 4096) = 4096
read(3, "sage\n      end\n      if oth == rel\n        return rel\n      end\n\n      rel.set_path(route_from_path(oth.path, self.path))\n      if rel.path == './' && self.query\n        # \"./?foo\" -> \"?foo\"\n        rel.set_path('')\n      end\n\n      return rel\n    end\n\n    alias - route_from\n\n    #\n    # == Args\n    #\n    # +oth+::\n    #    URI or String\n    #\n    # == Description\n    #\n    # Calculates relative path to oth from self\n    #\n    # == Usage\n    #\n    #   require 'uri'\n    #\n    #   uri = URI.parse('http://my.example.com')\n    #   p uri.route_to('http://my.example.com/main.rbx?page=1')\n    #   #=> #<URI::Generic:0x2020c2f6 URL:/main.rbx?page=1>\n    #    \n    def route_to(oth)\n      case oth\n      when Generic\n      when String\n        oth = URI.parse(oth)\n      else\n        raise ArgumentError,\n          \"bad argument(expected URI object or URI string)\"\n      end\n\n      oth.route_from(self)\n    end\n\n    #\n    # Returns normalized URI\n    # \n    def normalize\n      uri = dup\n      uri.normalize!\n      uri\n    end\n\n    #\n    # Destructive version of #normalize\n    #\n    def normalize!\n      if path && path == ''\n        set_path('/')\n      end\n      if host && host != host.downcase\n        set_host(self.host.downcase)\n      end        \n    end\n\n    def path_query\n      str = @path\n      if @query\n        str += '?' + @query\n      end\n      str\n    end\n    private :path_query\n\n    #\n    # Constructs String from URI\n    # \n    def to_s\n      str = ''\n      if @scheme\n        str << @scheme\n        str << ':'\n      end\n\n      if @opaque\n        str << @opaque\n\n      else\n        if @registry\n          str << @registry\n        else\n          if @host\n            str << '//'\n          end\n          if self.userinfo\n            str << self.userinfo\n            str << '@'\n          end\n          if @host\n            str << @host\n          end\n          if @port && @port != self.default_port\n            str << ':'\n            str << @port.to_s\n          end\n        end\n\n        str << path_query\n      end\n\n      if @fragment\n        str << '#'\n        str << @fragment\n      end\n\n      str\n    end\n\n    #\n    # Compares to URI's\n    #\n    def ==(oth)\n      if self.class == oth.class\n        self.normalize.component_ary == oth.normalize.component_ary\n      else\n        false\n      end\n    end\n\n    def hash\n      self.component_ary.hash\n    end\n\n    def eql?(oth)\n      self.component_ary.eql?(oth.component_ary)\n    end\n\n=begin\n\n--- URI::Generic#===(oth)\n\n=end\n#    def ===(oth)\n#      raise NotImplementedError\n#    end\n\n=begin\n=end\n    def component_ary\n      component.collect do |x|\n        self.send(x)\n      end\n    end\n    protected :component_ary\n\n    # == Args\n    #\n    # +components+::\n    #    Multiple Symbol arguments defined in URI::HTTP\n    #\n    # == Description\n    #\n    # Selects specified components from URI\n    #\n    # == Usage\n    #\n    #   require 'uri'\n    #\n    #   uri = URI.parse('http://myuser:mypass@my.example.com/test.rbx')\n    #   p uri.select(:userinfo, :host, :path)\n    #   # => [\"myuser:mypass\", \"my.example.com\", \"/test.rbx\"]\n    #\n    def select(*components)\n      components.collect do |c|\n        if component.include?(c)\n          self.send(c)\n        else\n          raise ArgumentError, \n            \"expected of components of #{self.class} (#{self.class.component.join(', ')})\"\n        end\n      end\n    end\n\n    @@to_s = Kernel.instance_method(:to_s)\n    def inspect\n      @@to_s.bind(self).call.sub!(/>\\z/) {\" URL:#{self}>\"}\n    end\n\n    def coerce(oth)\n      case oth\n      when String\n        oth = URI.parse(oth)\n      else\n        super\n      end\n\n      return oth, self\n    end\n  end\nend\n", 4096) = 3665
brk(0xa058000)                          = 0xa058000
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/common.rb", 0xbfe4bcd0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/common.so", 0xbfe4bcd0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/common.rb", 0xbfe4bcd0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/common.so", 0xbfe4bcd0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/common.rb", 0xbfe4bcd0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/common.so", 0xbfe4bcd0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/common.rb", 0xbfe4bcd0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/common.so", 0xbfe4bcd0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/common.rb", 0xbfe4bcd0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/common.so", 0xbfe4bcd0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/common.rb", 0xbfe4bcd0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/common.so", 0xbfe4bcd0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/common.rb", 0xbfe4bcd0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/common.so", 0xbfe4bcd0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/common.rb", 0xbfe4bcd0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/common.so", 0xbfe4bcd0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/common.rb", {st_mode=S_IFREG|0644, st_size=17568, ...}) = 0
open("/usr/lib/ruby/1.8/uri/common.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=17568, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/ftp.rb", 0xbfe4d2e0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/ftp.so", 0xbfe4d2e0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/ftp.rb", 0xbfe4d2e0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/ftp.so", 0xbfe4d2e0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/ftp.rb", 0xbfe4d2e0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/ftp.so", 0xbfe4d2e0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/ftp.rb", 0xbfe4d2e0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/ftp.so", 0xbfe4d2e0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/ftp.rb", 0xbfe4d2e0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/ftp.so", 0xbfe4d2e0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/ftp.rb", 0xbfe4d2e0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/ftp.so", 0xbfe4d2e0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/ftp.rb", 0xbfe4d2e0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/ftp.so", 0xbfe4d2e0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/ftp.rb", 0xbfe4d2e0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/ftp.so", 0xbfe4d2e0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/ftp.rb", {st_mode=S_IFREG|0644, st_size=5252, ...}) = 0
open("/usr/lib/ruby/1.8/uri/ftp.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5252, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/ftp.rb", 0xbfe4d2f0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/ftp.rb", 0xbfe4d2f0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/ftp.rb", 0xbfe4d2f0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/ftp.rb", 0xbfe4d2f0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/ftp.rb", 0xbfe4d2f0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/ftp.rb", 0xbfe4d2f0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/ftp.rb", 0xbfe4d2f0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/ftp.rb", 0xbfe4d2f0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/ftp.rb", {st_mode=S_IFREG|0644, st_size=5252, ...}) = 0
open("/usr/lib/ruby/1.8/uri/ftp.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5252, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/uri/ftp.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5252, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/uri/ftp.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/uri/ftp.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5252, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "#\n# = uri/ftp.rb\n#\n# Author:: Akira Yamada <akira@ruby-lang.org>\n# License:: You can redistribute it and/or modify it under the same term as Ruby.\n# Revision:: $Id: ftp.rb 16085 2008-04-19 11:56:22Z knu $\n#\n\nrequire 'uri/generic'\n\nmodule URI\n\n  #\n  # FTP URI syntax is defined by RFC1738 section 3.2.\n  #\n  class FTP < Generic\n    DEFAULT_PORT = 21\n\n    COMPONENT = [\n      :scheme, \n      :userinfo, :host, :port,\n      :path, :typecode\n    ].freeze\n    #\n    # Typecode is \"a\", \"i\" or \"d\". \n    #\n    # * \"a\" indicates a text file (the FTP command was ASCII)\n    # * \"i\" indicates a binary file (FTP command IMAGE)\n    # * \"d\" indicates the contents of a directory should be displayed\n    #\n    TYPECODE = ['a', 'i', 'd'].freeze\n    TYPECODE_PREFIX = ';type='.freeze\n\n    def self.new2(user, password, host, port, path, \n                  typecode = nil, arg_check = true)\n      typecode = nil if typecode.size == 0\n      if typecode && !TYPECODE.include?(typecode)\n        raise ArgumentError,\n          \"bad typecode is specified: #{typecode}\"\n      end\n\n      # do escape\n\n      self.new('ftp',\n               [user, password], \n               host, port, nil, \n               typecode ? path + TYPECODE_PREFIX + typecode : path, \n               nil, nil, nil, arg_check)\n    end\n\n    #\n    # == Description\n    #\n    # Creates a new URI::FTP object from components, with syntax checking.  \n    #\n    # The components accepted are +userinfo+, +host+, +port+, +path+ and \n    # +typecode+.\n    #\n    # The components should be provided either as an Array, or as a Hash \n    # with keys formed by preceding the component names with a colon. \n    #\n    # If an Array is used, the components must be passed in the order\n    # [userinfo, host, port, path, typecode]\n    #\n    # If the path supplied is absolute, it will be escaped in order to\n    # make it absolute in the URI. Examples:\n    #\n    #     require 'uri'\n    #\n    #     uri = URI::FTP.build(['user:password', 'ftp.example.com', nil, \n    #       '/path/file.> zip', 'i'])\n    #     puts uri.to_s  ->  ftp://user:password@ftp.example.com/%2Fpath/file.zip;type=a\n    #\n    #     uri2 = URI::FTP.build({:host => 'ftp.example.com', \n    #       :path => 'ruby/src'})\n    #     puts uri2.to_s  ->  ftp://ftp.example.com/ruby/src\n    #\n    def self.build(args)\n\n      # Fix the incoming path to be generic URL syntax\n      # FTP path  ->  URL path\n      # foo/bar       /foo/bar\n      # /foo/bar      /%2Ffoo/bar\n      #\n      if args.kind_of?(Array)\n        args[3] = '/' + args[3].sub(/^\\//, '%2F')\n      else\n        args[:path] = '/' + args[:path].sub(/^\\//, '%2F')\n      end\n\n      tmp = Util::make_components_hash(self, args)\n\n      if tmp[:typecode]\n        if tmp[:typecode].size == 1\n          tmp[:typecode] = TYPECODE_PREFIX + tmp[:typecode] \n        end\n        tmp[:path] << tmp[:typecode]\n      end\n\n      return super(tmp)\n    end\n\n    #\n    # == Description\n    #\n    # Creates a new URI::FTP object from generic URL components with no\n    # syntax checking.\n    #\n    # Unlike build(), this method does not escape the path component as\n    # required by RFC1738; instead it is treated as per RFC2396.\n    #\n    # Arguments are +scheme+, +userinfo+, +host+, +port+, +registry+, +path+, \n    # +opaque+, +query+ and +fragment+, in that order.\n    #\n    def initialize(*arg)\n      super(*arg)\n      @typecode = nil\n      tmp = @path.index(TYPECODE_PREFIX)\n      if tmp\n        typecode = @path[tmp + TYPECODE_PREFIX.size..-1]\n        self.set_path(@path[0..tmp - 1])\n        \n        if arg[-1]\n          self.typecode = typecode\n        else\n          self.set_typecode(typecode)\n        end\n      end\n    end\n    attr_reader :typecode\n\n    def check_typecode(v)\n      if TYPECODE.include?(v)\n        return true\n      else\n        raise InvalidComponentError,\n          \"bad typecode(expected #{TYPECODE.join(', ')}): #{v}\"\n      end\n    end\n    private :check_typecode\n\n    def set_typecode(v)\n      @typecode = v\n    end\n   "..., 4096) = 4096
read(3, "ypecode(typecode)\n      typecode\n    end\n\n    def merge(oth) # :nodoc:\n      tmp = super(oth)\n      if self != tmp\n        tmp.set_typecode(oth.typecode)\n      end\n\n      return tmp\n    end\n\n    # Returns the path from an FTP URI.\n    #\n    # RFC 1738 specifically states that the path for an FTP URI does not\n    # include the / which separates the URI path from the URI host. Example:\n    #\n    #     ftp://ftp.example.com/pub/ruby \n    #\n    # The above URI indicates that the client should connect to \n    # ftp.example.com then cd pub/ruby from the initial login directory.\n    #\n    # If you want to cd to an absolute directory, you must include an\n    # escaped / (%2F) in the path. Example:\n    #\n    #     ftp://ftp.example.com/%2Fpub/ruby\n    #\n    # This method will then return \"/pub/ruby\"\n    #\n    def path\n      return @path.sub(/^\\//,'').sub(/^%2F/i,'/')\n    end\n\n    def to_s\n      save_path = nil\n      if @typecode\n        save_path = @path\n        @path = @path + TYPECODE_PREFIX + @typecode\n      end\n      str = super\n      if @typecode\n        @path = save_path\n      end\n\n      return str\n    end\n  end\n  @@schemes['FTP'] = FTP\nend\n", 4096) = 1156
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/generic.rb", 0xbfe4bcb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/generic.so", 0xbfe4bcb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/generic.rb", 0xbfe4bcb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/generic.so", 0xbfe4bcb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/generic.rb", 0xbfe4bcb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/generic.so", 0xbfe4bcb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/generic.rb", 0xbfe4bcb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/generic.so", 0xbfe4bcb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/generic.rb", 0xbfe4bcb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/generic.so", 0xbfe4bcb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/generic.rb", 0xbfe4bcb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/generic.so", 0xbfe4bcb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/generic.rb", 0xbfe4bcb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/generic.so", 0xbfe4bcb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/generic.rb", 0xbfe4bcb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/generic.so", 0xbfe4bcb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/generic.rb", {st_mode=S_IFREG|0644, st_size=24145, ...}) = 0
open("/usr/lib/ruby/1.8/uri/generic.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=24145, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/http.rb", 0xbfe4d2c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/http.so", 0xbfe4d2c0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/http.rb", 0xbfe4d2c0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/http.so", 0xbfe4d2c0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/http.rb", 0xbfe4d2c0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/http.so", 0xbfe4d2c0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/http.rb", 0xbfe4d2c0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/http.so", 0xbfe4d2c0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/http.rb", 0xbfe4d2c0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/http.so", 0xbfe4d2c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/http.rb", 0xbfe4d2c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/http.so", 0xbfe4d2c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/http.rb", 0xbfe4d2c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/http.so", 0xbfe4d2c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/http.rb", 0xbfe4d2c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/http.so", 0xbfe4d2c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/http.rb", {st_mode=S_IFREG|0644, st_size=2650, ...}) = 0
open("/usr/lib/ruby/1.8/uri/http.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2650, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/http.rb", 0xbfe4d2d0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/http.rb", 0xbfe4d2d0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/http.rb", 0xbfe4d2d0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/http.rb", 0xbfe4d2d0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/http.rb", 0xbfe4d2d0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/http.rb", 0xbfe4d2d0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/http.rb", 0xbfe4d2d0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/http.rb", 0xbfe4d2d0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/http.rb", {st_mode=S_IFREG|0644, st_size=2650, ...}) = 0
open("/usr/lib/ruby/1.8/uri/http.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2650, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/uri/http.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2650, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/uri/http.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/uri/http.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2650, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "#\n# = uri/http.rb\n#\n# Author:: Akira Yamada <akira@ruby-lang.org>\n# License:: You can redistribute it and/or modify it under the same term as Ruby.\n# Revision:: $Id: http.rb 11747 2007-02-15 02:41:45Z knu $\n#\n\nrequire 'uri/generic'\n\nmodule URI\n\n  #\n  # The syntax of HTTP URIs is defined in RFC1738 section 3.3.\n  #\n  # Note that the Ruby URI library allows HTTP URLs containing usernames and\n  # passwords. This is not legal as per the RFC, but used to be \n  # supported in Internet Explorer 5 and 6, before the MS04-004 security \n  # update. See <URL:http://support.microsoft.com/kb/834489>.\n  #\n  class HTTP < Generic\n    DEFAULT_PORT = 80\n\n    COMPONENT = [\n      :scheme, \n      :userinfo, :host, :port, \n      :path, \n      :query, \n      :fragment\n    ].freeze\n\n    #\n    # == Description\n    #\n    # Create a new URI::HTTP object from components, with syntax checking.\n    #\n    # The components accepted are userinfo, host, port, path, query and\n    # fragment.\n    #\n    # The components should be provided either as an Array, or as a Hash \n    # with keys formed by preceding the component names with a colon. \n    #\n    # If an Array is used, the components must be passed in the order\n    # [userinfo, host, port, path, query, fragment].\n    #\n    # Example:\n    #\n    #     newuri = URI::HTTP.build({:host => 'www.example.com', \n    #       :path> => '/foo/bar'})\n    #\n    #     newuri = URI::HTTP.build([nil, \"www.example.com\", nil, \"/path\", \n    #       \"query\", 'fragment'])\n    #\n    # Currently, if passed userinfo components this method generates \n    # invalid HTTP URIs as per RFC 1738.\n    #\n    def self.build(args)\n      tmp = Util::make_components_hash(self, args)\n      return super(tmp)\n    end\n\n    #\n    # == Description\n    #\n    # Create a new URI::HTTP object from generic URI components as per\n    # RFC 2396. No HTTP-specific syntax checking (as per RFC 1738) is \n    # performed.\n    #\n    # Arguments are +scheme+, +userinfo+, +host+, +port+, +registry+, +path+, \n    # +opaque+, +query+ and +fragment+, in that order.\n    #\n    # Example:\n    #\n    #     uri = URI::HTTP.new(['http', nil, \"www.example.com\", nil, \"/path\",\n    #       \"query\", 'fragment'])\n    #\n    def initialize(*arg)\n      super(*arg)\n    end\n\n    #\n    # == Description\n    #\n    # Returns the full path for an HTTP request, as required by Net::HTTP::Get.\n    #\n    # If the URI contains a query, the full path is URI#path + '?' + URI#query.\n    # Otherwise, the path is simply URI#path.\n    #\n    def request_uri\n      r = path_query\n      if r[0] != ?/\n        r = '/' + r\n      end\n\n      r\n    end\n  end\n\n  @@schemes['HTTP'] = HTTP\nend\n", 4096) = 2650
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/generic.rb", 0xbfe4bc90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/generic.so", 0xbfe4bc90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/generic.rb", 0xbfe4bc90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/generic.so", 0xbfe4bc90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/generic.rb", 0xbfe4bc90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/generic.so", 0xbfe4bc90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/generic.rb", 0xbfe4bc90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/generic.so", 0xbfe4bc90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/generic.rb", 0xbfe4bc90) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/generic.so", 0xbfe4bc90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/generic.rb", 0xbfe4bc90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/generic.so", 0xbfe4bc90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/generic.rb", 0xbfe4bc90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/generic.so", 0xbfe4bc90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/generic.rb", 0xbfe4bc90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/generic.so", 0xbfe4bc90) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/generic.rb", {st_mode=S_IFREG|0644, st_size=24145, ...}) = 0
open("/usr/lib/ruby/1.8/uri/generic.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=24145, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/https.rb", 0xbfe4d2a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/https.so", 0xbfe4d2a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/https.rb", 0xbfe4d2a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/https.so", 0xbfe4d2a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/https.rb", 0xbfe4d2a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/https.so", 0xbfe4d2a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/https.rb", 0xbfe4d2a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/https.so", 0xbfe4d2a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/https.rb", 0xbfe4d2a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/https.so", 0xbfe4d2a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/https.rb", 0xbfe4d2a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/https.so", 0xbfe4d2a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/https.rb", 0xbfe4d2a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/https.so", 0xbfe4d2a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/https.rb", 0xbfe4d2a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/https.so", 0xbfe4d2a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/https.rb", {st_mode=S_IFREG|0644, st_size=498, ...}) = 0
open("/usr/lib/ruby/1.8/uri/https.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=498, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/https.rb", 0xbfe4d2b0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/https.rb", 0xbfe4d2b0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/https.rb", 0xbfe4d2b0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/https.rb", 0xbfe4d2b0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/https.rb", 0xbfe4d2b0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/https.rb", 0xbfe4d2b0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/https.rb", 0xbfe4d2b0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/https.rb", 0xbfe4d2b0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/https.rb", {st_mode=S_IFREG|0644, st_size=498, ...}) = 0
open("/usr/lib/ruby/1.8/uri/https.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=498, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/uri/https.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=498, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/uri/https.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/uri/https.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=498, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "#\n# = uri/https.rb\n#\n# Author:: Akira Yamada <akira@ruby-lang.org>\n# License:: You can redistribute it and/or modify it under the same term as Ruby.\n# Revision:: $Id: https.rb 11747 2007-02-15 02:41:45Z knu $\n#\n\nrequire 'uri/http'\n\nmodule URI\n\n  # The default port for HTTPS URIs is 443, and the scheme is 'https:' rather\n  # than 'http:'. Other than that, HTTPS URIs are identical to HTTP URIs;\n  # see URI::HTTP.\n  class HTTPS < HTTP\n    DEFAULT_PORT = 443\n  end\n  @@schemes['HTTPS'] = HTTPS\nend\n", 4096) = 498
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/http.rb", 0xbfe4bc70) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/http.so", 0xbfe4bc70) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/http.rb", 0xbfe4bc70) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/http.so", 0xbfe4bc70) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/http.rb", 0xbfe4bc70) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/http.so", 0xbfe4bc70) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/http.rb", 0xbfe4bc70) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/http.so", 0xbfe4bc70) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/http.rb", 0xbfe4bc70) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/http.so", 0xbfe4bc70) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/http.rb", 0xbfe4bc70) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/http.so", 0xbfe4bc70) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/http.rb", 0xbfe4bc70) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/http.so", 0xbfe4bc70) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/http.rb", 0xbfe4bc70) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/http.so", 0xbfe4bc70) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/http.rb", {st_mode=S_IFREG|0644, st_size=2650, ...}) = 0
open("/usr/lib/ruby/1.8/uri/http.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2650, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/ldap.rb", 0xbfe4d280) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/ldap.so", 0xbfe4d280) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/ldap.rb", 0xbfe4d280) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/ldap.so", 0xbfe4d280) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/ldap.rb", 0xbfe4d280) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/ldap.so", 0xbfe4d280) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/ldap.rb", 0xbfe4d280) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/ldap.so", 0xbfe4d280) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/ldap.rb", 0xbfe4d280) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/ldap.so", 0xbfe4d280) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/ldap.rb", 0xbfe4d280) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/ldap.so", 0xbfe4d280) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/ldap.rb", 0xbfe4d280) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/ldap.so", 0xbfe4d280) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/ldap.rb", 0xbfe4d280) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/ldap.so", 0xbfe4d280) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/ldap.rb", {st_mode=S_IFREG|0644, st_size=3342, ...}) = 0
open("/usr/lib/ruby/1.8/uri/ldap.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3342, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/ldap.rb", 0xbfe4d290) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/ldap.rb", 0xbfe4d290) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/ldap.rb", 0xbfe4d290) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/ldap.rb", 0xbfe4d290) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/ldap.rb", 0xbfe4d290) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/ldap.rb", 0xbfe4d290) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/ldap.rb", 0xbfe4d290) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/ldap.rb", 0xbfe4d290) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/ldap.rb", {st_mode=S_IFREG|0644, st_size=3342, ...}) = 0
open("/usr/lib/ruby/1.8/uri/ldap.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3342, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/uri/ldap.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3342, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/uri/ldap.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/uri/ldap.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3342, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "#\n# = uri/ldap.rb\n#\n# Author:: \n#  Takaaki Tateishi <ttate@jaist.ac.jp>\n#  Akira Yamada <akira@ruby-lang.org>\n# License:: \n#   URI::LDAP is copyrighted free software by Takaaki Tateishi and Akira Yamada.\n#   You can redistribute it and/or modify it under the same term as Ruby.\n# Revision:: $Id: ldap.rb 11708 2007-02-12 23:01:19Z shyouhei $\n#\n\nrequire 'uri/generic'\n\nmodule URI\n\n  #\n  # LDAP URI SCHEMA (described in RFC2255)\n  # ldap://<host>/<dn>[?<attrs>[?<scope>[?<filter>[?<extensions>]]]]\n  #\n  class LDAP < Generic\n\n    DEFAULT_PORT = 389\n    \n    COMPONENT = [\n      :scheme,\n      :host, :port,\n      :dn,\n      :attributes,\n      :scope,\n      :filter,\n      :extensions,\n    ].freeze\n\n    SCOPE = [\n      SCOPE_ONE = 'one',\n      SCOPE_SUB = 'sub',\n      SCOPE_BASE = 'base',\n    ].freeze\n\n    def self.build(args)\n      tmp = Util::make_components_hash(self, args)\n\n      if tmp[:dn]\n        tmp[:path] = tmp[:dn]\n      end\n\n      query = []\n      [:extensions, :filter, :scope, :attributes].collect do |x|\n        next if !tmp[x] && query.size == 0\n        query.unshift(tmp[x])\n      end\n\n      tmp[:query] = query.join('?')\n\n      return super(tmp)\n    end\n\n    def initialize(*arg)\n      super(*arg)\n\n      if @fragment\n        raise InvalidURIError, 'bad LDAP URL'\n      end\n\n      parse_dn\n      parse_query\n    end\n\n    def parse_dn\n      @dn = @path[1..-1]\n    end\n    private :parse_dn\n\n    def parse_query\n      @attributes = nil\n      @scope      = nil\n      @filter     = nil\n      @extensions = nil\n\n      if @query\n        attrs, scope, filter, extensions = @query.split('?')\n\n        @attributes = attrs if attrs && attrs.size > 0\n        @scope      = scope if scope && scope.size > 0\n        @filter     = filter if filter && filter.size > 0\n        @extensions = extensions if extensions && extensions.size > 0\n      end\n    end\n    private :parse_query\n\n    def build_path_query\n      @path = '/' + @dn\n\n      query = []\n      [@extensions, @filter, @scope, @attributes].each do |x|\n        next if !x && query.size == 0\n        query.unshift(x)\n      end\n      @query = query.join('?')\n    end\n    private :build_path_query\n\n    def dn\n      @dn\n    end\n\n    def set_dn(val)\n      @dn = val\n      build_path_query\n      @dn\n    end\n    protected :set_dn\n\n    def dn=(val)\n      set_dn(val)\n      val\n    end\n\n    def attributes\n      @attributes\n    end\n\n    def set_attributes(val)\n      @attributes = val\n      build_path_query\n      @attributes\n    end\n    protected :set_attributes\n\n    def attributes=(val)\n      set_attributes(val)\n      val\n    end\n\n    def scope\n      @scope\n    end\n\n    def set_scope(val)\n      @scope = val\n      build_path_query\n      @scope\n    end\n    protected :set_scope\n\n    def scope=(val)\n      set_scope(val)\n      val\n    end\n\n    def filter\n      @filter\n    end\n\n    def set_filter(val)\n      @filter = val\n      build_path_query\n      @filter\n    end\n    protected :set_filter\n\n    def filter=(val)\n      set_filter(val)\n      val\n    end\n\n    def extensions\n      @extensions\n    end\n\n    def set_extensions(val)\n      @extensions = val\n      build_path_query\n      @extensions\n    end\n    protected :set_extensions\n\n    def extensions=(val)\n      set_extensions(val)\n      val\n    end\n\n    def hierarchical?\n      false\n    end\n  end\n\n  @@schemes['LDAP'] = LDAP\nend\n", 4096) = 3342
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/generic.rb", 0xbfe4bc50) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/generic.so", 0xbfe4bc50) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/generic.rb", 0xbfe4bc50) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/generic.so", 0xbfe4bc50) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/generic.rb", 0xbfe4bc50) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/generic.so", 0xbfe4bc50) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/generic.rb", 0xbfe4bc50) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/generic.so", 0xbfe4bc50) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/generic.rb", 0xbfe4bc50) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/generic.so", 0xbfe4bc50) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/generic.rb", 0xbfe4bc50) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/generic.so", 0xbfe4bc50) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/generic.rb", 0xbfe4bc50) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/generic.so", 0xbfe4bc50) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/generic.rb", 0xbfe4bc50) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/generic.so", 0xbfe4bc50) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/generic.rb", {st_mode=S_IFREG|0644, st_size=24145, ...}) = 0
open("/usr/lib/ruby/1.8/uri/generic.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=24145, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/ldaps.rb", 0xbfe4d260) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/ldaps.so", 0xbfe4d260) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/ldaps.rb", 0xbfe4d260) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/ldaps.so", 0xbfe4d260) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/ldaps.rb", 0xbfe4d260) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/ldaps.so", 0xbfe4d260) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/ldaps.rb", 0xbfe4d260) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/ldaps.so", 0xbfe4d260) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/ldaps.rb", 0xbfe4d260) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/ldaps.so", 0xbfe4d260) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/ldaps.rb", 0xbfe4d260) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/ldaps.so", 0xbfe4d260) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/ldaps.rb", 0xbfe4d260) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/ldaps.so", 0xbfe4d260) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/ldaps.rb", 0xbfe4d260) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/ldaps.so", 0xbfe4d260) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/ldaps.rb", {st_mode=S_IFREG|0644, st_size=286, ...}) = 0
open("/usr/lib/ruby/1.8/uri/ldaps.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=286, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/ldaps.rb", 0xbfe4d270) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/ldaps.rb", 0xbfe4d270) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/ldaps.rb", 0xbfe4d270) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/ldaps.rb", 0xbfe4d270) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/ldaps.rb", 0xbfe4d270) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/ldaps.rb", 0xbfe4d270) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/ldaps.rb", 0xbfe4d270) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/ldaps.rb", 0xbfe4d270) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/ldaps.rb", {st_mode=S_IFREG|0644, st_size=286, ...}) = 0
open("/usr/lib/ruby/1.8/uri/ldaps.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=286, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/uri/ldaps.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=286, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/uri/ldaps.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/uri/ldaps.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=286, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "require 'uri/ldap'\n\nmodule URI\n\n  # The default port for LDAPS URIs is 636, and the scheme is 'ldaps:' rather\n  # than 'ldap:'. Other than that, LDAPS URIs are identical to LDAP URIs;\n  # see URI::LDAP.\n  class LDAPS < LDAP\n    DEFAULT_PORT = 636\n  end\n  @@schemes['LDAPS'] = LDAPS\nend\n", 4096) = 286
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/ldap.rb", 0xbfe4bc30) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/ldap.so", 0xbfe4bc30) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/ldap.rb", 0xbfe4bc30) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/ldap.so", 0xbfe4bc30) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/ldap.rb", 0xbfe4bc30) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/ldap.so", 0xbfe4bc30) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/ldap.rb", 0xbfe4bc30) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/ldap.so", 0xbfe4bc30) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/ldap.rb", 0xbfe4bc30) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/ldap.so", 0xbfe4bc30) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/ldap.rb", 0xbfe4bc30) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/ldap.so", 0xbfe4bc30) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/ldap.rb", 0xbfe4bc30) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/ldap.so", 0xbfe4bc30) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/ldap.rb", 0xbfe4bc30) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/ldap.so", 0xbfe4bc30) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/ldap.rb", {st_mode=S_IFREG|0644, st_size=3342, ...}) = 0
open("/usr/lib/ruby/1.8/uri/ldap.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3342, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/mailto.rb", 0xbfe4d240) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/mailto.so", 0xbfe4d240) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/mailto.rb", 0xbfe4d240) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/mailto.so", 0xbfe4d240) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/mailto.rb", 0xbfe4d240) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/mailto.so", 0xbfe4d240) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/mailto.rb", 0xbfe4d240) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/mailto.so", 0xbfe4d240) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/mailto.rb", 0xbfe4d240) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/mailto.so", 0xbfe4d240) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/mailto.rb", 0xbfe4d240) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/mailto.so", 0xbfe4d240) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/mailto.rb", 0xbfe4d240) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/mailto.so", 0xbfe4d240) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/mailto.rb", 0xbfe4d240) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/mailto.so", 0xbfe4d240) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/mailto.rb", {st_mode=S_IFREG|0644, st_size=6684, ...}) = 0
open("/usr/lib/ruby/1.8/uri/mailto.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=6684, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/mailto.rb", 0xbfe4d250) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/mailto.rb", 0xbfe4d250) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/mailto.rb", 0xbfe4d250) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/mailto.rb", 0xbfe4d250) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/mailto.rb", 0xbfe4d250) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/mailto.rb", 0xbfe4d250) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/mailto.rb", 0xbfe4d250) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/mailto.rb", 0xbfe4d250) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/mailto.rb", {st_mode=S_IFREG|0644, st_size=6684, ...}) = 0
open("/usr/lib/ruby/1.8/uri/mailto.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=6684, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/1.8/uri/mailto.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=6684, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/1.8/uri/mailto.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/1.8/uri/mailto.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=6684, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "#\n# = uri/mailto.rb\n#\n# Author:: Akira Yamada <akira@ruby-lang.org>\n# License:: You can redistribute it and/or modify it under the same term as Ruby.\n# Revision:: $Id: mailto.rb 11747 2007-02-15 02:41:45Z knu $\n#\n\nrequire 'uri/generic'\n\nmodule URI\n\n  #\n  # RFC2368, The mailto URL scheme\n  #\n  class MailTo < Generic\n    include REGEXP\n\n    DEFAULT_PORT = nil\n\n    COMPONENT = [ :scheme, :to, :headers ].freeze\n\n    # :stopdoc:\n    #  \"hname\" and \"hvalue\" are encodings of an RFC 822 header name and\n    #  value, respectively. As with \"to\", all URL reserved characters must\n    #  be encoded.\n    #\n    #  \"#mailbox\" is as specified in RFC 822 [RFC822]. This means that it\n    #  consists of zero or more comma-separated mail addresses, possibly\n    #  including \"phrase\" and \"comment\" components. Note that all URL\n    #  reserved characters in \"to\" must be encoded: in particular,\n    #  parentheses, commas, and the percent sign (\"%\"), which commonly occur\n    #  in the \"mailbox\" syntax.\n    #\n    #  Within mailto URLs, the characters \"?\", \"=\", \"&\" are reserved.\n\n    # hname      =  *urlc\n    # hvalue     =  *urlc\n    # header     =  hname \"=\" hvalue\n    HEADER_PATTERN = \"(?:[^?=&]*=[^?=&]*)\".freeze\n    HEADER_REGEXP  = Regexp.new(HEADER_PATTERN, 'N').freeze\n    # headers    =  \"?\" header *( \"&\" header )\n    # to         =  #mailbox\n    # mailtoURL  =  \"mailto:\" [ to ] [ headers ]\n    MAILBOX_PATTERN = \"(?:#{PATTERN::ESCAPED}|[^(),%?=&])\".freeze\n    MAILTO_REGEXP = Regexp.new(\" # :nodoc:\n      \\\\A\n      (#{MAILBOX_PATTERN}*?)                          (?# 1: to)\n      (?:\n        \\\\?\n        (#{HEADER_PATTERN}(?:\\\\&#{HEADER_PATTERN})*)  (?# 2: headers)\n      )?\n      (?:\n        \\\\#\n        (#{PATTERN::FRAGMENT})                        (?# 3: fragment)\n      )?\n      \\\\z\n    \", Regexp::EXTENDED, 'N').freeze\n    # :startdoc:\n\n    #\n    # == Description\n    #\n    # Creates a new URI::MailTo object from components, with syntax checking.\n    #\n    # Components can be provided as an Array or Hash. If an Array is used,\n    # the components must be supplied as [to, headers].\n    #\n    # If a Hash is used, the keys are the component names preceded by colons.\n    #\n    # The headers can be supplied as a pre-encoded string, such as \n    # \"subject=subscribe&cc=address\", or as an Array of Arrays like\n    # [['subject', 'subscribe'], ['cc', 'address']]\n    #\n    # Examples:\n    # \n    #    require 'uri'\n    #    \n    #    m1 = URI::MailTo.build(['joe@example.com', 'subject=Ruby'])\n    #    puts m1.to_s  ->  mailto:joe@example.com?subject=Ruby\n    #    \n    #    m2 = URI::MailTo.build(['john@example.com', [['Subject', 'Ruby'], ['Cc', 'jack@example.com']]])\n    #    puts m2.to_s  ->  mailto:john@example.com?Subject=Ruby&Cc=jack@example.com\n    #    \n    #    m3 = URI::MailTo.build({:to => 'listman@example.com', :headers => [['subject', 'subscribe']]})\n    #    puts m3.to_s  ->  mailto:listman@example.com?subject=subscribe\n    #\n    def self.build(args)\n      tmp = Util::make_components_hash(self, args)\n\n      if tmp[:to]\n        tmp[:opaque] = tmp[:to]\n      else\n        tmp[:opaque] = ''\n      end\n\n      if tmp[:headers]\n        tmp[:opaque] << '?'\n\n        if tmp[:headers].kind_of?(Array)\n          tmp[:opaque] << tmp[:headers].collect { |x|\n            if x.kind_of?(Array)\n              x[0] + '=' + x[1..-1].to_s\n            else\n              x.to_s\n            end\n          }.join('&')\n\n        elsif tmp[:headers].kind_of?(Hash)\n          tmp[:opaque] << tmp[:headers].collect { |h,v|\n            h + '=' + v\n          }.join('&')\n\n        else\n          tmp[:opaque] << tmp[:headers].to_s\n        end\n      end\n\n      return super(tmp)\n    end\n\n    #\n    # == Description\n    #\n    # Creates a new URI::MailTo object from generic URL components with\n    # no syntax checking.\n    #\n    # This method is usually called from URI::parse, which checks\n    # the validity of each component.\n    #\n    def initialize(*arg)\n      super(*arg)\n\n      @to = nil\n   "..., 4096) = 4096
brk(0xa079000)                          = 0xa079000
read(3, "         self.headers = $2\n        else\n          set_to($1)\n          set_headers($2)\n        end\n\n      else\n        raise InvalidComponentError,\n          \"unrecognised opaque part for mailtoURL: #{@opaque}\"\n      end\n    end\n\n    # The primary e-mail address of the URL, as a String\n    attr_reader :to\n\n    # E-mail headers set by the URL, as an Array of Arrays\n    attr_reader :headers\n\n    def check_to(v)\n      return true unless v\n      return true if v.size == 0\n\n      if OPAQUE !~ v || /\\A#{MAILBOX_PATTERN}*\\z/o !~ v\n        raise InvalidComponentError,\n          \"bad component(expected opaque component): #{v}\"\n      end\n\n      return true\n    end\n    private :check_to\n\n    def set_to(v)\n      @to = v\n    end\n    protected :set_to\n\n    def to=(v)\n      check_to(v)\n      set_to(v)\n      v\n    end\n\n    def check_headers(v)\n      return true unless v\n      return true if v.size == 0\n\n      if OPAQUE !~ v || \n          /\\A(#{HEADER_PATTERN}(?:\\&#{HEADER_PATTERN})*)\\z/o !~ v\n        raise InvalidComponentError,\n          \"bad component(expected opaque component): #{v}\"\n      end\n\n      return true\n    end\n    private :check_headers\n\n    def set_headers(v)\n      @headers = []\n      if v\n        v.scan(HEADER_REGEXP) do |x|\n          @headers << x.split(/=/o, 2)\n        end\n      end\n    end\n    protected :set_headers\n\n    def headers=(v)\n      check_headers(v)\n      set_headers(v)\n      v\n    end\n\n    def to_s\n      @scheme + ':' + \n        if @to \n          @to\n        else\n          ''\n        end + \n        if @headers.size > 0\n          '?' + @headers.collect{|x| x.join('=')}.join('&')\n        else\n          ''\n        end +\n        if @fragment\n          '#' + @fragment\n        else\n          ''\n        end\n    end\n    \n    # Returns the RFC822 e-mail text equivalent of the URL, as a String.\n    #\n    # Example:\n    #\n    #   require 'uri'\n    #\n    #   uri = URI.parse(\"mailto:ruby-list@ruby-lang.org?Subject=subscribe&cc=myaddr\")\n    #   uri.to_mailtext\n    #   # => \"To: ruby-list@ruby-lang.org\\nSubject: subscribe\\nCc: myaddr\\n\\n\\n\"\n    #\n    def to_mailtext\n      to = URI::unescape(@to)\n      head = ''\n      body = ''\n      @headers.each do |x|\n        case x[0]\n        when 'body'\n          body = URI::unescape(x[1])\n        when 'to'\n          to << ', ' + URI::unescape(x[1])\n        else\n          head << URI::unescape(x[0]).capitalize + ': ' +\n            URI::unescape(x[1])  + \"\\n\"\n        end\n      end\n\n      return \"To: #{to}\n#{head}\n#{body}\n\"\n    end\n    alias to_rfc822text to_mailtext\n  end\n\n  @@schemes['MAILTO'] = MailTo\nend\n", 4096) = 2588
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/generic.rb", 0xbfe4bc10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/uri/generic.so", 0xbfe4bc10) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/generic.rb", 0xbfe4bc10) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/uri/generic.so", 0xbfe4bc10) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/generic.rb", 0xbfe4bc10) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/uri/generic.so", 0xbfe4bc10) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/generic.rb", 0xbfe4bc10) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/uri/generic.so", 0xbfe4bc10) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/generic.rb", 0xbfe4bc10) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/uri/generic.so", 0xbfe4bc10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/generic.rb", 0xbfe4bc10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/uri/generic.so", 0xbfe4bc10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/generic.rb", 0xbfe4bc10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/uri/generic.so", 0xbfe4bc10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/generic.rb", 0xbfe4bc10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/uri/generic.so", 0xbfe4bc10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/uri/generic.rb", {st_mode=S_IFREG|0644, st_size=24145, ...}) = 0
open("/usr/lib/ruby/1.8/uri/generic.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=24145, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems.rb", 0xbfe4e930) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems.so", 0xbfe4e930) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems.rb", {st_mode=S_IFREG|0644, st_size=29096, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=29096, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/migrate.rb", {st_mode=S_IFREG|0644, st_size=426, ...}) = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/migrate.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=426, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/migrate.rb", {st_mode=S_IFREG|0644, st_size=426, ...}) = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/migrate.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=426, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/migrate.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=426, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/migrate.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/migrate.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=426, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "class Gem::Commands::MigrateCommand < Gem::AbstractCommand\n  def description\n    'Deprecate method for migrating a gem you own from Rubyforge to Gemcutter.'\n  end\n\n  def initialize\n    super 'migrate', description\n  end\n\n  def execute\n    say \"This command is deprecated, RubyForge accounts/ownerships have been transferred to Gemcutter.\"\n    say \"Please see http://gemcutter.org/pages/migrate for more information\"\n  end\nend\n", 4096) = 426
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/owner.rb", {st_mode=S_IFREG|0644, st_size=2511, ...}) = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/owner.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2511, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/owner.rb", {st_mode=S_IFREG|0644, st_size=2511, ...}) = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/owner.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2511, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/owner.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2511, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/owner.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/owner.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2511, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "class Gem::Commands::OwnerCommand < Gem::AbstractCommand\n\n  def description\n    'Manage gem owners on Gemcutter.'\n  end\n\n  def arguments\n    \"GEM_NAME       name of gem to manage owners for.\"\n  end\n\n  def usage\n    \"#{program_name} GEM_NAME\"\n  end\n\n  def initialize\n    super 'owner', description\n    defaults.merge!(:add => [], :remove => [])\n\n    add_option('-a', '--add EMAIL', 'Add an owner') do |value, options|\n      options[:add] << value\n    end\n\n    add_option('-r', '--remove EMAIL', 'Remove an owner') do |value, options|\n      options[:remove] << value\n    end\n  end\n\n  def execute\n    setup\n    name = get_one_gem_name\n\n    add_owners    name, options[:add]\n    remove_owners name, options[:remove]\n    show_owners   name\n  end\n\n  def add_owners(name, owners)\n    owners.each do |owner|\n      response = make_request(:post, \"gems/#{name}/owners.json\") do |request|\n        request.set_form_data(\"email\" => owner)\n        request.add_field(\"Authorization\", api_key)\n      end\n      \n      case response\n      when Net::HTTPSuccess\n        say \"Added owner: #{owner}\"\n      else\n        say \"Error adding owner: #{owner}\"\n      end\n    end\n  end\n\n  def remove_owners(name, owners)\n    owners.each do |owner|\n      response = make_request(:delete, \"gems/#{name}/owners.json\") do |request|\n        request.set_form_data(:email => owner)\n        request.add_field(\"Authorization\", api_key)\n      end\n      \n      case response\n      when Net::HTTPSuccess\n        say \"Removed owner: #{owner}\"\n      else\n        say \"Error removing owner: #{owner}\"\n      end\n    end  end\n\n  def show_owners(name)\n    require 'json/pure' unless defined?(JSON::JSON_LOADED)\n\n    response = make_request(:get, \"gems/#{name}/owners.json\") do |request|\n      request.add_field(\"Authorization\", api_key)\n    end\n\n    case response\n    when Net::HTTPSuccess\n      begin\n        owners = JSON.parse(response.body)\n\n        say \"Owners for gem: #{name}\"\n        owners.each do |owner|\n          say \"- #{owner['email']}\"\n        end\n      rescue JSON::ParserError => json_error\n        say \"There was a problem parsing the data: #{json_error}\"\n        terminate_interaction\n      end\n    when Net::HTTPNotFound\n      say \"This gem is currently not hosted on Gemcutter.\"\n      terminate_interaction\n    when Net::HTTPUnauthorized\n      say \"You do not have permission to manage this gem.\"\n      terminate_interaction\n    else\n      say \"There was a problem processing your request.\"\n      terminate_interaction\n    end\n  end\nend\n", 4096) = 2511
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/push.rb", {st_mode=S_IFREG|0644, st_size=740, ...}) = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/push.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=740, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/push.rb", {st_mode=S_IFREG|0644, st_size=740, ...}) = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/push.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=740, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/push.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=740, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/push.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/push.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=740, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "class Gem::Commands::PushCommand < Gem::AbstractCommand\n\n  def description\n    'Push a gem up to Gemcutter'\n  end\n\n  def arguments\n    \"GEM       built gem to push up\"\n  end\n\n  def usage\n    \"#{program_name} GEM\"\n  end\n\n  def initialize\n    super 'push', description\n    add_proxy_option\n  end\n\n  def execute\n    setup\n    send_gem\n  end\n\n  def send_gem\n    say \"Pushing gem to Gemcutter...\"\n\n    path = get_one_gem_name\n    response = make_request(:post, \"gems\") do |request|\n      request.body = Gem.read_binary(path)\n      request.add_field(\"Content-Length\", request.body.size)\n      request.add_field(\"Content-Type\", \"application/octet-stream\")\n      request.add_field(\"Authorization\", api_key)\n    end\n\n    say response.body\n  end\nend\n", 4096) = 740
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/tumble.rb", {st_mode=S_IFREG|0644, st_size=319, ...}) = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/tumble.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=319, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/tumble.rb", {st_mode=S_IFREG|0644, st_size=319, ...}) = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/tumble.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=319, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/tumble.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=319, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/tumble.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/tumble.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=319, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "class Gem::Commands::TumbleCommand < Gem::AbstractCommand\n  def description\n    \"Deprecated method of upgrading to Gemcutter.org for gem downloads\"\n  end\n\n  def initialize\n    super 'tumble', description\n  end\n\n  def execute\n    say \"This command is deprecated, Gemcutter.org is the primary source for gems.\"\n  end\nend\n", 4096) = 319
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/webhook.rb", {st_mode=S_IFREG|0644, st_size=3219, ...}) = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/webhook.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3219, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/webhook.rb", {st_mode=S_IFREG|0644, st_size=3219, ...}) = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/webhook.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3219, ...}) = 0
close(3)                                = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/webhook.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3219, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/webhook.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/commands/webhook.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=3219, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "class Gem::Commands::WebhookCommand < Gem::AbstractCommand\n\n  def description\n    <<-EOF\nWebhooks can be created for either specific gems or all gems. In both cases\nyou'll get a POST request of the gem in JSON format at the URL you specify in\nthe command. You can also use this command to test fire a webhook for any gem.\nEOF\n  end\n\n  def arguments\n    \"GEM_NAME       name of gem to register webhook for, or omit to list hooks.\"\n  end\n\n  def usage\n    \"#{program_name} [GEM_NAME]\"\n  end\n\n  def initialize\n    super 'webhook', \"Register a webhook that will be called any time a gem is updated on Gemcutter.\"\n    option_text = \"The URL of the webhook to\"\n\n    add_option('-a', '--add URL', \"#{option_text} add\") do |value, options|\n      options[:send] = 'add'\n      options[:url] = value\n    end\n\n    add_option('-r', '--remove URL', \"#{option_text} remove\") do |value, options|\n      options[:send] = 'remove'\n      options[:url] = value\n    end\n\n    add_option('-f', '--fire URL', \"#{option_text} testfire\") do |value, options|\n      options[:send] = 'fire'\n      options[:url] = value\n    end\n\n    add_option('-g', '--global', \"Apply hook globally\") do |value, options|\n      options[:global] = true\n    end\n\n    add_proxy_option\n  end\n\n  def execute\n    setup\n\n    if options[:url]\n      name = options[:global] ? '*' : get_one_gem_name\n      send(\"#{options[:send]}_webhook\", name, options[:url])\n    else\n      list_webhooks\n    end\n  end\n\n  def add_webhook(name, url)\n    say \"Adding webhook...\"\n    make_webhook_request(:post, name, url)\n  end\n\n  def remove_webhook(name, url)\n    say \"Removing webhook...\"\n    make_webhook_request(:delete, name, url, \"web_hooks/remove\")\n  end\n\n  def fire_webhook(name, url)\n    say \"Test firing webhook...\"\n    make_webhook_request(:post, name, url, \"web_hooks/fire\")\n  end\n\n  def list_webhooks\n    require 'json/pure' unless defined?(JSON::JSON_LOADED)\n\n    response = make_request(:get, \"web_hooks\") do |request|\n      request.add_field(\"Authorization\", api_key)\n    end\n\n    case response\n    when Net::HTTPSuccess\n      begin\n        groups = JSON.parse(response.body)\n\n        if groups.size.zero?\n          say \"You haven't added any webhooks yet.\"\n        else\n          groups.each do |group, hooks|\n            if options[:global]\n              next if group != \"all gems\"\n            elsif options[:args] && options[:args].first\n              next if group != options[:args].first\n            end\n\n            say \"#{group}:\"\n            hooks.each do |hook|\n              say \"- #{hook['url']}\"\n            end\n          end\n        end\n      rescue JSON::ParserError => json_error\n        say \"There was a problem parsing the data:\"\n        say json_error.to_s\n        terminate_interaction\n      end\n    else\n      say response.body\n      terminate_interaction\n    end\n  end\n\n  def make_webhook_request(method, name, url, api = \"web_hooks\")\n    response = make_request(method, api) do |request|\n      request.set_form_data(\"gem_name\" => name, \"url\" => url)\n      request.add_field(\"Authorization\", api_key)\n    end\n\n    case response\n    when Net::HTTPSuccess\n      say response.body\n    else\n      say response.body\n      terminate_interaction\n    end\n  end\nend\n", 4096) = 3219
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/gem_runner.rb", 0xbfe53f10) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/gem_runner.so", 0xbfe53f10) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/gem_runner.rb", {st_mode=S_IFREG|0644, st_size=2291, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/gem_runner.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2291, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/gem_runner.rb", 0xbfe53f20) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/gem_runner.rb", {st_mode=S_IFREG|0644, st_size=2291, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/gem_runner.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2291, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/gem_runner.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2291, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/gem_runner.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/gem_runner.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2291, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\nrequire 'rubygems/command_manager'\nrequire 'rubygems/config_file'\nrequire 'rubygems/doc_manager'\n\n##\n# Run an instance of the gem program.\n#\n# Gem::GemRunner is only intended for internal use by RubyGems itself.  It\n# does not form any public API and may change at any time for any reason.\n#\n# If you would like to duplicate functionality of `gem` commands, use the\n# classes they call directly.\n\nclass Gem::GemRunner\n\n  def initialize(options={})\n    @command_manager_class = options[:command_manager] || Gem::CommandManager\n    @config_file_class = options[:config_file] || Gem::ConfigFile\n    @doc_manager_class = options[:doc_manager] || Gem::DocManager\n  end\n\n  ##\n  # Run the gem command with the following arguments.\n\n  def run(args)\n    start_time = Time.now\n\n    if args.include?('--')\n      # We need to preserve the original ARGV to use for passing gem options\n      # to source gems.  If there is a -- in the line, strip all options after\n      # it...its for the source building process.\n      build_args = args[args.index(\"--\") + 1...args.length]\n      args = args[0...args.index(\"--\")]\n    end\n\n    Gem::Command.build_args = build_args if build_args\n\n    do_configuration args\n    cmd = @command_manager_class.instance\n\n    cmd.command_names.each do |command_name|\n      config_args = Gem.configuration[command_name]\n      config_args = case config_args\n                    when String\n                      config_args.split ' '\n                    else\n                      Array(config_args)\n                    end\n      Gem::Command.add_specific_extra_args command_name, config_args\n    end\n\n    cmd.run Gem.configuration.args\n    end_time = Time.now\n\n    if Gem.configuration.benchmark then\n      printf \"\\nExecution time: %0.2f seconds.\\n\", end_time - start_time\n      puts \"Press Enter to finish\"\n      STDIN.gets\n    end\n  end\n\n  private\n\n  def do_configuration(args)\n    Gem.configuration = @config_file_class.new(args)\n    Gem.use_paths(Gem.configuration[:gemhome], Gem.configuration[:gempath])\n    Gem::Command.extra_args = Gem.configuration[:gem]\n    @doc_manager_class.configured_args = Gem.configuration[:rdoc]\n  end\n\nend\n\n", 4096) = 2291
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/command_manager.rb", 0xbfe528e0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/command_manager.so", 0xbfe528e0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/command_manager.rb", {st_mode=S_IFREG|0644, st_size=4292, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/command_manager.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=4292, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/config_file.rb", 0xbfe528c0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/config_file.so", 0xbfe528c0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/config_file.rb", {st_mode=S_IFREG|0644, st_size=7551, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/config_file.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=7551, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/doc_manager.rb", 0xbfe528a0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/doc_manager.so", 0xbfe528a0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/doc_manager.rb", {st_mode=S_IFREG|0644, st_size=5602, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/doc_manager.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5602, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/doc_manager.rb", 0xbfe528b0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/doc_manager.rb", {st_mode=S_IFREG|0644, st_size=5602, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/doc_manager.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5602, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/doc_manager.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5602, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/doc_manager.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/doc_manager.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=5602, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\nrequire 'fileutils'\nrequire 'rubygems'\n\n##\n# The documentation manager generates RDoc and RI for RubyGems.\n\nclass Gem::DocManager\n\n  include Gem::UserInteraction\n\n  @configured_args = []\n\n  def self.configured_args\n    @configured_args ||= []\n  end\n\n  def self.configured_args=(args)\n    case args\n    when Array\n      @configured_args = args\n    when String\n      @configured_args = args.split\n    end\n  end\n\n  ##\n  # Load RDoc from a gem if it is available, otherwise from Ruby's stdlib\n\n  def self.load_rdoc\n    begin\n      gem 'rdoc'\n    rescue Gem::LoadError\n      # use built-in RDoc\n    end\n\n    begin\n      require 'rdoc/rdoc'\n\n      @rdoc_version = if defined? RDoc::VERSION then\n                        Gem::Version.new RDoc::VERSION\n                      else\n                        Gem::Version.new '1.0.1' # HACK parsing is hard\n                      end\n\n    rescue LoadError => e\n      raise Gem::DocumentError,\n          \"ERROR: RDoc documentation generator not installed: #{e}\"\n    end\n  end\n\n  def self.rdoc_version\n    @rdoc_version\n  end\n\n  ##\n  # Updates the RI cache for RDoc 2 if it is installed\n\n  def self.update_ri_cache\n    load_rdoc rescue return\n\n    return unless defined? RDoc::VERSION # RDoc 1 does not have VERSION\n\n    require 'rdoc/ri/driver'\n\n    options = {\n      :use_cache => true,\n      :use_system => true,\n      :use_site => true,\n      :use_home => true,\n      :use_gems => true,\n      :formatter => RDoc::RI::Formatter,\n    }\n\n    driver = RDoc::RI::Driver.new(options).class_cache\n  end\n\n  ##\n  # Create a document manager for +spec+. +rdoc_args+ contains arguments for\n  # RDoc (template etc.) as a String.\n\n  def initialize(spec, rdoc_args=\"\")\n    @spec = spec\n    @doc_dir = File.join(spec.installation_path, \"doc\", spec.full_name)\n    @rdoc_args = rdoc_args.nil? ? [] : rdoc_args.split\n  end\n\n  ##\n  # Is the RDoc documentation installed?\n\n  def rdoc_installed?\n    File.exist?(File.join(@doc_dir, \"rdoc\"))\n  end\n\n  ##\n  # Generate the RI documents for this gem spec.\n  #\n  # Note that if both RI and RDoc documents are generated from the same\n  # process, the RI docs should be done first (a likely bug in RDoc will cause\n  # RI docs generation to fail if run after RDoc).\n\n  def generate_ri\n    setup_rdoc\n    install_ri # RDoc bug, ri goes first\n\n    FileUtils.mkdir_p @doc_dir unless File.exist?(@doc_dir)\n  end\n\n  ##\n  # Generate the RDoc documents for this gem spec.\n  #\n  # Note that if both RI and RDoc documents are generated from the same\n  # process, the RI docs should be done first (a likely bug in RDoc will cause\n  # RI docs generation to fail if run after RDoc).\n\n  def generate_rdoc\n    setup_rdoc\n    install_rdoc\n\n    FileUtils.mkdir_p @doc_dir unless File.exist?(@doc_dir)\n  end\n\n  ##\n  # Generate and install RDoc into the documentation directory\n\n  def install_rdoc\n    rdoc_dir = File.join @doc_dir, 'rdoc'\n\n    FileUtils.rm_rf rdoc_dir\n\n    say \"Installing RDoc documentation for #{@spec.full_name}...\"\n    run_rdoc '--op', rdoc_dir\n  end\n\n  ##\n  # Generate and install RI into the documentation directory\n\n  def install_ri\n    ri_dir = File.join @doc_dir, 'ri'\n\n    FileUtils.rm_rf ri_dir\n\n    say \"Installing ri documentation for #{@spec.full_name}...\"\n    run_rdoc '--ri', '--op', ri_dir\n  end\n\n  ##\n  # Run RDoc with +args+, which is an ARGV style argument list\n\n  def run_rdoc(*args)\n    args << @spec.rdoc_options\n    args << self.class.configured_args\n    args << '--quiet'\n    args << @spec.require_paths.clone\n    args << @spec.extra_rdoc_files\n    args << '--title' << \"#{@spec.full_name} Documentation\"\n    args = args.flatten.map do |arg| arg.to_s end\n\n    if self.class.rdoc_version >= Gem::Version.new('2.4.0') then\n      args.delete '--inline-source'\n      args.delete '--promiscuous'\n      args.delete '-p'\n      args.delete '--one-file'\n      # HACK more\n    end\n\n    r = "..., 4096) = 4096
read(3, "ent args\n    rescue Errno::EACCES => e\n      dirname = File.dirname e.message.split(\"-\")[1].strip\n      raise Gem::FilePermissionError.new(dirname)\n    rescue RuntimeError => ex\n      alert_error \"While generating documentation for #{@spec.full_name}\"\n      ui.errs.puts \"... MESSAGE:   #{ex}\"\n      ui.errs.puts \"... RDOC args: #{args.join(' ')}\"\n      ui.errs.puts \"\\t#{ex.backtrace.join \"\\n\\t\"}\" if\n      Gem.configuration.backtrace\n      ui.errs.puts \"(continuing with the rest of the installation)\"\n    ensure\n      Dir.chdir(old_pwd)\n    end\n  end\n\n  def setup_rdoc\n    if File.exist?(@doc_dir) && !File.writable?(@doc_dir) then\n      raise Gem::FilePermissionError.new(@doc_dir)\n    end\n\n    FileUtils.mkdir_p @doc_dir unless File.exist?(@doc_dir)\n\n    self.class.load_rdoc\n  end\n\n  ##\n  # Remove RDoc and RI documentation\n\n  def uninstall_doc\n    raise Gem::FilePermissionError.new(@spec.installation_path) unless\n    File.writable? @spec.installation_path\n\n    original_name = [\n      @spec.name, @spec.version, @spec.original_platform].join '-'\n\n    doc_dir = File.join @spec.installation_path, 'doc', @spec.full_name\n    unless File.directory? doc_dir then\n      doc_dir = File.join @spec.installation_path, 'doc', original_name\n    end\n\n    FileUtils.rm_rf doc_dir\n\n    ri_dir = File.join @spec.installation_path, 'ri', @spec.full_name\n\n    unless File.directory? ri_dir then\n      ri_dir = File.join @spec.installation_path, 'ri', original_name\n    end\n\n    FileUtils.rm_rf ri_dir\n  end\n\nend\n\n", 4096) = 1506
brk(0xa09a000)                          = 0xa09a000
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/fileutils.rb", 0xbfe51270) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/fileutils.so", 0xbfe51270) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/fileutils.rb", 0xbfe51270) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/fileutils.so", 0xbfe51270) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/fileutils.rb", 0xbfe51270) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i486-linux/fileutils.so", 0xbfe51270) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/fileutils.rb", 0xbfe51270) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/i386-linux/fileutils.so", 0xbfe51270) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/fileutils.rb", 0xbfe51270) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/fileutils.so", 0xbfe51270) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/fileutils.rb", 0xbfe51270) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/fileutils.so", 0xbfe51270) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/fileutils.rb", 0xbfe51270) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/1.8/i486-linux/fileutils.so", 0xbfe51270) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/fileutils.rb", 0xbfe51270) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/vendor_ruby/fileutils.so", 0xbfe51270) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/1.8/fileutils.rb", {st_mode=S_IFREG|0644, st_size=43014, ...}) = 0
open("/usr/lib/ruby/1.8/fileutils.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=43014, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems.rb", 0xbfe51250) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems.so", 0xbfe51250) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems.rb", {st_mode=S_IFREG|0644, st_size=29096, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=29096, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/exceptions.rb", 0xbfe53ef0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/exceptions.so", 0xbfe53ef0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/exceptions.rb", {st_mode=S_IFREG|0644, st_size=2216, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/exceptions.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2216, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
gettimeofday({1263334812, 899740}, NULL) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/etc/gemrc", 0xbfe515c0)        = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/home/davidw/.gemrc", 0xbfe515c0) = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/commands/build_command.rb", 0xbfe50200) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/commands/build_command.so", 0xbfe50200) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/commands/build_command.rb", {st_mode=S_IFREG|0644, st_size=1134, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/commands/build_command.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1134, ...}) = 0
close(3)                                = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/commands/build_command.rb", 0xbfe50210) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/commands/build_command.rb", {st_mode=S_IFREG|0644, st_size=1134, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/commands/build_command.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1134, ...}) = 0
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/commands/build_command.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1134, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/commands/build_command.rb", O_RDONLY|O_LARGEFILE) = 3
close(3)                                = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/commands/build_command.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=1134, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb760a000
read(3, "require 'rubygems/command'\nrequire 'rubygems/builder'\n\nclass Gem::Commands::BuildCommand < Gem::Command\n\n  def initialize\n    super('build', 'Build a gem from a gemspec')\n  end\n\n  def arguments # :nodoc:\n    \"GEMSPEC_FILE  gemspec file name to build a gem for\"\n  end\n\n  def usage # :nodoc:\n    \"#{program_name} GEMSPEC_FILE\"\n  end\n\n  def execute\n    gemspec = get_one_gem_name\n    if File.exist?(gemspec)\n      specs = load_gemspecs(gemspec)\n      specs.each do |spec|\n        Gem::Builder.new(spec).build\n      end\n    else\n      alert_error \"Gemspec file not found: #{gemspec}\"\n    end\n  end\n\n  def load_gemspecs(filename)\n    if yaml?(filename)\n      result = []\n      open(filename) do |f|\n        begin\n          while not f.eof? and spec = Gem::Specification.from_yaml(f)\n            result << spec\n          end\n        rescue Gem::EndOfYAMLException => e\n          # OK\n        end\n      end\n    else\n      result = [Gem::Specification.load(filename)]\n    end\n    result\n  end\n\n  def yaml?(filename)\n    line = open(filename) { |f| line = f.gets }\n    result = line =~ %r{!ruby/object:Gem::Specification}\n    result\n  end\nend\n", 4096) = 1134
read(3, "", 4096)                       = 0
close(3)                                = 0
munmap(0xb760a000, 4096)                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/command.rb", 0xbfe4ebd0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/command.so", 0xbfe4ebd0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/command.rb", {st_mode=S_IFREG|0644, st_size=12126, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/command.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=12126, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/builder.rb", 0xbfe4ebb0) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/ruby/gems/1.8/gems/gemcutter-0.3.0/lib/rubygems/builder.so", 0xbfe4ebb0) = -1 ENOENT (No such file or directory)
stat64("/usr/local/lib/site_ruby/1.8/rubygems/builder.rb", {st_mode=S_IFREG|0644, st_size=2060, ...}) = 0
open("/usr/local/lib/site_ruby/1.8/rubygems/builder.rb", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=2060, ...}) = 0
close(3)                                = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_SETMASK, [], NULL)      = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
stat64("yahoo", 0xbfe51e20)             = -1 ENOENT (No such file or directory)
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
write(2, "ERROR:  Gemspec file not found: yahoo", 37) = 37
write(2, "\n", 1)                       = 1
gettimeofday({1263334812, 950863}, NULL) = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
sigprocmask(SIG_BLOCK, NULL, [])        = 0
rt_sigaction(SIGINT, {SIG_DFL, [INT], SA_RESTART}, {0x6bb440, [], 0}, 8) = 0
exit_group(0)                           = ?
